# 农场施肥

```
def check(mid, fields):
    ans = 0
    for field in fields:
        if field % mid == 0:
            ans += (field // mid)
        else:
            ans += ((field // mid) + 1)
    return ans
 
 
if __name__ == "__main__":
    nums = list(map(int,input().split(' ')))
    m,n = nums[0],nums[1]
    fields = list(map(int,input().split(' ')))
 
    left = 1
    right = max(fields)
 
    while left < right:
        mid = (right + left) / 2
        if check(mid, fields) <= n:
            right = mid
        else:
            left = mid + 1
            
    if check(left, fields) > n:
        print(-1)
    else:
        print(int(left))
```

# 直角三角形

```
def get_triangel_nums(nums,m):
    nums.sort()
    res = 0
    for i in range(m-2):
        for j in range(i+1,m-1):
            if nums[i] == nums[j]:
                break
            for k in range(j+1,m):
                if nums[k] == nums[j]:
                    break
                if nums[i]**2 + nums[j]**2 == nums[k]**2:
                    res +=1
                    break
                elif nums[i]**2 + nums[j]**2 < nums[k]**2:
                    break
    print(res)
 
n = int(input().strip())
for i in range(n):
    nums = list(map(int,input().strip().split(" ")))
    m = len(nums)
    get_triangel_nums(nums,m)
    
```

# 查找充电设备组合

```
n = int(input().strip())
nums = list(map(int,input().strip().split(" ")))
p_max = int(input().strip())
nums = [50,20,20,60]
n = 4
p_max = 90
def beibao(nums,n,p_max):
    dp = [[0 for _ in range(p_max+1)] for _ in range(n+1)]
    for i in range(n+1):
        for j in range(p_max+1):
            if i == 0 or j ==0:
                continue
            if nums[i-1] > j:
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = max(dp[i-1][j],nums[i-1] + dp[i-1][j-nums[i-1]])
    print(dp[n][p_max])
beibao(nums,n,p_max)
```

# 上班之路

```
from typing import List
 
map = [['' for _ in range(101)] for _ in range(101)]
 
 
class Solution:
    def ToCompany(self, matrix: List[List[str]], x: int, y: int, lis: List[List[int]], turn: int,
                  barricade: int) -> int:
        # 待实现函数，在此函数中实现你的代码
        if len(lis) > 1:
            ints = lis[len(lis) - 2]
            if ints[0] != x and ints[1] != y:
                turn += 1
 
        lis.append([x, y])
 
        if turn > t:
            return 0
        if matrix[x][y] == '*':
            barricade += 1
        if barricade > c:
            return 0
        if matrix[x][y] == 'T':
            return 1
 
        matrix[x][y] = 'X'
 
        if x > 0:
            if matrix[x - 1][y] != 'X':
                if self.ToCompany(matrix, x - 1, y, lis, turn, barricade) == 1:
                    return 1
                else:
                    matrix[x - 1][y] = map[x - 1][y]
                    lis.pop()
        if x < n - 1:
            if matrix[x + 1][y] != 'X':
                if self.ToCompany(matrix, x + 1, y, lis, turn, barricade) == 1:
                    return 1
                else:
                    matrix[x + 1][y] = map[x + 1][y]
                    lis.pop()
        if y > 0:
            if matrix[x][y - 1] != 'X':
                if self.ToCompany(matrix, x, y - 1, lis, turn, barricade) == 1:
                    return 1
                else:
                    matrix[x][y - 1] = map[x][y - 1]
                    lis.pop()
        if y < m - 1:
            if matrix[x][y + 1] != 'X':
                if self.ToCompany(matrix, x, y + 1, lis, turn, barricade) == 1:
                    return 1
                else:
                    matrix[x][y + 1] = map[x][y + 1]
                    lis.pop()
        return 0
 
 
if __name__ == "__main__":
    line1 = input()
    t, c = int(line1.split()[0]), int(line1.split()[1])
    line2 = input()
    n, m = int(line2.split()[0]), int(line2.split()[1])
    mapCopy = [['' for _ in range(m)] for _ in range(n)]
    x = 0
    y = 0
    for i in range(n):
        string = input()
        for j in range(m):
            map[i][j] = string[j]
            mapCopy[i][j] = map[i][j]
            if map[i][j] == 'S':
                x = i
                y = j
 
    if Solution().ToCompany(mapCopy, x, y, [], 0, 0) == 1:
        print('YES')
    else:
        print('NO')
```

# 快递投放问题

```
if __name__ == "__main__":
    strs = [x for x in input().split(' ')]
    M = int(strs[0])
    N = int(strs[1])
 
    mapPkg = {}
    for i in range(M):
        strings = [x for x in input().split(' ')]
        mapPkg[strings[0]] = strings[1] + strings[2]
 
    mapNo = {}
    for i in range(N):
        strings = [x for x in input().split(' ')]
        noList = []
        for j in range(2, len(strings)):
            noList.append(strings[j])
        mapNo[strings[0] + strings[1]] = noList
 
    resList = []
    for k, v in mapNo.items():
        for s in v:
            if k == mapPkg[s]:
                resList.append(s)
    print(' '.join(resList) if resList else 'none')
```

# 机房布局

```
if __name__ == "__main__":
    string = input()
    res = 0
    # print(len(string))
    # string = 'MIM'
    for i in range(len(string)):
        c = string[i]
        if c == 'M':
            if i + 1 < len(string) and string[i + 1] == 'I':
                res += 1
                i += 2
            elif i - 1 >= 0 and string[i - 1] == 'I':
                res += 1
            else:
                res = -1
                break
    print(res)
```

# 去除多余空格

```
def Solution(arr, string):
    quotaStart = False
    needDel = []
    for i in range(len(string)):
        if string[i] == ' ' and string[i - 1] == ' ' and not quotaStart:
            needDel.append(i)
        if string[i] == '\'':
            quotaStart = not quotaStart
    strArr = list(string)
    ans = arr
    for dell in needDel:
        strArr[dell] = ''
        for i in range(len(arr)):
            if dell < arr[i][0]:
                ans[i][0] -= 1
                ans[i][1] -= 1
    print(''.join(strArr))
    # print(ans)
    res = ''
 
    for ints in ans:
        res += ('[' + str(ints[0]) + ',' + str(ints[-1]) + '],')
    # print(res[0:len(res) - 1])
    print(res[0:-1])
 
    # print(''.join(ans))
 
 
if __name__ == "__main__":
    inputStr = input()
    strings = list(map(str, input().split(',')))
    arr = []
    for string in strings:
        strs = string.split(' ')
        start = int(strs[0])
        end = int(strs[1])
        arr.append([start, end])
    Solution(arr, inputStr)
```

# 优雅子数组

```
from typing import List
 
 
class Solution:
    def ElegantArray(self, array: List[int], n: int, k: int) -> int:
        ans = 0
        for i in range(n):
            count = {array[i]: 1}
            for j in range(i + 1, n):
                c = array[j]
                if c in count.keys():
                    count[c] += 1
                else:
                    count[c] = 1
                if count[c] >= k:
                    ans += (n - j)
                    break
        return ans
 
 
if __name__ == "__main__":
    n, k = map(int, input().split(' '))
    arr = list(map(int, input().split(' ')))
    print(Solution().ElegantArray(arr, n, k))
```

# 计算快递主站点

```
def handle(se: set, n: int) -> None:
    for i in range(len(s)):
        if i in se:
            continue
        if n != i and s[n][i] == 1:
            se.add(i)
            handle(se, i)
 
 
if __name__ == "__main__":
    N = int(input())
    s = [[0 for i in range(N)] for j in range(N)]
 
    for i in range(N):
        strInput = input().split(' ')
        for j in range(N):
            s[i][j] = int(strInput[j])
 
    se = set()
    res = 0
 
    for i in range(N):
        if i in se:
            continue
        temp = set()
        temp.add(i)
        handle(temp, i)
        for _ in temp:
            se.add(_)
        # se.union(temp)
        res += 1
    print(res)
```

# 最大数字

```
resList = []
inputStrs = []
 
 
def isChild(child) -> bool:
    index = 0
    isOver = False
    count = 0
    for i in range(len(child)):
        str = child[i]
        for j in range(index, len(inputStrs)):
            temp = inputStrs[j]
            if j == len(inputStrs) - 1:
                isOver = True
            if temp == str:
                index = j + 1
                count += 1
                break
        if isOver:
            break
    return count == len(child)
 
 
def swap(strings, indexa: int, indexb: int) -> None:
    temp = strings[indexa]
    strings[indexa] = strings[indexb]
    strings[indexb] = temp
 
 
def combine(strs, start: int, end: int) -> None:
    if start == end:
        numStr = ''
        for s in strs:
            numStr += s
        if int(numStr) not in resList and isChild(strs):
            resList.append(int(numStr))
    else:
        for i in range(start, len(strs)):
            if i != start and strs[i] == strs[start]:
                continue
            swap(strs, i, start)
            if strs[0] == '0':
                continue
            combine(strs, start + 1, end)
            swap(strs, i, start)
 
 
if __name__ == "__main__":
    inputStrs = input()
    map = {}
    for inputStr in inputStrs:
        map.setdefault(inputStr, 0)
        map[inputStr] += 1
    lis = []
    for k, v in map.items():
        num = k
        lis.append(num)
        if v >= 2:
            lis.append(num)
 
    strsNum = ['' for i in range(len(lis))]
    for i in range(len(lis)):
        strsNum[i] = lis[i]
    combine(strsNum, 0, len(strsNum) - 1)
    resList.sort()
    print(resList[len(resList) - 1])
```

# 分奖金

```
if __name__ == "__main__":
    n = int(input())
    ints = list(map(int, input().split(' ')))
    for i in range(n):
        for j in range(i + 1, n):
            if ints[i] < ints[j]:
                ints[i] = (ints[j] - ints[i]) * (i + 1)
                break
    print(' '.join([str(i) for i in ints]), end='')
```

# 最差产品奖

```
 
 
if __name__ == "__main__":
    M = int(input())
    line = list(map(int, input().split(',')))
    vector = []
    for i in range(len(line) - M + 1):
        minn = min(line[i:i+M])
        vector.append(minn)
 
    print(','.join([str(x) for x in vector]))
```

# 几何平均值最大子数组

```
import math
def calc_mean(num_list):
    value = 1
    for num in num_list:
        value *= num
    return math.pow(value, 1 / len(num_list))
 
 
def solution():
    line_list = input().split(" ")
    N, L = int(line_list[0]), int(line_list[1])
    num_list = []
    for i in range(N):
        num = float(input())
        num_list.append(num)
 
    lo = 0
    size = 0
    max_mean = -math.inf
    for i in range(0, N - L + 1):
        for j in range(i + L, N + 1):
            mean_value = calc_mean(num_list[i: j])
            # print(num_list[i: j], mean_value)
            if mean_value - max_mean >= 1e-5:
                max_mean = mean_value
                lo = i
                size = j - i
            elif abs(mean_value - max_mean) <= 1e-10:
                # print("hhhh", mean_value, max_mean)
                if j - i < size:
                    lo = i
                    size = j - i
            # print(max_mean, lo, size)
    print(lo, size)
 
 
if __name__ == '__main__':
    solution()
```

# 服务中心选址

```
if __name__ == "__main__":
    n = int(input())
 
    # 转化为点
    points = []
    for i in range(n):
        data = [int(x) for x in input().split(" ")]
        a = data[0]
        b = data[1]
        if i == 0:
            points.append(b)
        elif i == n - 1:
            points.append(a)
        else:
            if i < n / 2:
                points.append(b)
            else:
                points.append(a)
 
    # 按照点大小排序
    points.sort()
 
    # 最佳位置
    pos = -1
    if len(points) % 2 == 0:
        pos = int((len(points) - 1) / 2)
    else:
        pos = int(len(points) / 2)
 
    # 计算距离
    result = 0
    for i in range(len(points)):
        if i != pos:
            result += abs(points[i] - points[pos])
 
    print(result)
```

# 日志限流

```
n = int(input().strip())
nums = list(map(int,input().strip().split(" ")))
total = int(input().strip())
n = 6
nums = [3,3,8,7,10,15]
total = 40
 
nums.sort(reverse=True)
print(nums)
 
if sum(nums) < total:
    print(-1)
else:
    left = total//n - 1
    right = nums[0]
    result =left
    while right > left+1:
        mid = (right + left)//2
        cur_sum = 0
        for i in range(n):
            cur_sum +=min(nums[i],mid)
            if cur_sum>total:
                break
        if cur_sum >total:
            right = mid
        elif cur_sum <total:
            left = mid
            result = mid
        else:
            result = mid
    print(result)
```

# 最优资源分配

```
def main(m, n,tasks):
    chip = [0]*n
 
    for i in range(len(tasks)):
        c = tasks[i]
        if c == 'A':
            conf = 1
        elif c == 'B':
            conf = 2
        else:
            conf = 8
        for j in range(n):
            used = chip[j]
            if m - used >= conf:
                chip[j] += conf
                break
    for i in range(n):
        res = ''
        used = chip[i]
        for j in range(m):
            res += '1' if j < used else "0"
        print(res)
 
 
if __name__ == "__main__":
    # m = int(input().strip())
    # n = int(input().strip())
    # tasks = input().strip()
    m = 8
    n = 2
    tasks = "ACBCB"
    main(m, n, tasks)
```

# 最佳对手

```
# n = int(input().strip())
# d = int(input().strip())
# nums = list(map(int,input().strip().split(" ")))
n,d=6,20
nums= [81,87,47,59,81,18]
def main(nums):
    nums.sort()
    left_count = 0
    left_total = 0
    right_count = 0
    right_total = 0
    flag = True
    for i in range(1, n):
        diff = nums[i] - nums[i - 1]
        if diff <= d:
            flag = False
            if i % 2 == 0:
                left_count += 1
                left_total += diff
            else:
                right_count += 1
                right_total += diff
    if flag:
        return -1
    if left_count > right_count:
        return left_total
    if left_count < right_count:
        return right_total
 
    return min(left_total, right_total)
 
print(main(nums))
```

# 天然蓄水库

```
from functools import cmp_to_key
#nums = list(map(int,input().strip().split(" ")))
nums = [1, 9, 6, 2, 5, 4, 9, 3, 7]
# nums = [3, 2, 1]
# nums = [3, 1, 2]
n = len(nums)
 
 
def comp(x, y):
    if x[0] != y[0]:
        return y[0] - x[0]
    else:
        return y[1][1]-x[1][0]
 
 
def main():
    res = []
    for i in range(n-1):
        left = nums[i]
        right = nums[i+1]
        if left < right:
            continue
        for j in range(i+2, n):
            if nums[j] > right:
                right = nums[j]
                height = min(left, right)
                len1 = j-i-1
                total = len1 * height - sum(nums[i+1:j])
                res.append([total, (i, j)])
            if nums[j] >= left:
                # 重新来，因为下次会重新记录
                break
    if len(res) == 0:
        print(0)
    else:
        res.sort(key=cmp_to_key(comp))
        print("%d %d:%d" % (res[0][1][0], res[0][1][1], res[0][0]))
 
main()
```

# Linux发行版的数量

```
n = int(input().strip())
nums = []
for i in range(n):
    num = list(map(int,input().strip().split(" ")))
    nums.append(num)
n = 4
 
nums = [[1, 1, 0, 0],
        [1, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 0, 0, 1]]
 
nums = [[1, 1, 0, 1],
        [1, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 0, 0, 1]]
 
res = []
 
 
def dfs(k, visited):
    items = []
    for i in range(n):
        if k != i and nums[k][i] == 1:
            if i not in visited:
                visited.append(i)
                items.append(dfs(i,visited))
    max_ = 0
    if len(items) != 0:
        max_ = max(items)
 
    return max_ + 1
 
 
for j in range(n):
    res.append(dfs(j,[j]))
 
print(max(res))
```

# 组合出合法最小数

```
from functools import cmp_to_key
nums = ["13", "000045", "09", "56"]
def comp(x,y):
    len1 = len(x)
    len2 = len(y)
    min_ = min(len1,len2)
    for i in range(min_):
        if x[i] != y[i]:
            return int(x[i]) - int(y[i])
    if x + y > y + x:
        return 1
    else:
        return -1
nums.sort(key = cmp_to_key(comp))
result = "".join(nums)
if result == "0":
    print(result)
else:
    print(result.lstrip("0"))

```

#  寻找相似单词

```

n = 4
nums = ["dasd","bca","tad","abc"]
nums = ["acB","Bac","aBc","cBa"]
word = "cBa"
 
word_list = list(word)
word_list.sort()
res = []
for num in nums:
    num_list = list(num)
    num_list.sort()
    if len(num_list) == len(word_list) and num_list == word_list:
        res.append(num)
 
res.sort()
 
print("null") if len(res) == 0 else print(" ".join(res))
```

# 递增字符串

```
#string = input().strip()
string = "AABBABAAA"
count = string.count("BA")
res = count
while count !=0:
    string = string.replace("BA","")
    print(string)
    count = string.count("BA")
    res +=count
print(res)
```

#  微服务的集成测试

```

n = 3
use_times = [[5,0,0],
             [1,10,1],
             [1,0,11]]
k=2
 
n = 5
use_times = [[1,0,0,0,0],
             [0,2,0,0,0],
             [1,1,3,0,0],
             [1,1,0,4,0],
             [0,0,1,1,5]]
k=5
# 使用递归来求解
def dfs(k):
    # 获取所有依赖以及递归依赖的总和
    times = []
    for i in range(n):
        if k!=i and use_times[k][i] ==1:
            times.append(dfs(i))
    max_=0
    # 求取依赖中最大值，因为可以同时进行，所以求出最大的依赖时间即可
    if len(times) != 0:
        max_ = max(times)
    return max_ + use_times[k][k]
 
print(dfs(k-1))
```

# 快速开租建站

```
from collections import defaultdict

 
task_num = 5
rel_num = 5
nums = [[0,4],
        [1,2],
        [1,3],
        [2,3],
        [2,4]]
 
rel_dict = defaultdict(list)
 
for rel in nums:
    rel_dict[rel[1]].append(rel[0])
 
total_nums = [i for i in range(task_num)]
 
res = []
finish_task = [i for i in total_nums if i not in rel_dict.keys()]
while len(total_nums) != 0:
    finish_task = [i for i in total_nums if i not in rel_dict.keys()]
    res.append(finish_task)
    total_nums = list(rel_dict.keys())
    for num in total_nums:
        temp_tasks = [i for i in rel_dict[num] if i not in finish_task]
        if len(temp_tasks) == 0:
            del rel_dict[num]
        else:
            rel_dict[num] = temp_tasks
print(len(res))
```

# 区块链文件转储系统

```
# total = int(input().strip())
# nums = list(map(int,input().strip().split(" ")))
#滑动窗口来解决
total = 1000
nums=[100,1000,500,400,400,150]
length =  len(nums)
max_=0
for i in range(length):
    temp =0
    for j in range(i,length):
        temp += nums[j]
        if temp <=total:
            max_ = max(max_,temp)
        else:
            break
print(max_)
```

# 识图谱新词挖掘

```
from collections import Counter
content = input().strip()
word = input().strip()
#通过Python固有类来判断单词出现的次数
word_dict = dict(Counter(word))
 
n = len(content)
m = len(word)
res = 0
if n>=m:
    #通过滑动窗口来获取总的单词数量
    for i in range(n-m+1):
        #print(i)
        temp_word = content[i:i+m]
        temp_word_dict = dict(Counter(temp_word))
        if temp_word_dict == word_dict:
            res+=1
print(res)
```

# 静态扫描

```
m = int(input().strip())
file_flags = list(map(int,input().strip().split(" ")))
file_sizes = list(map(int,input().strip().split(" ")))
def main(m, file_flags, file_sizes):
    #文件相同标识出现的次数
    count_dict = {}
    #相同标识文件的大小
    size_dict = {}
 
    for i in range(len(file_flags)):
        file_flag = file_flags[i]
        if file_flag in count_dict:
            count_dict[file_flag] += 1
        else:
            count_dict[file_flag] = 1
 
        if file_flag not in size_dict:
            size_dict[file_flag] = file_sizes[i]
 
    total = 0
    for file_flag in count_dict:
        #每次都重新扫描和扫描一次+缓存的成本中取最小，PS：只要需要缓存就得必须有一次扫描
        total += min(count_dict[file_flag]*size_dict[file_flag] , size_dict[file_flag] + m)
 
    print(total)
 
main(m, file_flags, file_sizes)
 
 
```

# 人数最多的站点

```
import heapq
n = 3
nums = [[1,3],
        [2,4],
        [1,4]]
 
def main(nums):
    nums.sort(key=lambda x:x[0])
    heap = []
    heapq.heapify(heap)
    max_ = 0
    res = nums[0][0]
    for num in nums:
        start = num[0]
        end = num[1]
        while len(heap) >0:
            top = heapq.nsmallest(1,heap)
            if top[0] < start:
                heapq.heappop(heap)
            else:
                break
        heapq.heappush(heap,end)
 
        if len(heap) > max_:
            max_ = len(heap)
            res = start
    return res
 
print(main(nums))
```

# 优秀学员统计

```
from collections import Counter
n = int(input().strip())
nums = list(map(int,input().strip().split(" ")))
all_record = []
 
#总共有打卡记录人数最开始出现的打卡时间
record_emp = {}
 
for i in range(30):
    if nums[i] == 1:
        temp = int(input().strip())
        all_record.append(temp)
        if temp not in record_emp:
            record_emp[temp] = i
    else:
        temp_list = list(map(int,input().strip().split(" ")))
        all_record.extend(temp_list)
        for temp in temp_list:
            if temp not in record_emp:
                record_emp[temp] = i
 
#根据题意要求进行排序
def comp(x,y):
    #先根据次数进行排序
    if x[1]!=y[1]:
        return y[1] - x[1]
    else:
        #如果次数相当则根据出现的时间进行排序
        if record_emp[x[0]] != record_emp[y[0]]:
            return record_emp[x[0]] - record_emp[y[0]]
        else:
            #如果时间相同，则根据id进行排序
            return x[0] - y[0]
 
record_dict = dict(Counter(all_record))
record_list = list(record_dict.items())
 
record_list.sort(key=functools.cmp_to_key(comp))
res = [item[0] for item in record_list]
if len(res)>=5:
    print(" ".join(map(str,res[0:5])))
else:
    print(" ".join(map(str, res)))
```

# 异常的打卡记录

```
from collections import defaultdict

n=2
 
 
employ_dict = defaultdict(list)
res = []
for i in range(n):
    record = copy.deepcopy(records[i])
    record.append(i)
 
    id = record[0]
    act_device = record[3]
    reg_device = record[4]
 
    #先判断设备号和注册号是否一直，如果一样，则放到字典里，如果不一样，则视为打开异常
    if act_device == reg_device:
        if id in employ_dict:
            employ_dict[id].append(record)
        else:
            employ_dict[id] = [record]
    else:
        res.append(record[5])
 
for id in employ_dict:
    #获取当前id的所有打卡记录
    id_records = employ_dict[id]
    num = len(id_records)
    #按打卡时间升序排序
    id_records.sort(key=lambda x:len(x[1]))
    for i in range(num):
        time1 = int(id_records[i][1])
        dis1 = int(id_records[i][2])
 
        for j in range(i+1,num):
            time2 = int(id_records[j][1])
            dis2 = int(id_records[j][2])
 
            #如果两次打卡时间超过60分钟，则不计入异常，因为是升序排列，所以后面也不需要再检查
            if time2 - time1 >=60:
                break
            else:
                #如果两次打开时间小于60分钟，且打开距离超过5km,则2次打开记录算做异常
                if abs(dis2-dis1)>5:
                    if id_records[i][5] not in res:
                        res.append(id_records[i][5])
                    if id_records[j][5] not in res:
                        res.append(id_records[j][5])
if res == []:
    print("null")
else:
    res.sort()
    result = [" ".join(records[i]) for i in res]
    print(";".join(result))
```

# 基站维护工程师

```

n = 4
nums = [
        [1, 2, 3 ,3],
        [2 ,0, 2 ,3],
        [0 ,3, 2 ,4],
        [3 ,0 ,0 ,3]]
 
def dfs(n,visited,path_list,res):
    if len(path_list) == n-1:
        res.append(path_list.copy())
        return
    for i in range(1,n):
        if visited[i] == False:
            path_list.append(i)
            visited[i] = True
            dfs(n, visited, path_list, res)
            visited[i] = False
            path_list.pop()
 
def main(nums,n):
    visited = [False]*n
    path_list = []
    res = []
    dfs(n, visited, path_list, res)
 
    result = float("inf")
    for path in res:
        des = nums[0][path[0]]
        for i in range(len(path)-1):
            p = path[i]
            c = path[i+1]
            des+=nums[p][c]
        des+=nums[path[-1]][0]
        result = min(result,des)
    return result
 
print(main(nums,n))
```

# 数字加减游戏

```
s,t,a,b = map(int,input().strip().split(" "))
res = 0
 
value = t-s
while True:
    if (value-a*res)%b ==0 or (value+a*res)%b ==0:
        break
    res+=1
print(res)
```

# 简单的解压缩算法

```
str1 = input().strip()
str1 = "{A3B1{C}3}3"
# res = "AAABCCCAAABCCCAAABCCC"
 
def main():
    stack = []
    index_s = []
    for i in str1:
        if i >="0" and i<="9":
            # top = stack.pop()
            repeat = 0 if int(i) <= 1 else int(i) - 1
            if stack[-1]  == "}":
                left = index_s.pop()
                stack.pop(left)
                stack.pop()
                temp = stack[left:]
                temp_str = "".join(temp)
                stack.append(temp_str*repeat)
            else:
                stack.append(stack[-1] * repeat)
            continue
        if i=="{":
            index_s.append(len(stack))
        stack.append(i)
    print("".join(stack))
main()
```

# 二进制差异数

```
# n = int(input().strip())
# nums = list(map(int,input().strip().split(" ")))
n = 4
nums = [4,3,5,2]
 
hight_bit = [0]*30 #最多30位
for num in nums:
    num_bit = str(bin(num))[2:] #这样所求出的二进制字符串是没有前导0的，即以1开头或者为0
    length = len(num_bit)
 
    #区分二进制为0余其他
    if num_bit == "0":
        hight_bit[0]+=1
    else:
        hight_bit[length]+=1
        
res = 0
for i in range(30):
    for j in range(i+1,30):
        res+=hight_bit[i]*hight_bit[j]
 
print(res)
```

# 最多等和不相交连续子序列

```
from functools import cmp_to_key
 
n = int(input().strip())
nums = list(map(int,input().strip().split(" ")))
 
nums_dict = {}
 
def compy(x,y):
    return x[0] - y[0] if x[1] == y[1] else x[1] - y[1]
 
def comp(num_list):
    count = 1
    num_list.sort(key=cmp_to_key(compy),reverse=True)
 
    s1= num_list[0][0]
    for i in range(1, len(num_list)):
        s2, e2 = num_list[i][0],num_list[i][1]
        if e2 < s1:
            count += 1
            s1 = s2
    return count
def main(nums,n):
 
    #求出所有连续子区间的和
    for i in range(n):
        key = nums[i]
        if key in nums_dict:
            nums_dict[key].append([i,i])
        else:
            nums_dict[key] = [[i,i]]
 
        for j in range(i+1,n):
            key+=nums[j]
            if key in nums_dict:
                nums_dict[key].append([i, j])
            else:
                nums_dict[key] = [[i, j]]
 
    #寻求最大值
    max_=0
    for key in nums_dict:
        max_ = max(max_,comp(nums_dict[key]))
    print(max_)
 
main(nums,n)
```

# 猜字谜

```
issues = ["conection"]
answers = ["connection","today"]
issues = ["bdni","wooood"]
answers = ["bind","wrong","wood"]
 
def main(issues,answers):
    res = []
    for issue in issues:
        issue_list = list(set(issue))
        issue_list.sort()
        new_issue = "".join(issue_list)
        find = False
 
        for ans in answers:
            ans_list = list(set(ans))
            ans_list.sort()
            new_ans = "".join(ans_list)
            if new_ans == new_issue:
                res.append(ans)
                find = True
                break
        if not find:
            res.append("not found")
 
    print(",".join(res))
 
main(issues,answers)
```

# 货币单位换算

```
import re
def main(arr):
    pattern = re.compile("(\d+)([CNY|JPY|HKD|EUR|GBP|fen|cents|sen|eurocents|pence]+)")
    exchange = {
        "CNY":100.0,
        "JPY": (100.0 / 1825) * 100,
        "HKD":(100.0 / 123) * 100,
        "EUR":(100.0 / 14) * 100,
        "GBP":(100.0 / 12) * 100,
        "fen":1.0,
        "cents":100.0 / 123,
        "sen":100.0 / 1825,
        "eurocents":100.0 / 14,
        "pence":100.0 / 12
    }
    res = 0.0
    for temp_str in arr:
 
        results = pattern.findall(temp_str)
        print(results)
        for result in results:
            amount = result[0]
            unit = result[1]
            res+=float(amount)*exchange[unit]
    print(int(res))
 
num = int(input().strip().split(" "))
arr = []
for i in range(num):
    arr.append(input().strip().split(" "))
arr = ["100CNY"]
#arr = ["3000fen"]
arr = ["20CNY53fen","53HKD87cents"]
main(arr)
```

# 查找单入口空闲区域

```
n,m = map(int,input().strip().split(" "))
grids = []
for i in range(n):
    grids.append(input().strip().split(" "))
n = 4
m = 4
grids = [["X","X","X","X"],
         ["X","O","O","X"],
         ["X","O","O","X"],
         ["X","O","X","X"]]
 
n = 4
m = 5
grids = [["X","X","X","X","X"],
         ["O","O","O","O","X"],
         ["X","O","O","O","X"],
         ["X","O","X","X","O"]]
 
offset = [(0,-1),(0,1),(-1,0),(1,0)]
visited = []
def dfs(i,j,count,enter):
    pos = (i,j)
 
    if i<0 or i>=n or j<0 or j>=m or grids[i][j]=="X" or pos in visited:
        return count
    visited.append(pos)
 
    if i ==0 or i == n-1 or j==0 or j==m-1:
        enter.append(pos)
 
    count+=1
 
    for x,y in offset:
        new_x = i + x
        new_y = j + y
        count = dfs(new_x,new_y,count,enter)
 
    return count
 
def main(grids,n,m):
    res = []
    for i in range(n):
        for j in range(m):
            if grids[i][j] == "O" and (i,j) not in visited:
                enter = []
                count = dfs(i,j,0,enter)
                if len(enter) == 1:
                    pos = enter[0]
                    res.append([pos[0],pos[1],count])
 
    if len(res) == 0:
        return "NULL"
    res.sort(key=lambda x:x[2])
 
    if len(res) == 1 or res[0][2] > res[1][2]:
        return " ".join(map(str,res[0]))
    else:
        return res[0][2]
 
res = main(grids,n,m)
print(res)
```

# 任务总执行时长

```
nums = list(map(int,input().strip().split(" ")))
nums = [1,2,3]
nums = [2,3,3]
 
def main(taska,taskb,num):
 
    if taska==taskb:
        return [taska*num]
    res = []
    for i in range(num+1):
        res.append(taska*i+taskb*(num-i))
    return res
 
result = main(nums[0],nums[1],nums[2])
result.sort()
print(result)
```

# 整理扑克牌

```
nums = list(map(int,input().strip().split(" ")))
nums = [1,3,3,3,2,1,5]
nums = [4,4,2,1,2,1,3,3,3,4]
# nums.pop(0),7,7,7,7,8,8,8,8,8
#print(nums)
def main(nums):
 
    #统计各种牌面的数量
    card = dict(Counter(nums))
    #print(card)
 
    #统计组合，4代表炸弹，3+2代表葫芦，3代表三张，2代表对子，1代表单张
    combine = defaultdict(list)
    for key,value in card.items():
        if value == 3:
            combine[3].append(key)
        elif value == 2:
            combine[2].append(key)
        elif value == 1:
            combine[1].append(key)
        else:
            combine[4].append([key,value])
 
    #炸弹，三张，对子都进行降序排列
    combine[4].sort(key=lambda x:x[0]*x[1],reverse=True)
    combine[3].sort(reverse=True)
    combine[2].sort(reverse=True)
    #print(combine)
 
    #尝试组合出葫芦
    while combine[3]!=[]:
        if len(combine[2]) == 0 and len(combine[3]) == 1:
            break
        san_top = combine[3].pop(0)
        temp=0
        if len(combine[2]) == 0 or (len(combine[3])>0 and combine[3][0] > combine[2][0]):
            temp = combine[3].pop(0)
            combine[1].append(temp)
        else:
            temp = combine[2].pop(0)
        combine["3+2"].append([san_top,temp])
 
    combine[1].sort(reverse=True)
 
 
    res = []
    #分别按顺序将炸弹，葫芦，三张，对子，单张放到结果中
    for vals in combine[4]:
        score = vals[0]
        count = vals[1]
        res.extend([score]*count)
 
    for vals in combine["3+2"]:
        san = vals[0]
        er = vals[1]
        res.extend([san] * 3)
        res.extend([er] * 2)
 
    for vals in combine[3]:
        res.extend([vals] * 3)
 
    for vals in combine[2]:
        res.extend([vals] * 2)
 
    for vals in combine[1]:
        res.append(vals)
 
    print(" ".join(map(str,res)))
main(nums)
```

# 找数字|找等值元素

```

n = 3
m = 5
matrix = [[0,3,5,4,2],
          [2,5,7,8,3],
          [2,5,4,2,4]]
 
def main(matrix,n,m):
    num_dict = {}
 
    #获取相同数字所在矩阵的相同位置
    for i in range(n):
        for j in range(m):
            num = matrix[i][j]
            arr1 = [i,j]
 
            if num in num_dict:
                num_dict[num].append(arr1)
            else:
                num_dict[num] = [arr1]
 
    #找最相近的2个值得坐标
    for i in range(n):
        for j in range(m):
            num = matrix[i][j]
            min_dis = float('inf')
            for pos in num_dict[num]:
                i1 = pos[0]
                j1 = pos[1]
 
                if i1 !=i or j1 !=j:
                    dis = abs(i1-i) + abs(j1-j)
                    min_dis = min(min_dis,dis)
            matrix[i][j] = -1 if min_dis ==float('inf') else min_dis
 
    print(matrix)
main(matrix,n,m)
```

# 查找重复代码

```
# s1 = input().strip()
# s2 = input().strip()
s1="hello123world"
s2="hello123abc4"
 
s1="rghello123wohellord66665rld"
s2="vfhello123abc4hellord66665"
def main(s1,s2):
    len1 = len(s1)
    len2 = len(s2)
    dp = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
 
    max=0
    res = ""
    for i in range(1,len1):
        for j in range(1, len2):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]+1
                if dp[i][j]>max:
                    max = dp[i][j]
                    res = s1[i-max:i]
            else:
                dp[i][j]=0
    print(res)
main(s1,s2)
```

# 预订酒店

```
# n,k,x = map(int,input().strip().split(" "))
# nums = list(map(int,input().strip().split(" ")))
n = 10
k=5
x=6
nums = [1 ,2 ,3 ,4 ,5, 6, 7, 8, 9, 10]
res = []
for i in range(n):
    temp = abs(x-nums[i])
    res.append((temp,nums[i]))
res.sort()
# print(res)
result = []
for i in range(k):
    result.append(res[i][1])
result.sort()
print(result)
```

#  获取最大软件版本号

```
s1 = "002.0005.1-c"
s2 = "2.5.1-aDa"
# s2 = "1.4.2-D"
s1_nums= s1.split("-")
s2_nums = s2.split("-")
ver1 = s1_nums[0].split(".")
ver2 = s2_nums[0].split(".")
new_s1 = ["0","0","0",""]
new_s2 = ["0","0","0",""]
for i in range(len(ver1)):
    new_s1[i] = ver1[i]
if len(s1_nums)==2:
    new_s1[3] = s1_nums[1]
 
for i in range(len(ver2)):
    new_s2[i] = ver2[i]
if len(s2_nums)==2:
    new_s2[3] = s2_nums[1]
 
res = 1
for i in range(4):
    if i==3 :
        res = 1 if new_s1[i] > new_s2[i] else 2
        break
    if int(new_s1[i]) > int(new_s2[i]):
        res=1
        break
    elif int(new_s1[i]) < int(new_s2[i]):
        res= 2
        break
 
print(s1 if res ==1 else s2)
```

#  简单的自动曝光

```
# nums = list(map(int,input().strip().strip("")))
nums = [255,25,255]
nums = [0,0,255]
nums = [0,0,0,0]
result = []
#因为中位数求128.而且数组内的值为0-255，所以最多循环-18-128即可
for i in range(-128,129):
    count = 0
    total = 0
    for j in nums:
        temp = i+j
        if temp<0:
            temp=0
        elif temp>255:
            temp=255
        total+=temp
    abs_res = abs(128-total/len(nums))
    result.append((abs_res,i))
new_result = result.sort(key=lambda x:(x[0],x[1]))
print(result[0][-1])
```

# 开放日活动|取出尽量少的球

```
# SUM,length = map(int,input().strip().split(" "))
# bucketBallNums = list(map(int,input().strip().split(",")))
SUM = 14
length= 7
bucketBallNums = [2,3,2,5,5,1,4]
max_num = max(bucketBallNums)
total = sum(bucketBallNums)
maxCapacity = 0
if total>SUM:
    for i in range(1,max_num):
        res = []
        for j in bucketBallNums:
            if j<=i:
                res.append(j)
            else:
                res.append(i)
        temp_total = sum(res)
        if temp_total<=SUM:
            maxCapacity = i
        else:
            result = []
            for k in bucketBallNums:
                if k > maxCapacity:
                    result.append(k-maxCapacity)
                else:
                    result.append(0)
            print(result)
            break
else:
    print([])
```

# 投篮大赛

```
# s1 = input().strip().split(" ")
s1 = ["5","2","C","D","+"]
stack = []
for i in s1:
    if i == "C":
        if stack == []:
            continue
        else:
            stack.pop(-1)
    elif i == "D":
        if stack == []:
            continue
        else:
            temp = stack[-1]
            stack.append(temp*2)
    elif i == "+":
        if stack ==[]:
            continue
        elif len(stack) ==1:
            stack.append(stack[0])
        else:
            temp = sum(stack[-2:])
            stack.append(temp)
    else:
        stack.append(int(i))
print(sum(stack))
```

# 士兵过河

```
def get_shorter_time(a, b):
    if a * 10 < b:
        return a * 10
    return b
 
 
if __name__ == "__main__":
    N = int(input())
    T = int(input())
    a = [int(x) for x in input().split(" ")]
    a = sorted(a)
 
    dp = [0 for x in range(N)]
 
    # 初始状态 0 和 1
    dp[0] = a[0]
    dp[1] = get_shorter_time(a[0], a[1])
    time_flag = True
    if dp[0] > T:
        print("0 0")
    elif dp[1] > T:
        print(str(1) + " " + str(dp[0]))
    else:
        # 状态转移方程
        for i in range(2, N):
            dp[i] = min(dp[i - 1] + a[0] + get_shorter_time(a[0], a[i]),
                        dp[i - 2] + a[0] + get_shorter_time(a[i - 1], a[i]) + a[1] + get_shorter_time(a[0], a[1]))
 
            # 耗时超T立马结束
            if dp[i] > T:
                print(str(i) + " " + str(dp[i - 1]))
                time_flag = False
                break
 
    if time_flag:
        print(str(N) + " " + str(dp[N - 1]))
```

# 最大报酬

```
import functools
from typing import List
 
 
class Solution:
    def compare(self, arr1: List[int], arr2: List[int]) -> int:  # 自定义比较两个列表的方法
        r1 = 1.0 * arr1[1] / arr1[0]
        r2 = 1.0 * arr2[1] / arr2[0]
        diffR = int(r2 - r1)
        if diffR == 0:
            return arr1[0] - arr2[0]
        return diffR
 
    def func(self, jobs: List[List[int]], T: int) -> int:
        result = 0
        # 自定义的方法对jobs列表进行排序
        jobs = sorted(jobs, key=functools.cmp_to_key(self.compare))
        sumTime = 0
        for job in jobs:
            if job[0] + sumTime > T:
                continue
            sumTime += job[0]
            result += job[1]
        return result
 
 
def inputParams():
    params = [int(x) for x in input().split(" ")]
    T = params[0]
    n = params[1]
    vector = []
    for i in range(n):
        temp = list(map(int, input().split()))
        vector.append(temp)
    object = Solution()
    res = object.func(vector, T)
    print(res)
 
 
if __name__ == "__main__":
    while 1:
        try:
            inputParams()
        except Exception as e:
            break
```

# 最优高铁城市修建方案

```
import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Scanner;
 
class edge {
    int from;
    int to;
    int cost;
 
    public edge(int from, int to, int cost) {
        this.from = from;
        this.to = to;
        this.cost = cost;
    }
}
 
class Uniform {
    int[] root;
 
    public Uniform(int n) {
        root = new int[n];
        for (int i = 0; i < n; i++) root[i] = i;
    }
 
    public int find(int x) {
        if (root[x] == x) return root[x];
        return root[x] = find(root[x]);
 
    }
 
    public void union(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx != ry) {
            root[rx] = ry;
        }
    }
 
    public boolean check(int x, int y) {
        return find(x) == find(y);
    }
}
 
public class Main {
 
    public static void solution_01() {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        edge[] edges = new edge[m];
        // int[][] graph = new int[1005][1005];
        HashMap<String, Integer> map = new HashMap<>();
        for (int i = 0; i < m; i++) {
            int from = sc.nextInt();
            int to = sc.nextInt();
            int cost = sc.nextInt();
            edges[i] = new edge(from, to, cost);
 
            StringBuilder key = new StringBuilder();
            key.append(edges[i].from);
            key.append(edges[i].to);
            map.put(key.toString(), i);
            key = new StringBuilder();
            key.append(edges[i].to);
            key.append(edges[i].from);
            map.put(key.toString(), i);
 
        }
        //然后是必须要选择的边
        int res = 0;
        Uniform uf = new Uniform(n + 1);
        boolean[] vis = new boolean[n];
        int egs = 0;
        for (int j = 0; j < k; j++) {
            int from = sc.nextInt();
            int to = sc.nextInt();
            StringBuilder key = new StringBuilder();
            key.append(from);
            key.append(to);
            uf.union(from, to);
            int id = map.get(key.toString());
            res += edges[id].cost;
            vis[id] = true;
            egs++;
        }
        PriorityQueue<edge> Q = new PriorityQueue<>(new Comparator<edge>() {
            @Override
            public int compare(edge o1, edge o2) {
                return o1.cost - o2.cost;
            }
        });
        for (int i = 0; i < n; i++) {
            if (!vis[i]) Q.offer(edges[i]);
        }
        while (!Q.isEmpty()) {
            edge cur = Q.poll();
            if (uf.check(cur.from, cur.to)) continue;
            res += cur.cost;
            uf.union(cur.from, cur.to);
            egs++;
        }
        if (egs == n - 1) {
            System.out.println(res);
        } else System.out.println(-1);
    }
    public static void main(String[] args) {
        solution_01();
    }
}
```

# 计算网络信号

```
import java.util.LinkedList;
import java.util.Scanner;
 
public class Main {
    private static final LinkedList<Block> blocks = new LinkedList<>();
    private static final int[][] dic = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
 
    public static void main(String[] args) {
 
        try (Scanner scanner = new Scanner(System.in)) {
            int m = scanner.nextInt();
            int n = scanner.nextInt();
            int[][] matrix = new int[m][n];
            int[] src = new int[2];
            int[] dst = new int[2];
            for (int x = 0; x < matrix.length; x++) {
                for (int y = 0; y < matrix[x].length; y++) {
                    matrix[x][y] = scanner.nextInt();
                    if (matrix[x][y] > 0) {
                        src[0] = x;
                        src[1] = y;
                    }
                }
            }
            dst[0] = scanner.nextInt();
            dst[1] = scanner.nextInt();
            int res = solution(matrix, src, dst);
            System.out.print(res);
        }
    }
 
    private static int solution(int[][] matrix, int[] src, int[] dst) {
 
        int x = src[0];
        int y = src[1];
 
        blocks.add(new Block(x, y, matrix[x][y]));
        while (blocks.size() > 0) {
            Block block = blocks.removeFirst();
            diffuse(matrix, block.x, block.y, block.d);
        }
 
        return matrix[dst[0]][dst[1]];
    }
 
    private static void diffuse(int[][] matrix, int x, int y, int d) {
        for (int[] di : dic) {
            int newX = x + di[0], newY = y + di[1];
            if (newX >= 0 && newX < matrix.length && newY >= 0 && newY < matrix[0].length) {
                int next = matrix[newX][newY];
                if (next == 0) {
                    matrix[newX][newY] = d - 1;
                }
                if (d > 2 && next != -1) {
                    blocks.add(new Block(newX, newY, d - 1));
                }
            }
        }
    }
 
    private static class Block {
        int x;
        int y;
        int d;
 
        public Block(int x, int y, int d) {
            this.x = x;
            this.y = y;
            this.d = d;
        }
    }
}
```

# 新学校选址

```
import java.util.Arrays;
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(System.in)) {
            int n = scanner.nextInt();
            int[] sites = new int[n];
            for (int i = 0; i < sites.length; i++) {
                sites[i] = scanner.nextInt();
            }
            int bestSite = solution(sites);
            System.out.print(bestSite);
        }
    }
 
    private static int solution(int[] sites) {
        Arrays.sort(sites);
        if (sites.length % 2 == 0) {
            return sites[sites.length / 2 - 1];
        } else {
            return sites[sites.length / 2];
        }
    }
}
```

# 采样过滤

```
#include<bits/stdc++.h>
 
using namespace std;
 
int main()
{
    // 处理输入
    string param_input_str;
    getline(cin, param_input_str);
 
    //空格分割
    vector<string> v;
    while (param_input_str.find(" ") != string::npos) {
        int found = param_input_str.find(" ");
        v.push_back(param_input_str.substr(0, found));
        param_input_str = param_input_str.substr(found + 1);
    }
    v.push_back(param_input_str);
 
    int m = stoi(v[0]);
    int t = stoi(v[1]);
    int p = stoi(v[2]);
 
    // data
    string data_input_str;
    getline(cin, data_input_str);
 
    vector<int> sample_data;
    while (data_input_str.find(" ") != string::npos) {
        int found = data_input_str.find(" ");
        sample_data.push_back(stoi(data_input_str.substr(0, found)));
        data_input_str = data_input_str.substr(found + 1);
    }
    sample_data.push_back(stoi(data_input_str));
 
    // 判断数据异常
    vector<int> items(sample_data.size(), 0);
    for (int i = 0; i < sample_data.size(); i++) {
        if (sample_data[i] <= 0) {
            items[i] = 0;
        } else if (i > 0 && ((sample_data[i] - sample_data[i - 1] >= 10) || sample_data[i] < sample_data[i - 1])) {
            items[i] = 0;
        } else {
            items[i] = 1;
        }
    }
 
    //
    int i = 0;
    while (i < sample_data.size()) {
        // 可以用之前数据替代的情况
        if (items[i] == 0 && i > 0 && items[i - 1] == 1) {
            sample_data[i] = sample_data[i - 1];
            items[i] = 1;
        }
        int error_num = 0;
        int corrent = 0;
        int j = i;
 
        // 求得采样错误总数量
        while (m > 0 && j < sample_data.size()) {
            if (items[j] == 0) {
                error_num += 1;
                if (error_num >= t) {
                    if (j > 0) {
                        corrent = j - 1;
                    } else {
                        corrent = 0;
                    }
                }
            }
            j += 1;
        }
 
        // 大于故障次数门限 T
        if (error_num >= t) {
            bool pos = false;
            int k = 0;
            while (k < i && items[k] != 1) {
                k += 1;
            }
            pos = true;
 
            if (i + t == sample_data.size() - 1) {
                k = i;
                while (k < corrent + 1) {
                    sample_data[k] = sample_data[i - 1];
                    items[k] = 1;
                    k += 1;
                }
                break;
            } else if (i + m <= sample_data.size()) {
                for (int l = i; l < sample_data.size(); l++) {
                    if (l < corrent + 1) {
                        if (i > 0) {
                            sample_data[l] = sample_data[i - 1];
                        } else {
                            sample_data[0];
                        }
                        items[l] = 1;
                    } else {
                        items[l] = 0;
                    }
                }
            } else {
                for (int q = i; q < i + m; q++) {
                    if (q < corrent + 1) {
                        sample_data[q] = sample_data[i - 1];
                        items[q] = 1;
                    } else {
                        items[q] = 0;
                    }
                }
                if (i + m + p >= sample_data.size() + 1) {
                    for (int k = i; k < sample_data.size(); k++) {
                        items[k] = 0;
                    }
                    items[k] = 0;
                    i = k + p;
                }
            }
        } else {
            i += 1;
        }
    }
 
    int res = 0;
    int location = 0;
    for (auto item: items) {
        if (item != 1) {
            if (location > res) {
                res = location;
            }
            location = 0;
        } else {
            location += 1;
        }
    }
    cout << max(res, location) << endl;
 
    return 0;
}
```

# 连接器问题

```
#include<bits/stdc++.h>
 
using namespace std;
 
typedef pair<int, int> pii;
 
typedef struct Node {
    int start; // 区间起点
    int end; // 区间终点
 
    Node(int start_, int end_) {
        this->start = start_;
        this->end = end_;
    }
} Node;
 
void SplitInteger(string input, vector<int> &output, const string &pattern)
{
    string::size_type pos;
    input += pattern;
    for (size_t i = 0U; i < input.size(); i++) {
        pos = input.find(pattern, i);
        if (pos < input.size()) {
            string temp = input.substr(i, pos - i);
            if ((temp != pattern) && (!temp.empty())) {
                output.push_back(stoi(temp));
            }
            i = pos + pattern.size() - 1;
        }
    }
}
 
void SplitString(string input, vector<string> &output, const string &pattern)
{
    string::size_type pos;
    input += pattern;
    for (size_t i = 0U; i < input.size(); i++) {
        pos = input.find(pattern, i);
        if (pos < input.size()) {
            string temp = input.substr(i, pos - i);
            if ((temp != pattern) && (!temp.empty())) {
                output.push_back(temp);
            }
            i = pos + pattern.size() - 1;
        }
    }
}
 
bool comp(Node &lhs, Node &rhs) {
    if (lhs.start == rhs.start)
        return lhs.end < rhs.end;
    return lhs.start < rhs.start;
}
 
std::int32_t main()
{
    string input;
    getline(cin, input);
    input = input.substr(1, input.length() - 1);
 
    vector<string> vec1;
    SplitString(input, vec1, "],[");
 
    vector<Node> a;
    vector<Node> b;
 
    for (const string &s: vec1) {
        vector<std::int32_t> temp;
        SplitInteger(s, temp, ",");
        a.emplace_back(temp.front(), temp.back());
    }
    sort(a.begin(), a.end(), comp);
 
    Node cur = *new Node(a[0].start, a[0].end);
 
    for (int i = 1; i < a.size(); i++) {
        if (a.at(i).start <= cur.end) {
            cur.end = max(cur.end, a.at(i).end);
        } else {
            b.emplace_back(cur.start, cur.end);
            cur = *new Node(a.at(i).start, a.at(i).end);
        }
    }
 
    b.emplace_back(cur.start, cur.end);
    a = b;
 
    string s;
    getline(cin, s);
    s = s.substr(1, s.length() - 1);
 
    vector<int> vec2;
    SplitInteger(s, vec2, ",");
    sort(vec2.begin(), vec2.end());
 
    vector<int> d;
    for (int i = 0; i < a.size() - 1; i++) {
        d.push_back(a.at(i + 1).start - a.at(i).end);
    }
    sort(d.begin(), d.end());
 
    deque<int> connects;
    for (int x: vec2)
        connects.push_back(x);
 
    deque<int> gaps;
    for (int x: d)
        gaps.push_back(x);
 
    size_t res = gaps.size() + 1;
 
    while (true) {
        if (connects.empty())
            break;
        if (gaps.empty())
            break;
        if (connects.front() >= gaps.front()) {
            connects.pop_front();
            gaps.pop_front();
            res--;
        } else {
            connects.pop_front();
        }
    }
    cout << res << endl;
    return 0;
}
```

# 区间交叠问题

```
#include<bits/stdc++.h>
 
using namespace std;
 
bool comp(pair<int, int> x, pair<int, int> y) {
    //按左端点从小到大排
    return x.first < y.first;
}
 
void find_min_line(vector<pair<int, int>> ranges, int index, int ans, int start, int &min_num, int total_length) {
    // 完全覆盖
    if (ranges[index].second - start >= total_length) {
        min_num = min(min_num, ans);
        return;
    }
    int temp = 0;
    for (int i = index + 1; i <= ranges.size(); i++) {
        // 找出剩余线段中坐端点小于起始线段的右端点
        if (ranges[i].first <= ranges[index].second) {
            if (ranges[i].second > ranges[temp].second) temp = i;
        } else {
            break;
        }
        if (temp != 0) {
            find_min_line(ranges, temp, ans + 1, start, min_num, total_length);
        }
    }
}
 
pair<int, int> split(string input_str)
{
    pair<int, int> range;
 
    int found = input_str.find(",");
    range.first = stoi(input_str.substr(0, found));
    range.second = stoi(input_str.substr(found + 1));
    return range;
}
 
int main()
{
    // 输入处理
    int n;
    cin >> n;
    vector<pair<int, int>> ranges;
    for (int i = 0; i < n; i++) {
        string input_str;
        cin >> input_str;
        ranges.push_back(split(input_str));
    }
    sort(ranges.begin(), ranges.end(), comp);
    for (auto x: ranges) {
        cout << x.first << " " << x.second << endl;
    }
 
    int total_length = ranges[ranges.size() - 1].second - ranges[0].first;
 
    //区间起点
    int start = 0;
    int min_num = ranges.size();
    for (int i = 0; i <= n; i++) {
        start = ranges[i].first;
        find_min_line(ranges, i, 1, start, min_num, total_length);
    }
    cout << min_num << endl;
    return 0;
}
```

# 演唱会

```
#include<bits/stdc++.h>
 
using namespace std;
 
bool comp(pair<int, int> &a, pair<int, int> &b) 
{
    if ((a.first + a.second) < (b.first + b.second)) {
        return true;
    }
    return false;
}
 
int main() 
{
    //输入初始化
    int N;
    cin >> N;
    vector<pair<int, int>> performances;
    for (int i = 0; i < N; ++i) {
        int a, b;
        cin >> a >> b;
        performances.push_back(make_pair(a, b));
    }
 
    //按照演出结束时间排序
    sort(performances.begin(), performances.end(), comp);
    int count = 0;
    int lastMoment = 0;
    for (int i = 0; i < N; i++) {
        //每次选择表演时间在上次表演结束后的第一个节目
        if (performances[i].first >= lastMoment) {
            count++;
            lastMoment = performances[i].first + performances[i].second + 15;
        }
    }
 
    cout << count << endl;
}
```

# 通信误码

```
import sys
from collections import Counter
 
 
class Solution:
    def func(self, n, ints):
        maxLen = 2147483647
        maxLen = sys.maxsize  # (1 << 63) - 1
        maxLen = (1 << 31) - 1
        if n == 0:
            return 0
 
        maxCount = 0
        maxCode = set()
        codeCount = {}
 
        se = set(ints)
        codeCount = {element: ints.count(element) for element in se}
        k_v = sorted(codeCount.items(), key=lambda x: x[1], reverse=True)
        # print(k_v)
        maxCount = k_v[0][1]
 
        for k, v in codeCount.items():
            if v == maxCount:
                maxCode.add(k)
 
        for i in maxCode:
            lo = 0
            hi = len(ints) - 1
            while ints[lo] != i:
                lo += 1
            while ints[hi] != i:
                hi -= 1
            if lo <= hi:
                maxLen = min(maxLen, hi - lo + 1)
        return maxLen
 
 
if __name__ == "__main__":
    n = int(input())
    # ints = input().split()
    ints = list(map(int, input().split()))
    solo = Solution()
    print(solo.func(n, ints))
```

# 开心消消乐

```
def dfs(ni, mj):
    # 点击点是0，或者已经查看过，不是有效的集合
    if (ni, mj) in cache \
            or mapping[ni][mj] == "0":
        return False
 
    # 如果这个点是1，查看所有相邻的点，如果是1继续向下查
    def do_dfs(x, y):
        if (x, y) in cache \
                or x < 0 or x >= n \
                or y < 0 or y >= m:
            return
 
        cache.append((x, y))
        if mapping[x][y] == "1":
            do_dfs(x, y + 1)
            do_dfs(x, y - 1)
            do_dfs(x - 1, y)
            do_dfs(x + 1, y)
            do_dfs(x - 1, y - 1)
            do_dfs(x - 1, y + 1)
            do_dfs(x + 1, y - 1)
            do_dfs(x + 1, y + 1)
 
    do_dfs(ni, mj)
    # 已经找到了一个全是1的集合，返回计数
    return True
 
 
if __name__ == "__main__":
    while 1:
        try:
            n, m = map(int, input().split())
            mapping = [input().split() for i in range(n)]
            cache = []
            count = 0
            for i in range(n):
                for j in range(m):
                    count += dfs(i, j)
            print(count)
        except Exception as e:
            break
```

# 优选核酸检测点

```
import datetime
 
if __name__ == "__main__":
 
    def _tm(start, sep):
        time = datetime.datetime.strptime(start, '%H %M')
        time += datetime.timedelta(minutes=sep)
        return datetime.datetime.strftime(time, '%H %M')
 
 
    def get_increment(start_t, start_c, take_time):
        count = int(start_c)
        for i in range(int(take_time)):
            tm = _tm(start_t, i)
            # 8点-10点每分钟增加3人，表示8:00到10:00
            # 12点-14点每分钟增加10人，表示12:00到14:00
            if "08 00" <= tm < "10 00":
                count += 3
            elif "12 00" <= tm < "14 00":
                count += 10
 
            # 核酸点工作时间都是8点到20点, 没有排队人数时，不做扣减
            if "08 00" <= tm < "20 00" and count > 0:
                # 每分钟做完一个人
                count -= 1
        return count if count > 0 else 0
 
 
    while 1:
        try:
            start_time = input()
            end_time = input()
            # 期望的最大耗时 单位:分钟
            duration = (datetime.datetime.strptime(start_time, '%H %M')
                        - datetime.datetime.strptime(end_time, '%H %M')).seconds / 60
 
            num = int(input())
            site_list = []
            for _ in range(num):
                idx, distance, start_count = input().split()
                take_time = int(distance) * 10
 
                # 超时不计入统计
                if take_time > duration:
                    continue
 
                total_count = get_increment(start_time, start_count, take_time)
 
                # 超时不计入统计
                if total_count + take_time > duration:
                    continue
 
                # Ix:选择后的核酸检测点ID；Tx:做完核酸花费的总时间(分钟)；Mx:去该核算点花费的费用。
                site_list.append([idx, total_count + take_time, take_time])
            """
            优选规则：
            花费时间最少的核酸检测点排在前面。
            花费时间一样，花费费用最少的核酸检测点排在前面。
            时间和费用一样，则ID值最小的排在前面。
            """
            site_list = sorted(site_list, key=lambda x: (x[1], x[2], x[0]))
            print(len(site_list))
            for idx, take_time, cost in site_list:
                print(idx, take_time, cost)
        except Exception as e:
            break
```

# 挑选字符串

```
a = input()
b = input()
count = 0
 
while True:
    last = 0
    flag = False
    # 逐个在字符串A中找字符串B的每一个字符，如果找到了，按照规则，这个字符就不能再用，可以直接置一个无效字符。
    for single_char in b:
        # A中出现位置
        index = a.find(str(single_char), last)
        last = index
        if index != -1:
            a = a.replace(single_char, '_', 1)
        else:
            flag = True
            break
    if flag:
        break
 
    count += 1
print(count)
```

# 冗余覆盖

```
from collections import Counter
# s1 = input().strip()
# s2 = input().strip()
# k = int(input().strip())
s1 ="kb"
s2="aabcdg"
s1_dict = dict(Counter(s1))
k= 1
n1 = len(s1)
n2 = len(s2)
res = -1
 
for i in range(n2-n1-k+1):
    temp = s2[i:i+(n1+k)]
    temp_dict = dict(Counter(temp))
    flag = True
    for j in s1_dict.keys():
        if j not in temp_dict.keys() or (j in temp_dict.keys() and s1_dict[j] > temp_dict[j]):
            flag =False
            break
    if flag:
        print(i)
        break
else:
    print(-1)
```

# 冗余覆盖

```
from collections import Counter
# s1 = input().strip()
# s2 = input().strip()
# k = int(input().strip())
s1 ="kb"
s2="aabcdg"
s1_dict = dict(Counter(s1))
k= 1
n1 = len(s1)
n2 = len(s2)
res = -1
 
for i in range(n2-n1-k+1):
    temp = s2[i:i+(n1+k)]
    temp_dict = dict(Counter(temp))
    flag = True
    for j in s1_dict.keys():
        if j not in temp_dict.keys() or (j in temp_dict.keys() and s1_dict[j] > temp_dict[j]):
            flag =False
            break
    if flag:
        print(i)
        break
else:
    print(-1)
```

# 最短木板长度

```
params = [int(x) for x in input().split(" ")]
n = params[0]
m = params[1]
woods = [int(x) for x in input().split(" ")]
 
woods = sorted(woods)
result = 0;
 
# 遍历给的木料长度，每次都补一下最短的木板，每次补完之后重新排序，重复此步骤。
for i in range(m):
    woods[0] = woods[0] + 1
    woods = sorted(woods)
    result = max(result, woods[0])
 
print(result)
```

# 最多获得的短信条数

```
#include<bits/stdc++.h>
 
using namespace std;
 
bool comp(vector<double> x, vector<double> y) {
    return x[2] > y[2];
}
 
int main()
{
    string money_str;
    getline(cin, money_str);
    int money = stoi(money_str);
 
    string topup_str;
    getline(cin, topup_str);
 
    //空格分割
    vector<int> v;
    while (topup_str.find(" ") != string::npos) {
        int found = topup_str.find(" ");
        v.push_back(stoi(topup_str.substr(0, found)));
        topup_str = topup_str.substr(found + 1);
    }
    v.push_back(stoi(topup_str));
 
    vector<vector<double>> topup_details;
    for (int i = 0; i < v.size(); i++) {
        vector<double> topup_detail;
        topup_detail.push_back(double(i + 1));
        topup_detail.push_back(double(v[i]));
        topup_detail.push_back(double(v[i]) / (i + 1));
        topup_details.push_back(topup_detail);
    }
 
    sort(topup_details.begin(), topup_details.end(), comp);
 
    //贪心选择
    int result = 0;
    for (int i = 0; money > 0; i++) {
        if (topup_details[i][0] <= money) {
            result += topup_details[i][1];
            money -= topup_details[i][0];
        }
 
        if (i == topup_details.size() - 1) {
            i = 0;
        }
    }
    cout << result << endl;
    return 0;
}
```

# 密室逃生游戏

```
key = input()
boxes_str = input().strip().split(",")[-1].strip()
boxes = [x for x in boxes_str.split(" ")]
res = -1
for i in range(len(boxes)):
    # 先全部转为小写字母
    lower = boxes[i].lower()
    chars = []
    for c in lower:
        if 'a' <= c <= 'z':
            chars.append(c)
    chars.sort()
    if len(chars) == len(key):
        if key == "".join(chars):
            res = i + 1
            break
 
print(res)
```

# 匿名信

```
newspaper = [''.join(sorted(x)) for x in input().split(" ")]
anonymousLetter = [''.join(sorted(x)) for x in input().split(" ")]
 
flag = False
for letter in anonymousLetter:
    if letter not in newspaper:
        flag = True
        break
 
if flag:
    print(False)
else:
    print(True)
```

# 任务调度

```
import functools
import sys
 
 
def comp(a, b):
    if a[1] > b[1]:
        return -1
    elif a[1] == b[1]:
        return 0
    else:
        return 1
 
 
def find(tasks, time):
    for task in tasks:
        if task[3] == time:
            return task
    return None
 
 
# 处理输入
# 不确定多少行输入
tasks = []
while True:
    line = sys.stdin.readline()
    if not line:
        break
    tasks.append([int(x) for x in line.split(" ")])
 
# print (tasks)
 
time = 0
waiting = []
while len(tasks) > 0:
    cur = find(tasks, time)
 
    if cur is not None:
        waiting.append(cur)
        # 按照优先级排序
        waiting = sorted(waiting, key=functools.cmp_to_key(comp))
        # print (tasks)
        cur = waiting[0]
    else:
        if len(waiting) != 0:
            cur = waiting[0]
 
    if cur is not None:
        cur[2] -= 1
        if cur[2] == 0:
            print(str(cur[0]) + " " + str(time + 1))
            tasks.remove(cur)
            waiting.remove(cur)
 
    time += 1
```

# 总最快检测效率

```
x,y = map(int,input().strip().split(" "))
nums = list(map(int,input().strip().split(" ")))
# x = 2
# y = 2
# nums = [200,300]
 
#将最低效率的志愿者一个一个向最高效率迁移
def change_volunteer(i,j,nums,max_num,count):
    while i < j:
        if nums[i] * 0.1 > nums[j] * 0.2:
            max_num += nums[i] * 0.1 - nums[j] * 0.2
            count += 1
            if count == 3:
                count = 0
                i += 1
            j -= 1
        else:
            break
    return max_num
 
def main(x,y,nums):
    #先将效率由大到小降序排列
    nums.sort(reverse=True)
    max_num = 0
 
    #志愿者少于采样员，优先分配高效率采样员
    if y<x:
        for i in range(x):
            max_num+= nums[i] if i<y else nums[i]*0.8
        max_num = change_volunteer(0, y-1, nums, max_num,0)
    else:
        if y>=4*x:
            y=4*x
        max_num = sum(nums)
 
        #一个一个分配后剩余志愿者的数量
        remain_volunteer = y-x
 
        i,count=0,0
        j = x-1
        while remain_volunteer>0:
            max_num+=nums[i]*0.1
            remain_volunteer-=1
            count+=1
            if count==3:
                count=0
                i+=1
 
        max_num = change_volunteer(i, j, nums, max_num,count)
    print(max_num)
main(2,2,nums)
 
```

# 机器人

```
direction = [[0, 1], [0, -1], [1, 0], [-1, 0]]
 
k = 0
 
 
def bfs(matrix, visited, x, y):
    global k
    visited[x][y] = True
    # 四个方向查看是否可行
    for d in direction:
        newX = x + d[0]
        newY = y + d[1]
        if newX >= 0 and newX < len(matrix) and newY >= 0 and newY < len(matrix[0]):
            if not visited[newX][newY] and abs(matrix[x][y] - matrix[newX][newY]) <= 1:
                k += 1
                bfs(matrix, visited, newX, newY)
 
 
# 处理输入
params = [int(x) for x in input().split(" ")]
X = params[0]
Y = params[1]
matrix = []
for i in range(X):
    matrix.append([int(x) for x in input().split(" ")])
 
# 起点可以是每一个位置
result = 0
for i in range(X):
    for j in range(Y):
        visited = [[False for y in range(Y)] for x in range(X)]
        k = 1
        bfs(matrix, visited, i, j)
        result = max(k, result)
 
print(result)
```

# 星际篮球争霸赛

```
def canPartitionKSubsets(nums, k):
    all = sum(nums)
    if all % k:
        return False
    per = all // k
    nums.sort()
    if nums[-1] > per:
        return False
    n = len(nums)
    dp = [False] * (1 << n)
    dp[0] = True
    cursum = [0] * (1 << n)
    for i in range(0, 1 << n):
        if not dp[i]:
            continue
        for j in range(n):
            if cursum[i] + nums[j] > per:
                break
            if (i >> j & 1) == 0:
                next = i | (1 << j)
                if not dp[next]:
                    cursum[next] = (cursum[i] + nums[j]) % per
                    dp[next] = True
    return dp[(1 << n) - 1]
 
 
if __name__ == "__main__":
    # 处理输入
    n = int(input())
    nums = [int(x) for x in input().split(" ")]
 
    for i in reversed(range(n + 1)):
        # 从最大的可能行开始，满足条件即为为最小的情况
        if canPartitionKSubsets(nums, i):
            print(int(sum(nums) / i))
            break
```

# 箱子之字形摆放

```
inputs = input().split(" ")
char_str = inputs[0]
n = int(inputs[1])
 
# 将n行格子看作是n个数组
res_array = [[] for i in range(n)]
 
index = 0
# 控制下一个字符归属到哪个数组
flag = True
 
for c in char_str:
    if index == -1:
        index = 0
        flag = True
 
    if index == n:
        index = n - 1
        flag = False
 
    res_array[index].append(c)
 
    if flag:
        index += 1
    else:
        index -= 1
 
for single_array in res_array:
    print("".join(single_array))
```

# 快递业务站

```
n = int(input())
sites = []
for i in range(n):
    sites.append([int(x) for x in input().split(" ")])
 
count = 0
# 保存站点覆盖情况
cover = set([])
for i in range(n):
    # 第i个站点未覆盖
    if i not in cover:
        count += 1
 
    # 第i个站点与其他站点的相连情况
    site = sites[i]
    for j in range(len(site)):
        if site[j] == 1:
            cover.add(j)
print(count)
```

# 端口合并

```
#include<bits/stdc++.h>
 
using namespace std;
 
set<int> split(string input_str)
{
    set<int> v;
 
    while (input_str.find(",") != string::npos) {
        int found = input_str.find(",");
        v.insert(stoi(input_str.substr(0, found)));
        input_str = input_str.substr(found + 1);
    }
    v.insert(stoi(input_str));
    return v;
}
 
bool check(set<int> range1, set<int> range2) {
    int count = 0;
    for (auto x: range1) {
        if (range2.count(x)) {
            count++;
        }
        if (count >= 2) {
            return true;
        }
    }
    return false;
}
 
bool merge(vector<set<int>> &ranges)
{
    for (int i = 0; i < ranges.size(); i++) {
        for (int j = i + 1; j < ranges.size(); j++) {
            if (check(ranges[i], ranges[j])) {
                //合并去重
                ranges[i].insert(ranges[j].begin(), ranges[j].end());
                ranges.erase(ranges.begin() + j);
                return true;
            }
        }
    }
    return false;
}
 
int main()
{
    int m;
    cin >> m;
 
    vector<set<int>> ranges;
    for (int i = 0; i < m; i++) {
        string input_str;
        cin >> input_str;
        ranges.push_back(split(input_str));
    }
 
    while (merge(ranges));
 
    cout << "[";
    int i = 0;
    for (auto x: ranges) {
        cout << "[";
        string output = "";
        for (auto y: x) {
            output += to_string(y) + ",";
        }
        cout << output.substr(0, output.size() - 1) << "]";
        if (i != ranges.size() - 1) {
            cout << ",";
        }
        i++;
    }
    cout << "]";
 
    return 0;
}
```

# 对称美学

```
def find(n,k):
    if n==0:
        return "R"
    # 第n行的长度
    length = 2**n
    if k>=length/2:
        pos = k-length/2
        return find(n-1,pos)
    else:
        return "B" if find(n-1,k) == "R" else "R"
 
def main():
    t = int(input().strip())
    for i in range(t):
        n,k = list(map(int,input().strip().split(" ")))
        res = "red" if find(n-1,k) == "R" else "blue"
        print(res)
 
main()
```

# 日志首次上报最多积分

```
def func():
    while 1:
        try:
            log_list = list(map(int, input().split()))
            # 最大得分
            max_score = 0
            for i in range(len(log_list)):
                # 待上报条数
                log_num = sum(log_list[0:i + 1])
 
                # 扣分项
                deduct = sum([log_list[j] * (i - j) for j in range(i)])
                max_score = max(max_score, log_num - deduct)
                if log_num > 100:
                    break
            print(max_score)
        except Exception as e:
            break
 
 
if __name__ == "__main__":
    func()
```

# 二元组个数

```
import collections
 
def main():
    m = int(input().strip())
    m_nums = list(map(int,input().strip().split(" ")))
    nums_a_count = collections.defaultdict(int)
    for i in m_nums:
        nums_a_count[i]+=1
    n = int(input().strip())
    n_nums = list(map(int,input().strip().split(" ")))
    nums_b_count = collections.defaultdict(int)
    for i in n_nums:
        nums_b_count[i]+=1
    result = 0
    for key1,value in nums_a_count.items():
        if key1 in nums_b_count.keys():
            result += value * nums_b_count[key1]
    print(result)
 
 
main()

```

# 特异性双端队列

```
def main():
    number = int(input().strip())
    operations = []
    for i in range(2*number):
        temp = input().strip().split(" ")
        operations.append(temp)
    stack = []
    start = 1
    count = 0 #这个是移动次数
    for strs in operations:
        if strs[0] == "remove":
            if stack!=[]:
                if stack[0] == start:
                    stack.pop(0)
                    start+=1
                else:
                    stack.sort()
                    stack.pop(0)
                    count+=1
                    start+=1
            continue
        # 如果是添加指令
        if strs[1]=="add":
            if strs[0] == "head":
                # 从头部添加
                stack.insert(0,int(strs[2]))
            else:
                # 从尾部添加
                stack.append(int(strs[2]))
    print(count)
main()
```

# 处理器问题

```
def dfs(batch_processor, index, level,path, result):
 
    if len(path)== level:
        result.append(path)
        return
 
    for i in range(index,len(batch_processor)):
        path.append(batch_processor[i])
        #逐个往后找合适的组合
        dfs(batch_processor, i + 1, level, path, result)
        path = path[:-1]
 
    return False
 
 
 
def get_combo(batch_processor, num,result):
    path = []
    dfs(batch_processor, 0, num, [], result)
 
 
def main():
 
    #处理输入
    # input_str = input().strip()[1:-1]
    # nums = map(int,input_str.strip(","))
    nums = [0, 1, 4, 5, 6, 7]
    nums = [0, 1, 2,3,4, 5, 6, 7]
 
 
    #初始化两个链路剩余可用的处理器
    processors_1 =[]
    processors_2 = []
    for i in nums:
        if i>=4:
            processors_2.append(i)
        else:
            processors_1.append(i)
 
    length_1 = len(processors_1)
    length_2 = len(processors_2)
 
    #申请的处理器个数
    # apply_num = int(input().strip())
    apply_num = 1
    apply_num = 8
    result = []
    #满足条件结果组合
 
    if apply_num == 1:
        #原则1
        if length_1 == 1 or length_2 == 1:
            if length_1 == 1:
                get_combo(processors_1, 1, result)
            if length_2 == 1:
                get_combo(processors_2, 1, result)
        elif length_1 == 3 or length_2 == 3:
            if length_1 == 3:
                get_combo(processors_1, 1, result)
            if length_2 == 3:
                get_combo(processors_2, 1, result)
        elif length_1 == 2 or length_2 == 2:
            if length_1 == 2:
                get_combo(processors_1, 1, result)
            if length_2 == 2:
                get_combo(processors_2, 1, result)
        elif length_1 == 4 or length_2 == 4:
            if length_1 == 4:
                get_combo(processors_1, 1, result)
            if length_2 == 4:
                get_combo(processors_2, 1, result)
 
    elif apply_num == 2:
        # 原则2
        if length_1 == 2 or length_2 == 2:
            if length_1 == 2:
                get_combo(processors_1, 2, result)
            if length_2 == 2:
                get_combo(processors_2, 2, result)
        elif length_1 == 4 or length_2 == 4:
            if length_1 == 4:
                get_combo(processors_1, 2, result)
            if length_2 == 4:
                get_combo(processors_2, 2, result)
        elif length_1 == 3 or length_2 == 3:
            if length_1 == 3:
                get_combo(processors_1, 2, result)
            if length_2 == 3:
                get_combo(processors_2, 2, result)
    elif apply_num == 4:
        # 原则3
        if length_1 == 4 or length_2 == 4:
            if length_1 == 4:
                result.append(processors_1)
            if length_2 == 4:
                result.append(processors_2)
    elif apply_num == 8:
        # 原则4
        if length_1 == 4 and length_2 == 4:
            processors_1.extend(processors_2)
            result.append(processors_1)
    print(result)
 
main()
```

# 最大利润

```
items = int(input())
days = int(input())
max_items = [int(x) for x in input().split(" ")]
prices = []
for i in range(items):
    prices.append([int(x) for x in input().split(" ")])
# print (prices)
 
max_profit = 0
for i in range(len(prices)):
    ans = 0
    for j in range(1, len(prices[i])):
        ans += max(0, prices[i][j] - prices[i][j - 1]);
    max_profit += ans * max_items[i]
 
print(max_profit)
```

# 最大平分数组

```
def can_partition_ksubsets(nums, k, total):
 
    if total % k > 0:
        return False
    per = total / k
    nums.sort()
    if nums[-1] > per:
        return False
    length = len(nums)
    dp = [False for i in range(1<<length)]
    cur_sum = [0 for i in range(1<<length)]
    dp[0] = True
    for i in range(1<<length):
        if not dp[i]:
            continue
        for j in range(length):
            if cur_sum[i] + nums[j] > per :
                break
            if ((i >> j) & 1) == 0:
                next = i | (1 << j)
                if not dp[next]:
                    cur_sum[next] = (cur_sum[i] + nums[j]) % per
                    dp[next] = True
    return dp[(1 << length) - 1]
 
 
def main():
    #处理输入
    # m = int(input().strip())
    # nums = map(int,input().strip().split(" "))
    m = 7
    nums = [4,3,2,3,5,2,1]
    m = 9
    nums = [5, 2 ,1, 5, 2 ,1, 5 ,2 ,1]
    total = sum(nums)
    #最大可以等分为m个子数组
    for i in range(m,1,-1):
        #从最大的可能行开始, 满足条件即输出
        if can_partition_ksubsets(nums, i, total):
            print(i)
            break
    return 0
main()
```

# 探索地块建立

```
import sys
def maxSideLength(mat, threshold, c):
    m, n = len(mat), len(mat[0])
    P = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + mat[i - 1][j - 1]
 
    ans = 0
    # print (P)
    # 2、遍历前缀和矩阵，获得边长等于c的矩阵
    for i in range(c, m + 1):
        for j in range(c, n + 1):
            # 重点理解：减去点[i-c][j]和点[i][j-c]的矩阵前缀和，剩下来的为一个边长为c正方形，注意点[i-c][j-c]减了两次，需要加一个回来
            if P[i][j] - P[i - c][j] - P[i][j - c] + P[i - c][j - c] >= threshold:
                ans += 1
 
    return ans
 
 
# 处理输入
# print ( input())
 
input_params = [int(x) for x in input().split(" ")]
n = input_params[0]
m = input_params[1]
c = input_params[2]
k = input_params[3]
 
matrix = []
for i in range(n):
    matrix.append([int(x) for x in input().split(" ")])
 
print(maxSideLength(matrix, k, c))
```

# 最长的密码

```
import sys
def solution_01():
    # 处理输入
    pwd_list = input().split(" ")
 
    valid_pwd_list = []  # 定义变量,存储合法的密码
    for pwd in pwd_list:
        flag = True  # 定义flag, 表示当前密码依次去掉一个字符后是否都在pwd_list中
        # 当前密码依次去除一个字符
        for i in range(len(pwd) - 1, 0, -1):
            if pwd[: i] not in pwd_list:
                flag = False
                break
        if flag:
            valid_pwd_list.append(pwd)
 
    valid_pwd_list.sort(reverse=True)
 
    return valid_pwd_list[0] if len(valid_pwd_list) != 0 else ""
 
 
if __name__ == '__main__':
    ans = solution_01()
    print(ans)
```

# 计算数组中心位置

```
import sys
# 计算num_list的乘积
def calc_pd(num_list):
    pd = 1
    for num in num_list:
        pd *= num
 
    return pd
 
 
def Solution():
    # 处理输入
    num_list = input().split(" ")
    num_list = [int(num) for num in num_list]
 
    ans = -1
    for i in range(0, len(num_list)):
        if i == 0:
            l_pd = 1
            r_pd = calc_pd(num_list[1:])
        elif i == len(num_list) - 1:
            l_pd = calc_pd(num_list[0: -1])
            r_pd = 1
        else:
            l_pd = calc_pd(num_list[0: i])
            r_pd = calc_pd(num_list[i + 1:])
        if l_pd == r_pd and ans == -1:
            ans = i
 
    return ans
 
 
if __name__ == '__main__':
    ans = Solution()
    print(ans)
```

# 积木最远距离

```
count = int(input())
blocks = {}
for i in range(count):
    num = int(input())
    if num in blocks:
        blocks[num].append(i)
    else:
        blocks[num] = [i]
 
max_distance = -1
for block_num in blocks:
    if len(blocks[block_num]) > 1:
        max_distance = max(max_distance, max(blocks[block_num]) - min(blocks[block_num]));
 
print(max_distance)

```

# 垃圾短信识别

```
import collections
 
 
def solution_01():
    # 处理输入
    total_num = int(input())
    relation_map = {}  # 构建关系映射
    for i in range(total_num):
        id_list = input().split(" ")
        if id_list[0] not in relation_map.keys():
            relation_map[id_list[0]] = [id_list[1]]
        else:
            relation_map[id_list[0]].append(id_list[1])
 
    spec_id = input()
 
    # 计算L, 即A发送过短信的接收者中,没有给A发送过短信的人; L>5
    send_id_list = relation_map[spec_id] if spec_id in relation_map.keys() else []
    num_send_2_A = 0  # 定义变量,A发送给短信的接收者中,给A发过短信的人数
    for id_ in send_id_list:
        if id_ in relation_map.keys():
            if spec_id in relation_map[id_]:
                num_send_2_A += 1
 
    L = len(send_id_list) - num_send_2_A
 
    # 计算M, 即A发送的短信数-A接收的短信数; M>10
    num_A_received = 0  # 定义变量,A接收到的短信数
    for k, v in relation_map.items():
        if k != spec_id and spec_id in v:
            num_A_received += 1
 
    M = len(send_id_list) - num_A_received
 
    # 计算N, 即如果存在X,A发送给X的短信数-A接收到X的短信数; N>5
    N = -1
    if spec_id in relation_map.keys():  # 存在A发送过短信的情况
        spec_count = collections.Counter(relation_map[spec_id])  # 统计A发送给其他ID各自的短信数
        for k, v in spec_count.items():
            if k in relation_map.keys():  # 如果X发送过短信
                k_count = collections.Counter(relation_map[k])  # 统计X发送给其他ID各自的短信数
                if spec_id in k_count.keys():  # X给A发过短信
                    d_value = int(v) - int(k_count[spec_id])  # 计算差值
                    N = max(N, d_value)
 
    if L > 5 or M > 10 or N > 5:
        print(f"true {L} {M}")
    else:
        print(f"false {L} {M}")
 
 
if __name__ == '__main__':
    solution_01()
```

# 打印机队列

```
import functools
from collections import defaultdict
targs_dict = defaultdict(list)
# total = 7
total = int(input().strip())

count = 0
def comp(x,y):
    if x[0] ==y[0]:
        if x[1] < y[1]:
            return -1
        else:
            return 1
    if x[0] < y[0]:
        return 1
    else:
        return -1
for i in range(total):
    temp_msg = input().strip().split(" ")
    # temp_msg = msg_list[i]
    if temp_msg[0] =="IN":
        count+=1
        temp_key = int(temp_msg[1])
        temp_value = (int(temp_msg[2]),count)
        targs_dict[temp_key].append(temp_value)
    else:
        # print(targs_dict)
        temp_key = int(temp_msg[1])
        temp_targs = targs_dict[temp_key]
        if temp_targs == []:
            print("NULL")
        else:
            temp_targs.sort(key=functools.cmp_to_key(comp))
            print(temp_targs[0][1])
            # print(temp_targs)
            targs_dict[temp_key] = temp_targs[1:]
```

# 模拟商场优惠打折

```
#先满减后打折
def mode_a(price,m,n):
    count = 0
    while m>0:
        if price < 100:
            break
        price -= (price // 100 * 10)
        count += 1
        m-=1
    price *= 0.92
    count +=1
    return (price, count)
 
#先打折后满减
def mode_b(price, m, n):
 
    count = 0;
    price *= 0.92
    count +=1
    while m>0 :
        if price < 100:
            break
        price -= (price // 100 * 10)
        count += 1
        m -= 1
    return (price, count)
 
 
#先满减后无门槛
def mode_c(price, m, k):
 
    count = 0
    while m>0 :
        if price < 100:
            break
        price -= (price // 100 * 10)
        count += 1
        m -= 1
 
    for i in range(k):
        price -= 5
        count +=1
        if price < 0:
            break
    return (price, count)
 
# 先打折后无门槛
def mode_d(price, n, k):
 
    count = 0
    price *= 0.92
    count += 1;
    for i in range(k):
        price -= 5
        count +=1
        if price < 0:
            break
    return (price, count)
 
def main():
 
    #处理输入
    # params = list(map(int,input().strip().split("")))
    #
    # m = params[0]
    # n = params[1]
    # k = params[2]
    params = [3,2,5]
    m,n,k = 3,2,5
    # nums = int(input().strip())
    nums= 3
    prices=[100,200,400]
    for i in range(nums):
        res = []
        # price = int(input().strip())
        price = prices[i]
        res.append(mode_a(price, m, n))
        res.append(mode_b(price, m, n))
        res.append(mode_c(price, m, k))
        res.append(mode_d(price, n, k))
 
        #按照价格降序，用券数降序排序
        res.sort(key=lambda x: (x[0], x[1]))
        print(res[0])
main()
```

# 单词重量

```
# words = input().strip().split(" ")
s = "Who Love Solo"
words = s.split(" ")
nums = len(words)
new_str = "".join(words)
total_length = len(new_str)
print("%.2f" % (total_length/nums))
```

# 输出指定字母在字符串的中的索引

```
k=4
str1 = "hAkDAjByBq"
str_list = list(str1)
str_list.sort()
new_str = "".join(str_list)
index = str1.index(new_str[k-1])
print(index)
```

# 最大化控制资源成本

```
# coding:utf-8
import functools
 
max_machine = 0
 
# 处理输入
task_num = input()
 
i = int(task_num)
ranges = []
while i > 0:
    input_str = input()
    input_list = [int(x) for x in input_str.split(" ")]
    ranges.append(input_list)
    i = i - 1
 
 
# 自定义排序函数，a,b为两个list
def comp(a, b):
    if a[0] > b[0]:
        return 1
    elif a[0] == b[0]:
        if a[1] > b[1]:
            return 1
        elif a[1] == b[1]:
            return 0
    return -1
 
 
# 求公共区间
def cal_public_range(ranges):
    global max_machine
    ranges = sorted(ranges, key=functools.cmp_to_key(comp))
    public_range = []
    for i in range(len(ranges)):
        for j in range(i + 1, len(ranges)):
            left = max(ranges[i][0], ranges[j][0])
            right = min(ranges[i][1], ranges[j][1])
            if left <= right:
                temp = [left, right, ranges[i][2] + ranges[j][2]]
                public_range.append(temp)
                if ranges[i][2] + ranges[j][2] > max_machine:
                    max_machine = ranges[i][2] + ranges[j][2]
    return public_range
 
 
while len(ranges) > 1:
    ranges = cal_public_range(ranges)
 
print(max_machine)
```

# 羊、狼、农夫过河

```
input_nums = [int(x) for x in input().split(" ")]
M = input_nums[0]
N = input_nums[1]
X = input_nums[2]
 
min_times = (M + N) * X
 
 
# m0, n0 分别表示剩余的羊、狼个数， x为船容量
# m1, n1 分别表示运输到对岸的羊、狼个数，times为次数
def transport(m0, n0, x, m1, n1, times):
    global min_times
    # 若可以一次性运走，结束了，注意等于号。。。
    if x >= m0 + n0:
        if times + 1 < min_times:
            min_times = times + 1
        return times + 1
 
    # 尝试运一部分狼一部分羊
    # 要上船的羊数量不可以超过岸上数量、也不可以超过船的容量
    for i in range(m0):
        if i > x:
            break
        # 要上船的狼的数量不可以超过岸上数量、也不可以超过船装了羊后的剩余的容量
        for j in range(n0):
            if i + j > x:
                break
            # 不可以不运
            if i + j == 0:
                continue
 
            # 船离岸后，原来这岸，要么没有羊，要么羊比狼多，才可以运；对岸也要检查，不考虑回程带动物
            if (m0 - i == 0 or m0 - i > n0 - j) and (m1 + i == 0 or m1 + i > n1 + j):
                # 运一次
                result = transport(m0 - i, n0 - j, x, m1 + i, n1 + j, times + 1)
                # 如果获取了结果，和minTime比较，但是不结束，继续检查
                if result < min_times and result != 0:
                    min_times = result
 
    # 没有方案...返回0
    return 0
 
 
# 表示已运输到对岸的羊、狼个数
m_temp = 0
n_temp = 0
 
transport(M, N, X, m_temp, n_temp, 0)
 
if min_times == (M + N) * X:
    print(0)
else:
    print(min_times)
```

# 真正的密码

```
# 处理输入
input_strs = input().split(" ")
# 将所有字符串放入哈希集合
word_set = set()
for single_str in input_strs:
    word_set.add(single_str)
# 真正的密码
true_pass_word = ""
 
# 按顺序检查每一个词
for single_str in input_strs:
    # 条件1：检查这个词所有以索引0开头的子串在数组中是否都有
    flag = True
    for i in range(1, len(single_str)):
        # 以索引0开头的子串
        sub_str = single_str[0:i]
        if sub_str not in word_set:
            flag = False
            break
 
    if flag:
        # 条件2：比较密码长度
        if len(single_str) > len(true_pass_word):
            true_pass_word = single_str
        # 条件3：比较密码字典排序
        if len(single_str) == len(true_pass_word) and single_str > true_pass_word:
            true_pass_word = single_str
 
print(true_pass_word)
```

# 过滤组合字符串

```
import copy
 
# 保存排列组合字符串
res_str_list = []
 
# 预设值
num_char_map = {'0': "abc", '1': "def", '2': "ghi", '3': "jkl", '4': "mno", '5': "pqr", '6': "st", '7': "uv", '8': "wx",
                '9': "yz"}
 
 
# 递归求排列组合
def dfs(num_str, temp_list, index):
    if index == len(num_str):
        res_str_list.append("".join(temp_list))
        return
    temp_list_back_up = copy.copy(temp_list)
    for single_char in num_char_map[num_str[index]]:
        temp_list.append(single_char)
        dfs(num_str, temp_list, index + 1)
        temp_list.pop()
 
 
# 处理输入
num_str = input()
block_str = input()
dfs(num_str, [], 0)
 
# 过滤
for single_str in res_str_list:
    if block_str in single_str:
        res_str_list.remove(single_str)
 
print(res_str_list)
```

# 等和子数组最小和

```
import functools
 
 
def canPartitionKSubsets(nums, k):
    all = sum(nums)
    if all % k:
        return False
    per = all // k
    nums.sort()
    if nums[-1] > per:
        return False
    n = len(nums)
    dp = [False] * (1 << n)
    dp[0] = True
    cursum = [0] * (1 << n)
    for i in range(0, 1 << n):
        if not dp[i]:
            continue
        for j in range(n):
            if cursum[i] + nums[j] > per:
                break
            if (i >> j & 1) == 0:
                next = i | (1 << j)
                if not dp[next]:
                    cursum[next] = (cursum[i] + nums[j]) % per
                    dp[next] = True
    return dp[(1 << n) - 1]
 
 
# 处理输入
n = int(input())
nums = [int(x) for x in input().split(" ")]
 
for i in reversed(range(n + 1)):
    # 从最大的可能行开始，满足条件即为为最小的情况
    if (canPartitionKSubsets(nums, i)):
        print(sum(nums) / i)
        break;
```

# 租车骑绿岛

```
input_param = [int(x) for x in input().split(" ")]
m = input_param[0]
n = input_param[0]
weights = [int(x) for x in input().split(" ")]
 
# 第一步，单词内部调整
ordered_weights = sorted(weights, reverse=False)
 
min_bikes = 0
temp_weight = 0
for i in ordered_weights:
    if temp_weight <= m <= temp_weight + ordered_weights[i]:
        min_bikes += 1
        temp_weight = ordered_weights[i]
    else:
        temp_weight += ordered_weights[i]
print(min_bikes)
```

# 不含 101 的数

```
nums = input().split(" ")
left = int(nums[0])
right = int(nums[1])
 
count = right - left + 1
for i in range(left, right + 1):
    bin_str = str(bin(i))
    if '101' in bin_str:
        count -= 1
print(count)
```

# 最多颜色的车辆

```
cars = [int(x) for x in input().split(" ")]
window_size = int(input())
 
car_count = [0, 0, 0]
# 初始化滑动窗口
for i in range(window_size):
    car_count[cars[i]] += 1
 
# 滑动窗口向前滑
max_res = max(max(car_count[0], car_count[1]), car_count[2])
for i in range(window_size, len(cars)):
    car_count[cars[i]] += 1
    car_count[cars[i - window_size]] -= 1
    max_res = max(max_res, max(max(car_count[0], car_count[1]), car_count[2]))
print(max_res)
```

# 完美走位

```
# 处理输入
input_str = input()
 
char_count = {'W': 0, 'A': 0, 'S': 0, 'D': 0}
 
# 频次统计
for single_char in input_str:
    char_count[single_char] += 1
 
# 特殊情况
if char_count['W'] == char_count['A'] and \
        char_count['W'] == char_count['S'] and \
        char_count['W'] == char_count['D']:
    print(0)
else:
    # 左右区间位置
    left = 0
    right = 0
    length = 0
 
    # 替换的最小长度
    res = len(input_str)
    # 出现次数最多的字母
    max_char_num = 0
    # 可替换字母个数, 随着指针移动，如果free_char_num 大于0且能被4整除，当前范围满足条件，左指针右移一格，否则右指针右移
    free_char_num = 0
 
    char_count[input_str[0]] -= 1
    while True:
        max_char_num = max(max((max(char_count['W'], char_count['S'])), char_count['A']), char_count['D']);
        length = right - left + 1
        free_char_num = length - ((max_char_num - char_count['W']) + (max_char_num - char_count['S']) + (
                max_char_num - char_count['A']) + (max_char_num - char_count['D']));
        if free_char_num >= 0 and free_char_num % 4 == 0:
            if length < res:
                res = length
 
            char_count[input_str[left]] += 1
            left += 1
 
        else:
            right += 1
            char_count[input_str[right]] -= 1
 
        if right >= len(input_str) - 1:  # 越界即结束
            break
 
    print(res)
```

# 字符串重新排列

```
arr = input().split()
from collections import Counter
# arr = "My sister is in the house not in the yard".split(" ")
 
# 算法入口
def main(arr):
    for i in range(len(arr)):
        arr[i] = "".join(sorted(arr[i]))
    count = dict(Counter(arr))
 
    arr.sort(key=lambda x: (-count[x], len(x), [ord(char) for char in x]))
 
    return " ".join(map(str, arr))
 
 
# 算法调用
print(main(arr))
```

# 单向链表中间节点

```
import copy
 
 
# 链表节点类
class ListNode:
    def __init__(self, val="", next=None):
        self.val = val
        self.next = next
 
 
# 处理输入
head = input().split(" ")
head_addr = head[0]
list_count = int(head[1])
 
# 构造节点信息map
node_info = {}
for i in range(list_count):
    # 节点信息
    input_node_info = input().split(" ")
    addr = input_node_info[0]
    val = int(input_node_info[1])
    next_addr = input_node_info[2]
    temp_node = ListNode(val, next_addr)
    node_info[addr] = temp_node
 
# 构造链表，剔除无效节点
size = 1
cur = 0
head_node = node_info[head_addr]
thead = copy.copy(head_node)
while (thead.next != '-1'):
    size += 1
    thead = node_info[thead.next]
 
# 找中间节点
while (head_node.next != -1):
    if ((size / 2) == cur):
        print(head_node.val)
        break
    head_node = node_info[head_node.next]
    cur += 1
```

# 字符串子序列II

```
a = input().strip()
b = input().strip()
 
j = len(b) - 1
ok = True
for i in range(len(a) - 1, -1, -1):
    if j == -1:
        print(-1)
        exit(0)
    find = False
    for k in range(j, -1, -1):
        if a[i] == b[k]:
            j = k - 1
            find = True
            break
    if not find:
        ok = False
if not ok:
    print(-1)
else:
    print(j + 1)
```

# 分苹果

```
n = int(input())
a = [int(x) for x in input().split()]
sums = 0
for x in a:
    sums = sums ^ x
if sums != 0:
    print(-1)
else:
    print(sum(a) - min(a))
```

# 事件推送

```
m, n, r = map(int, input().split())
numsA = list(map(int, input().split()))
numsB = list(map(int, input().split()))
for ai in numsA:
    for bj in numsB:
        if ai <= bj and bj - ai <= r:
            print(ai, bj)
            break
```

# 最大股票收益

```
def to_rmb(n):
    if n[-1] == "Y":
        return int(n[:-1])
    else:
        return int(n[:-1]) * 7
 
 
while 1:
    try:
        nums = list(map(to_rmb, input().split()))
 
        if not nums:
            print(0)
            break
 
        dp = []
        # 最大收益
        max_ = 0
        # 当前最小值
        min_ = nums[0]
        before_ = nums[0]
        for c in nums:
            if before_ > c:
                dp.append(max_)
                min_ = c
                max_ = 0
            else:
                min_ = min(min_, c)
                max_ = max(max_, c - min_)
            before_ = c
 
        dp.append(max_)
        print(sum(dp))
    except Exception as e:
        break
```

# 统计射击比赛成绩

```
while 1:
    try:
        n = int(input())
        ids = input().split(",")
        nums = list(map(int, input().split(",")))
 
        # 记录用户成绩
        dct = {}
        for i in range(n):
            if ids[i] in dct:
                dct[ids[i]].append(nums[i])
            else:
                dct[ids[i]] = [nums[i]]
 
        # 剔除长度小于3的用户
        for k, v in dct.items():
            if len(v) < 3:
                dct.pop(k)
            else:
                v.sort(reverse=True)
                dct[k] = sum(v[:3])
 
        ret = sorted(dct.items(), key=lambda x: (x[1], x[0]), reverse=True)
        print(",".join([id_ for id_, v in ret]))
    except Exception as e:
        break
```

# 金字塔

```
while 1:
    try:
        n = int(input())
 
        nums = [list(map(int, input().split())) for _ in range(n)]
 
        nums = sorted(nums, key=lambda x: x[1], reverse=True)
 
        dp = [0] * (n + 1)
        start = 0
        end = 0
        for i, j, m in nums:
            end = max(i, end)
            start = min(j, start)
            dp[j] += ((m + dp[i])//100) * 15
 
        print(f"{start} {dp[start]}")
    except Exception as e:
        break
```

# 流水线

```
m, n = map(int, input().split())
workTimes = list(map(int, input().split()))
workTimes.sort()
res = []
if n <= m:
    res = workTimes
else:
    res = workTimes[:m]  
    for i in range(m, n):
        minTime = min(res)  
        index = res.index(minTime)  
        res[index] += workTimes[i]  
print(max(res))
```

# Directory 删除

```
n=5
nums = [8,6],[10,8],[6,0],[20,8],[2,6]
del_num = 8
rel_dict = {}
all_nums = []
for num in nums:
    v,k = num
    if k not in rel_dict:
        rel_dict[k] = []
    rel_dict[k].append(v)
    all_nums.extend(num)
all_nums = list(set(all_nums))
print(rel_dict)
print(all_nums)
 
queue = [del_num]
while queue:
    num = queue.pop(0)
    if num in all_nums:
        all_nums.remove(num)
    if num in rel_dict:
        queue.extend(rel_dict[num])
 
if 0 in all_nums:
    all_nums.remove(0)
print(all_nums)
```

# 最长广播效应

```
n = 5
t = 7
link_list = [[2,1],[1,4],[2,4],[2,3],[3,4],[3,5],[4,5]]
def bfs():
    queue = [2] #添加起点值
    queue1 = []
    visited = [2]#讲起点值放入已访问列表，防止重复计算
    a= 0
    while queue:
        m = queue.pop(0)
        for k,v in  enumerate(link_list):
            non_m = v[0] if m!=v[0] else v[1]
            if m in v and non_m not in visited:
                visited.append(non_m)
                queue1.append(non_m)
                link_list.pop(k)
        if len(queue1)>0:
            a+=1
            queue = queue1
            queue1 = []
    return a*2
print(bfs())
```

# 考古问题

```
while 1:
    try:
        chars = input().split()
 
        dp = []
 
        def dfs(sub):
            if len(sub) == len(chars):
                t = "".join(sub)
                if t not in dp:
                    dp.append(t)
            else:
                for c in chars:
                    if c not in sub:
                        dfs(sub + [c])
 
        for c in chars:
            dfs([c])
 
        print(" ".join(dp))
    except Exception as e:
        break
```

# 贪吃蛇

```
steps = input().split(" ")
MN = input().split(" ")
M = int(MN[0])
N = int(MN[1])
import sys
 
arr = []  
first = []  
for i in range(M):
    line = sys.stdin.readline().strip().split()
    arr.append(line)
print(arr)
for i in range(N):
    for j in range(N):
        if arr[i][j] == "H":
            first.append(i)
            first.append(j)
print(first)
direction = {
    'U': [-1, 0],
    'D': [1, 0],
    'L': [0, -1],
    'R': [0, 1],
}
goStep = [0, -1]
snake = []
for s in range(len(steps)):
    item = steps[s]
    if item == 'G':  
        step = [first[0] + goStep[0], first[1] + goStep[1]]  
        if step[0] < 0 or step[1] < 0 or step[0] >= N or step[1] >= M:  
            break
        stepStr = arr[step[0]][step[1]]  
        if stepStr == "F":  
            arr[first[0]][first[1]] = "S"  
            arr[step[0]][step[1]] = "H" 
            snake.insert(0, first) 
            first = step
        else: 
            length = len(snake)
            if length > 0:  
                tail = snake[length - 1]  
                arr[tail[0]][tail[1]] = "E"  
                snake.pop()
                arr[first[0]][first[1]] = "H"  
                snake.insert(0, first)
            else:
                arr[first[0]][first[1]] = "E"
            if stepStr == "S":
                break
            arr[step[0]][step[1]] = "H"  
            first = step
        print(arr)
    else:
        goStep = direction[item]  
print(len(snake) + 1)
```

# 最大社交距离

```
n= 10
nums = [1,1,1,1,-4,1]
steated = []
def paizuo(n,nums):
    for i in range(len(nums)):
        ops = nums[i]
        if ops>0:
            if len(steated) == 0:
                if len(nums) == 1:
                    return 0
                steated.append(0)
            elif len(steated) == 1:
                if len(nums) == 2:
                    return n-1
                steated.append(n-1)
                continue
            elif len(steated)<n:
                max_len = 0
                start = 0
                for j in range(len(steated)-1):
                    max_length = steated[j + 1] - steated[j]
                    if max_length//2 >max_len:
                        max_len = max_length//2
                        start = steated[j]
                steated.append(start+max_len)
                steated.sort()
                if i ==len(nums)-1:
                    return start+max_len
            else:
                return -1
        else:
            index = steated.index(-ops)
            steated.pop(index)
    print(steated)
```

# 最小传输时延

```
while 1:
    try:
        n, m = map(int, input().split())
        map_ = {}
        for i in range(n):
            ui, vi, wi = list(map(int, input().split()))
            if ui not in map_:
                map_[ui] = {}
            map_[ui].update({vi: wi})
 
        s, e = map(int, input().split())
 
 
        # print(map_)
        # {1: {2: 11, 3: 50}, 2: {3: 13}}
 
        def dfs(start, end, high):
            """
            :param start: 起始位置
            :param end: 结束位置
            :param high: 当前深度，超过m跳出
            :return:
            """
            # float("inf") 无穷大
            min_ = float("inf")
            # 假设所有起始点都在map中
            if start not in map_ or high > m:
                return min_
 
            next_ = map_[start]
            if end in next_:
                min_ = min(min_, next_[end])
 
            for k, v in next_.items():
                min_ = min(min_, v + dfs(k, e, high + 1))
 
            return min_
 
 
        print(dfs(s, e, 1))
    except Exception as e:
        break
```

# 叠积木

```
nums = [3,6,3,3,3]
nums = sorted(nums,reverse=True)
#nums = [9 ,9, 9, 5, 3 ,2 ,2, 2 ,2, 2]
total = sum(nums)
max_nums = max(nums)
def dfs(nums,k,target):
    while nums and nums[0] ==target:
        nums.pop(0)
        k-=1
    if nums == []:
        return True
    v = nums[0]
    dp = [0] * k
    for i in range(k):
        if dp[i] +v <=target:
            dp[i]+=v
            if dfs(nums[1:],k,target):
                return True
            dp[i] -=v
        if dp[i]==0:break
    return False
for k in range(2,total//max_nums+1):
    target = total//k
    if total%k ==0 and target >= max_nums:
        flag = dfs(nums, k, target)
        if flag:
           print(k)
```

# 打印任务排序

```
nums = [9,3,5]
#nums= [1,2,2]
new_nums = sorted(nums,reverse=True)
print(new_nums)
res = []
for i in range(len(new_nums)):
    temp = nums[i]
    index = new_nums.index(temp)
    res.append(index)
    new_nums[index] = -1
print(res)
```

# 统计文本数量

```
import sys
 
lines = []
 
def _add_lines(data):
    # 去除前后的空白字符
    data = data.strip()
    if data:
        lines.append(data)
 
line = ""
for _line in sys.stdin:
    # 替换文本中的 \" \' 为 #，减少不必要的判断
    _line = _line.replace('\\"', "#").replace("\\'", "#")
    start = 0
    end = 0
    while end < len(_line):
        # 跳过双引号字符串，中间的内容不做判断
        if _line[end] == '"' and '"' in _line[end+1:]:
            end += _line[end+1:].index('"') + 2
        # 跳过单引号字符串，中间的内容不做判断
        elif _line[end] == "'" and "'" in _line[end+1:]:
            end += _line[end+1:].index("'") + 2
        # 跳过注释直到换行结束
        elif _line[end] == "-":
            end = len(_line)
        # 一个有效的文本
        elif _line[end] == ";":
            end += 1
            line += _line[start: end]
            _add_lines(line)
            # 重新记录新的文本，一行中有多个 分号的情况
            start = end
            end += 1
            line = ""
        else:
            end += 1
    # 文本为结束，先记录下来
    line += _line[start: end]
 
# 最后一条可以没有”;”
_add_lines(line)
 
# print(lines)
print(len(lines))
```

# 报文解压缩

```
class Solution:
    def decodeString(self, s: str) -> str:
        stack, a, n = [['', 1, '']], '', ''
        for c in s:
            if c.isalpha():
                a += c
            elif c.isdigit():
                n += c
            elif c == '[':
                stack.append([a, int(n), ''])
                a = n = ''
            else:
                p, t, b = stack.pop()
                stack[-1][-1] += p + t * (b + a)
                a = ''
        return stack.pop()[-1] + a
 
 
if __name__ == "__main__":
    input_str = str(input().strip())
    function = Solution()
    results = function.decodeString(input_str)
    print(results)
```

# 污染水域

```
nums = [1,0,1,0,0,0,1,0,1]
length = int(len(nums)**0.5)
grids = []
queue=[]
for i in range(0,len(nums),3):
    grids.append(nums[i:i+3])
for i in range(length):
    for j in range (length):
        if grids[i][j] == 1:
            queue.append([i,j])
time =-1
while queue:
    len1 = len(queue)
    for _ in range(len1):
        x, y = queue.pop(0)
        for i,j in [(1,0),(0,-1),(-1,0),(0,1)]:
            temp_x = x + i
            temp_y = y + j
            if temp_x>=0 and temp_x <length and temp_y>=0 and temp_y <length and grids[temp_x][temp_y] == 0:
                grids[temp_x][temp_y] = 1
                queue.append([temp_x,temp_y])
    time +=1
for i in grids:
    if 0 in i:
        print(-1)
        break
else:
    print(time)
```

# 连续出牌数量

```
def findMaxCards(cards):
    n = len(cards)
    matrix = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if cards[i][0] == cards[j][0] or cards[i][1] == cards[j][1]:
                matrix[i][j] = 1
    visited = [0 for _ in range(n)]  
    max_res = 0  
 
    temp = 0  
    for card_idx in range(n):
        if visited[card_idx] == 0:
            queue = [card_idx]
            visited[card_idx] = 1
        else:
            continue
 
        while queue:
            i = queue.pop(0)
            temp += 1
            for j in range(n):
                if matrix[i][j] == 1 and visited[j] == 0 and i != j:
                    queue.append(j)
                    visited[j] = 1
        max_res = max(max_res, temp)
        temp = 0
    return max_res
 
 
if __name__ == "__main__":
    cards = ['4r', '5r', '4n', '3t', '1g']
    print(findMaxCards(cards))
```

# 简易内存池

```
from sys import stdin
 
 
class MiniMemoryPool:
    def __init__(self):
        self.memory = []
 
    def request(self, size: int) -> str:
        if size <= 0 or size > 100:
            return "error"
        if len(self.memory) == 0:
            self.memory.append((0, size - 1))
            return "0"
        else:
            bef_start, bef_stop, insert_index = -1, -1, 0
            for start, stop in self.memory:
                if start == 0:
                    pass
                elif start - bef_stop - 1 >= size:
                    self.memory.insert(insert_index, (bef_stop + 1, bef_stop + size))
                    return str(bef_stop + 1)
                bef_start, bef_stop = start, stop
                insert_index += 1
            if bef_stop + size < 100:
                self.memory.append((bef_stop + 1, bef_stop + size))
                return str(bef_stop + 1)
            else:
                return "error"
 
    def release(self, start_addr: int) -> bool:
        found = False
        found_couple = (0, 0)
        for item in self.memory:
            if item[0] == start_addr:
                found = True
                found_couple = item
                break
        if found:
            self.memory.remove(found_couple)
        return found
 
 
if __name__ == "__main__":
    command_count = int(input())
    pool = MiniMemoryPool()
    for _ in range(command_count):
        command, size = stdin.readline().strip().split("=")
        if command == "REQUEST":
            print(pool.request(int(size)))
        elif command == "RELEASE":
            released = pool.release(int(size))
            if not released:
                print("error")
```

# 区间交集

```
import sys
 
arr = []
for line in sys.stdin.readlines():
    if line == '\n':
        break
    arr.append(list(map(int, line.split(' '))))
if len(arr) == 1:
    print(arr[0])
arr.sort(key=lambda x: x[0])
comm_section = []
for i in range(len(arr) - 1):
    for j in range(i + 1, len(arr)):
        if arr[i][-1] >= arr[j][0]:
            comm_section.append([arr[j][0], min(arr[i][-1], arr[j][-1])])
            if len(comm_section) == 1:
                print(comm_section)
comm_section.sort(key=lambda x: x[0])
l = len(comm_section)
i = 0
while i <= l - 2:
    if comm_section[i][-1] > comm_section[i + 1][0]:
        comm_section[i][-1] = max(comm_section[i][-1], comm_section[i + 1][-1])
        comm_section.pop(i + 1)
        l -= 1
    else:
        i += 1
    print(comm_section)
```

# 单词搜索

```
def WordSearch():
    n, m = tuple([int(x) for x in input().strip().split(" ")])
    s = input().strip()
    arr = []
    for i in range(n):
        arr.append(input().strip())
 
    def loc_surroundings(loc):
        loc_up = (loc[0] - 1, loc[1])
        loc_right = (loc[0], loc[1] + 1)
        loc_below = (loc[0] + 1, loc[1])
        loc_left = (loc[0], loc[1] - 1)
        surroundings = []
        for location in [loc_up, loc_right, loc_below, loc_left]:
            if 0 <= location[0] <= n - 1 and 0 <= location[1] <= m - 1:
                surroundings.append(location)
        return surroundings
 
    def search_path(start_loc, s_index, tmp_result, result):
        if s_index > len(s) - 2:
            result.append(tmp_result[:])
            return
        for surround_loc in loc_surroundings(start_loc):
            if surround_loc != start_loc and surround_loc not in tmp_result and \
                    arr[surround_loc[0]][surround_loc[1]] == s[s_index + 1]:
                tmp_result.append(surround_loc)
                search_path(surround_loc, s_index + 1, tmp_result, result)
                tmp_result.pop()
 
    tmp_result, result = [], []
    for i in range(m):
        for j in range(n):
            if arr[i][j] == s[0]:
                tmp_result.append((i, j))
                search_path((i, j), 0, tmp_result, result)
                if result:
                    return i + 1, j + 1
 
 
if __name__ == "__main__":
    print(WordSearch())
```

# 最长的顺子

```
def the_longest_chain(my_poker, history_poker):
    s1 = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    s2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
    poker = {}
    poker_reverse = {}
    for i in range(len(s1)):
        poker[s1[i]] = s2[i]
        poker_reverse[s2[i]] = s1[i]
    my_poker = [poker.get(x) for x in str(my_poker).split('-')]
    history_poker = [poker.get(x) for x in str(history_poker).split('-')]
    all_poker = [x for x in range(3, 15)] * 4
    for i in my_poker + history_poker:
        if all_poker.index(i):
            all_poker.remove(i)
    remain_poker = list(set(all_poker))
    remain_poker.sort()
    tmp_result = []
    result = []
    for i in range(len(remain_poker) - 1):
        tmp_result.append(remain_poker[i])
        for j in range(i + 1, len(remain_poker)):
            if remain_poker[j] - remain_poker[j - 1] == 1:
                tmp_result.append(remain_poker[j])
            else:
                break
        if len(tmp_result) > len(result):
            result = tmp_result[:]
        tmp_result.clear()
    return '-'.join([poker_reverse[x] for x in result])
 
 
if __name__ == "__main__":
    # print(the_longest_chain("3-3-3-3-4-4-5-5-6-7-8-9-10-J-Q-K-A", "4-5-6-7-8-8-8"))
    line1 = str(input().strip())
    line2 = str(input().strip())
    print(the_longest_chain(line1, line2))
```

# 九宫格按键输入法

```
class Solution:
    def NineGridInputMethod(self, input_str):
        dic = {'1': ',.', '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
               '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}
        num_mode = True  
        length = len(input_str)
        i = 0
        result = ""
        while i < length:
            s: str = input_str[i]
            if s == '#':
                num_mode = not num_mode
                i += 1
                continue
            if s == '/':
                i += 1
                continue
            if num_mode:
                result += s
                i += 1
                continue
            if s == '0':
                result += " "
                i += 1
                continue
            cnt = 0
            while i < length and input_str[i] == s:
                cnt += 1
                i += 1
            string = dic[s]
            result += string[cnt % len(string) - 1]
        return result
 
if __name__ == "__main__":
    line = str(input().strip())
    function = Solution()
    results = function.NineGridInputMethod(line)
    print(results)
```

# 任务最优调度

```
def task_schedule():
    arr = input().strip().split(",")
    n = int(input().strip())
    d = {} 
    d_max = 0 
    d_max_n = 0  
    for i in arr:
        d[i] = d.get(i, 0) + 1
        if d[i] > d_max:
            d_max = d[i]
    for k, v in d.items():
        if d[k] == d_max:
            d_max_n += 1
    return max((d_max - 1) * (n + 1) + d_max_n, len(arr))
 
 
if __name__ == "__main__":
    print(task_schedule())
```

# 仿lisp运算

```
while 1:
    try:
        nums = input().split()
        stack_a = []
        stack_b = []
 
        for c in nums:
            if "(" in c:
                stack_a.append("(")
                stack_a.append(c[1:])
            elif ")" in c:
                stack_a.append(c[:c.index(")")])
                stack_a += list(c[c.index(")"):])
            else:
                stack_a.append(c)
 
        while stack_a:
            temp = stack_a.pop()
            if temp == ")":
                stack_b.append(temp)
            elif temp == "(":
                com = stack_b.pop()
                a = int(stack_b.pop())
                b = int(stack_b.pop())
                stack_b.pop()
                if com == "add":
                    stack_b.append(a+b)
                elif com == "sub":
                    stack_b.append(a-b)
                elif com == "mul":
                    stack_b.append(a*b)
                else:
                    if b == 0:
                        print("error")
                        break
                    stack_b.append(a//b)
            else:
                stack_b.append(temp)
 
        if stack_b:
            print(stack_b.pop())
    except Exception as e:
        break
```

# 学生方阵

```
n = 3
m = 4
nums = [["F","M","M","F"],["F","M","M","F"],["F","F","F","M"]]
def bfs(grids,x,y,opt_type,max_count):
    if x<0 or x>=n or y<0 or y>=m:
        return max_count
    if grids[x][y] == "M":
        if opt_type == 0:
            return bfs(grids,x,y+1,opt_type,max_count+1)
        if opt_type == 1:
            return bfs(grids,x+1,y,opt_type,max_count+1)
        if opt_type == 2:
            return bfs(grids,x+1,y+1,opt_type,max_count+1)
        if opt_type == 3:
            return bfs(grids,x+1,y-1,opt_type,max_count+1)
    else:
        return max_count
res = []
for i in range(n):
    for j in range(m):
        if nums[i][j] == "M":
            res.append(
                max(
                    bfs(nums, i, j, 0, 0),
                    bfs(nums, i, j, 1, 0),
                    bfs(nums, i, j, 2, 0),
                    bfs(nums, i, j, 3, 0),
                )
            )
print(max(res))
```

# 发广播

```
data = [[1,1,0],[1,1,0],[0,0,1]]
data = [[1,0,0],[0,1,0],[0,0,1]]
data = [[1,1],[1,1]]
n=2
count = 0
for i in range(n):
    for j in range(n):
        if data[i][j]==1:
            queue = [(i,j)]
            while queue:
                x,y = queue.pop(0)
                for kk,k in [(0,1),(0,-1),(1,0),(-1,0)]:
                    temp_x = x + kk
                    temp_y = y + k
 
                    if temp_x>=0 and  temp_x<n and temp_y>=0 and temp_y<n and data[temp_x][temp_y] == 1:
                            data[temp_x][temp_y] = 0
                            queue.append((temp_x,temp_y))
            count+=1
print(count)
```

# 字符串比较

```
s1 = "xxcdefg"
s2 = "cdefghi"
v = 5
size = len(s1)
res = []
for i in range(size):
    sum = abs(ord(s1[i]) - ord(s2[i]))
    if sum <v:
        for j in range(i+1,size):
            sum +=abs(ord(s1[j]) - ord(s2[j]))
            if sum>v:
                res.append(j-i)
                break
        if sum <v:
            res.append(j - i+1)
    elif sum == v:
        res.append(1)
    else:
        res.append(0)
print(res)
```

# 斗地主之顺子

```
input_list = str(input()).split(" ")
instead = []
for i in input_list:
    if i.isdigit() and i != '2':
        instead.append(int(i))
    if i == "J":
        instead.append(11)
    if i == "Q":
        instead.append(12)
    if i == "K":
        instead.append(13)
    if i == "A":
        instead.append(14)
new_list = sorted(list(set(instead)))
 
i = 0
while i < (len(new_list) - 4):
    tmp = [str(new_list[i])] 
    for j in range(1, len(new_list)):
        if i + j <= len(new_list) - 1:
            if new_list[i] + j == new_list[i + j]:  
                if new_list[i + j] == 11:
                    tmp.append("J")
                elif new_list[i + j] == 12:
                    tmp.append("Q")
                elif new_list[i + j] == 13:
                    tmp.append("K")
                elif new_list[i + j] == 14:
                    tmp.append("A")
                else:
                    tmp.append(str(new_list[i + j]))
            else:
                i = i + j 
                break  
        else:
            i = i + j
            break
    else:
        i = i + j  
    if len(tmp) >= 5: 
        print(" ".join(tmp))
```

# 数据分类

```
if __name__ == "__main__":
    nums = list(map(int, input().split()))
    c = nums[0]
    b = nums[1]
    nums = nums[2:]
    dic = {}
    for i in nums:
        strI = str(hex(i))[2:]
        length = len(strI)
        if length < 8:
            strI = '0' * (8 - length) + strI
        else:
            strI = strI[:8]
        # print(strI)
        sum = 0
        for i in range(4):
            sum += int(strI[i * 2:i * 2 + 2], 16)
        typeNum = sum % b
        # print(typeNum)
        if typeNum < c:
            if typeNum in dic.keys():
                dic[typeNum] += 1
            else:
                dic[typeNum] = 1
    print(max(dic.values()))
```

# 高效的任务规划

```
while 1:
    try:
        m = int(input())
        for i in range(m):
 
            n = int(input())
            nums = [list(map(int, input().split())) for j in range(n)]
            nums = sorted(nums, key=lambda x: x[1], reverse=True)
 
            tal = 0
            bal = 0
            while nums:
                b, j = nums.pop(0)
                if bal >= b:
                    bal -= b
                else:
                    t = b - bal
                    tal += t
 
                if bal < j:
                    t = j - bal
                    bal += t
                    tal += t
 
            print(tal)
    except Exception as e:
        break
```

# 数组二叉树

```
nums = [-1]
res = []
nums[1:] = list(map(int, input().split()))
leafNode = []
for i in range(2, len(nums)):
    if nums[i] == -1:  
        continue
    elif (2 * i > len(nums) - 1 or nums[2 * i] == -1) and \
            (2 * i + 1 > len(nums) - 1 or nums[2 * i + 1] == -1):
        leafNode.append(nums[i]) 
minLeafNode = min(leafNode)  
index = nums.index(minLeafNode)  
while index > 0:
    res.append(str(nums[index]))  
    index = index 
res.reverse()
print(' '.join(res))
```

# 分糖果II

```
n = int(input())
a = [int(x) for x in input().split()]
sums = 0
for x in a:
    sums = sums ^ x
if sums != 0:
    print('NO')
else:
    print(sum(a) - min(a))
    
```

# 字符串匹配 

```
import re
 
while 1:
    try:
        nums = input().split()
        pattern = input()
        ret = []
        for index, w in enumerate(nums):
            if re.match(pattern, w):
                ret.append(str(index))
        if ret:
            print(",".join(ret))
        else:
            print("-1")
    except Exception as e:
        break
```

# 比较两个版本号的大小

```
v1 = "5.6.1"
v2 = "5.6.2a"
def com(s1,s2):
    if s1 == s2:
        return 0
    len1 = len(s1)
    len2 = len(s2)
    if len1 >len2:
        return 1
    elif len1<len2:
        return -1
    else:
        for i in range(len1):
            if s1[i] != s2[i]:
                return -1 if ord(s2[i]) >ord(s1[i]) else 1
 
v1_list = v1.split(".")
v2_list = v2.split(".")
min_ = min(len(v1_list),len(v2_list))
 
for i in range(min_):
    a = v1_list[i].lstrip("0")
    if a =="":
        a = "0"
    b = v2_list[i].lstrip("0")
    if b == "":
        b = "0"
    flag = com(a,b)
    if flag !=0:
        print(flag)
if flag==0:
    if len(v1_list)>len(v2_list):
        new_list = v1_list[min_:]
        new_str = "".join(new_list)
        if new_str.strip("0")!="":
            print(1)
        else:
            print(0)
    else:
        new_list = v2_list[min_:]
        new_str = "".join(new_list)
        if new_str.strip("0")!="":
            print(-1)
        else:
            print(0)
```

# 移除 K 位数字的最小值

```
stack = []
for i in range(len(s)):
    n = int(s[i])
    while k>0 and stack and stack[-1]>n:
        stack.pop()
        k-=1
 
    if stack!=[] or n!=0:
        stack.append(n)
 
while k>0:
    stack.pop()
    k-=1
print(stack)
```

# 转骰子

```
def throw_dice(s):
    arr = ['1', '2', '3', '4', '5', '6']
 
    def throw(operator):
        if operator == "L":
            arr[0], arr[1], arr[2], arr[3], arr[4], arr[5] = arr[4], arr[5], arr[2], arr[3], arr[1], arr[0]
        elif operator == 'R':
            arr[0], arr[1], arr[2], arr[3], arr[4], arr[5] = arr[5], arr[4], arr[2], arr[3], arr[0], arr[1]
        elif operator == 'F':
            arr[0], arr[1], arr[2], arr[3], arr[4], arr[5] = arr[0], arr[1], arr[4], arr[5], arr[3], arr[2]
        elif operator == 'B':
            arr[0], arr[1], arr[2], arr[3], arr[4], arr[5] = arr[0], arr[1], arr[5], arr[4], arr[2], arr[3]
        elif operator == 'A':
            arr[0], arr[1], arr[2], arr[3], arr[4], arr[5] = arr[3], arr[2], arr[0], arr[1], arr[4], arr[5]
        elif operator == 'C':
            arr[0], arr[1], arr[2], arr[3], arr[4], arr[5] = arr[2], arr[3], arr[1], arr[0], arr[4], arr[5]
        return arr
 
    for i in s:
        throw(i)
    return ''.join(arr)
 
 
if __name__ == "__main__":
    print(throw_dice("LRFBAC"))
```

# 面试

```
def dfs(nums,s,i,k,c,end,m,n):
    if c==0:
        return 1
    if i>=n or k>=m:
        return 1+dfs(nums,s,0,0,c,0,m,n)
    if s[i] == '0' and nums[i][1] >= end:
        if end:
            x = dfs(nums,s,i+1,k,c,end,m,n)
            s = s[:i] + '1' +s[i+1:]
 
            y = dfs(nums,s,i+1,k+1,c-1,nums[i][1],m,n)
            return x if x<y else y
        else:
            s = s[:i] + '1' +s[i+1:]
            return dfs(nums,s,i+1,k+1,c-1,nums[i][1],m,n)
    else:
        return dfs(nums, s, i + 1, k, c , end, m, n)
 
m = int(input())
n = int(input())
 
nums = []
for _ in range(n):
    nums.append(list(map(int, input().split())))
 
nums.sort(key=lambda x: x[0])
s = "0"*n
 
res = dfs(nums,s,0,0,n,0,m,n)
print(res)
```

# 叠书

```
while 1:
    try:
        n = int(input())
 
        nums = [list(map(int, input().split())) for _ in range(n)]
 
        dp = []
        lens = len(nums)
 
 
        def dfs(sub, stack, count=1):
            if count >= lens:
                dp.append(len(sub))
            else:
                while stack:
                    num = stack.pop(0)
                    if num[0] < sub[-1][0] and num[1] < sub[-1][1]:
                        sub.append(num)
                    dfs(sub, stack, count + 1)
 
 
        for i in range(lens):
            stack = nums[:i] + nums[i + 1:]
            dfs([nums[i]], stack)
 
        print(max(dp))
    except Exception as e:
        break
```

# 信道分配

```
import collections
 
if __name__ == "__main__":
    while True:
        try:
            N = int(input())
            l = list(map(int, input().split()))
            d = collections.defaultdict(int)
            for i in range(len(l)):
                d[2 ** i] = l[i]
            tar = int(input())
        except EOFError:
            break
 
    res = 0
    for k, v in d.items():
        if k >= tar:
            res += v
            d[k] = 0
    t = tar
    for k, v in sorted(d.items(), key=lambda x: x[0]):
        while v > 0:
            t -= k
            v -= 1
            if t <= 0:
                res += 1
                t = tar
    print(res)
```

# 没有回文串

```
def is_huiwen(s):
 
    for i in range(1,len(s)):
        if s[i] == s[i-1]:
            return True
    for i in range(2,len(s)):
        if s[i] == s[i-2]:
            return True
    return False
def check_result(s,pos):
    if pos<0:
        return False
    if pos==n:
        return True
    dot_pos = s[pos]
    end = ord("a") +n
    start = ord(dot_pos) +1
    for i in range(start,end):
        s[pos] = chr(i)
        print(chr(i))
        if is_huiwen(s):
            continue
        if check_result(s,pos+1):
            return True
    s[pos] = chr(ord("a")-1)
    return check_result(s,pos-1)
n=3
s = "cba"
s="dbad"
nums = [i for i in s]
if check_result(nums,2):
    print(nums)
else:
    print("NO")
```

# 服务失效判断 

```
servers = input()
errors = input()
 
class Node:
    def __init__(self, val):
        self.val = val
        self.next = []
 
class Server:
    servers = {}
    heads = []
 
    def add(self, server_link):
        # 新增节点及依赖关系
        a, b = server_link.split("-")
        if a not in self.servers:
            self.servers[a] = Node(a)
        else:
            # a依赖b，但a之前是头节点，需要从头节点列表中移除
            if self.servers[a] in self.heads:
                self.heads.remove(self.servers[a])
 
        if b not in self.servers:
            self.servers[b] = Node(b)
            self.servers[b].next.append(self.servers[a])
            # a依赖b且b是新增节点，添加到头节点列表
            self.heads.append(self.servers[b])
 
    def delete(self, del_node):
        # 删除故障节点
        def _delete_next(node):
            if del_node in node.next:
                node.next.remove(del_node)
                return
            for _node in node.next:
                _delete_next(_node)
 
        if del_node in self.heads:
            self.heads.remove(del_node)
            return
 
        for _node in self.heads:
            _delete_next(_node)
 
    def get_servers(self):
        # 获取正常节点
        result = []
        def _do_next(node):
            result.append(node.val)
            for _n in node.next:
                _do_next(_n)
 
        for _n in self.heads:
            _do_next(_n)
        result = sorted(result, key=lambda x: servers.index(x))
        return ",".join(result) if result else ","
 
ser = Server()
for s in servers.split(','):
    ser.add(s)
for e in errors.split(','):
    ser.delete(ser.servers[e])
print(ser.get_servers())
```

#  欢乐的周末

```
while 1:
    try:
        n, m = map(int, input().split())
 
        map_ = [input().split() for i in range(m)]
        # 小华小为的坐标
        start_spots = []
        # 聚餐点坐标
        end_spots = []
 
        for i in range(m):
            for j in range(n):
                if map_[i][j] == "2":
                    start_spots.append((i, j))
                elif map_[i][j] == "3":
                    end_spots.append((i, j))
 
        count = 0
        for end_ in end_spots:
 
            def dfs(si, sj, cache):
                if (si, sj) in cache:
                    return False
                cache.append((si, sj))
                # 控制地图边界
                if not (0 <= si < m and 0 <= sj < n):
                    return False
                # 遇到障碍物
                if map_[si][sj] == "1":
                    return False
                if (si, sj) == tuple(end_):
                    return True
 
                # 有四种情况可以向上下左右走
                return dfs(si + 1, sj, cache) or dfs(si - 1, sj, cache) \
                       or dfs(si, sj + 1, cache) or dfs(si, sj - 1, cache)
 
 
            # 已到达的坐标，避免重复计算
            cache_a = []
            cache_b = []
            if dfs(start_spots[0][0], start_spots[0][1], cache_a) \
                    and dfs(start_spots[1][0], start_spots[1][1], cache_b):
                count += 1
 
        print(count)
    except Exception as e:
        break
```

# 机器人走迷宫 

```
def func():
    x, y = map(int, input().split())
    k = int(input())
    a = []
    for i in range(k):
        a.append(list(map(int, input().split())))
    b = [[0] * y for j in range(x)]
    for i in a:
        b[i[0]][i[1]] = -1
 
    def run(i, j, b):
        b[i][j] = 1
        if i == x - 1 and j == y - 1:
            return b
        if i + 1 < x and b[i + 1][j] == 0:
            b = run(i + 1, j, b)
        if j + 1 < y and b[i][j + 1] == 0:
            b = run(i, j + 1, b)
        if (i + 1 >= x or b[i + 1][j] == -1 or b[i + 1][j] == 2) and (
                j + 1 >= y or b[i][j + 1] == -1 or b[i][j + 1] == 2):
            b[i][j] = 2
            if i - 1 >= 0 and b[i - 1][j] == 1:
                b = run(i - 1, j, b)
            if j - 1 >= 0 and b[i][j - 1] == 1:
                b = run(i, j - 1, b)
        return b
 
    b = run(0, 0, b)
    k = 0  # 陷阱标为0
    c = 0  # 不可达标为2
    for i in range(len(b)):
        for j in range(len(b[0])):
            if b[i][j] == 0:
                c += 1
            elif b[i][j] == 2:
                k += 1
    print(k, c)
 
 
if __name__ == '__main__':
    func()
```

# 最长的指定瑕疵度的元音子串

```
class Solution:
    def longest_flawedvowel_substr_len(self, flaw, input_string):
        left = 0
        maxi = 0
        count = 0
        for i in range(len(input_string)):
            if input_string[i] not in 'aeiouAEIOU':
                count += 1
            while count > flaw and i > left:
                if input_string[left] not in 'aeiouAEIOU':
                    count -= 1
                left += 1
            if input_string[left] in 'aeiouAEIOU' and input_string[i] in 'aeiouAEIOU' and count == flaw:
                maxi = max(maxi, i - left + 1)
        return maxi
 
 
if __name__ == "__main__":
    flaw = int(input().strip())
    input_string = input().strip()
    function = Solution()
    result = function.longest_flawedvowel_substr_len(flaw, input_string)
    print(result)
```

# 猜密码

```
import itertools
if __name__ == "__main__":
    nums = list(map(int, input().split(',')))
    n = int(input())
    res = []
    nums.sort()
    for i in range(n, len(nums) + 1):
        for num in itertools.combinations(nums, i):
            res.append(','.join(map(str, num)))
    if len(res) > 0:
        for s in sorted(res):
            print(s)
    else:
        print("none")
```

# 电信号

```
while 1:
    try:
        nums = input()
 
        dp = []
        cache = []
        for c in nums:
            if cache and cache[-1] == "0" == c:
                dp.append("".join(cache))
                cache = [c]
            else:
                cache.append(c)
        else:
            if cache:
                dp.append("".join(cache))
 
        sub = max(dp, key=lambda x: 0 if "11" in x else len(x))
        print(sub)
    except Exception as e:
        break
```

# 迷宫问题

```
x = 5
y = 5
nums = [[0 ,1 ,0 ,0, 0],[0 ,1, 0, 1, 0],[0 ,0, 0 ,0 ,1],[0 ,1, 1, 1, 0],[0 ,0, 0, 0, 0]]
def out(i,j):
    if i == x-1 and j == y-1:
        nums[i][j] =-1
        return
    if nums[i][j] !=0:
        return
    if i<x-1:
        out(i+1,j)
    if j<y-1:
        out(i,j+1)
    if i==x-1 or j ==y-1:
        if i==x-1 and j<y-1 and nums[i][j+1] !=-1:
            nums[i][j] = 2
        elif j==y-1 and i<x-1 and nums[i+1][j] !=-1:
            nums[i][j] = 2
        else:
            nums[i][j] = -1
    elif nums[i+1][j] !=-1 and nums[i][j+1] !=-1:
        nums[i][j] = 2
    else:
        nums[i][j] = -1
 
out(0,0)
res = []
for i in range(x):
    for j in range(y):
        if nums[i][j] == -1:
            res.append([i,j])
print(res)
print(nums)
```

# n进制减法

```
# 0-9, A-Z
mapping = list(map(str, range(10))) + [chr(i) for i in range(ord('A'), ord('Z')+1)]
 
def subtract():
    n, a, b = input().split()
    n = int(n)
 
    def _get(data):
        # 除了单独的0以外，不能是以0开头的字符串
        if data[0] == "0" and data != "0":
            raise ValueError
        return int(data, n)
 
    try:
        c = _get(a) - _get(b)
        # 0表示结果为整数，1表示结果为负数
        flg = 0 if c >= 0 else 1
    except ValueError as e:
        # -1表示出错
        return "-1"
 
    ret = []
    c = abs(c)
    while c:
        ret.append(mapping[c % n])
        c = c // n
 
    return f'{flg} {"".join(ret[::-1])}'
 
print(subtract())
```

# 热点网站统计

```
import collections
import sys
 
urls = []
for line in sys.stdin:
    line = line.replace("\n", "")
    if '.' in line:
        urls.append(line)
    else:
        dct = collections.Counter(urls)
        ret = sorted(dict(dct).items(), key=lambda x: (-x[1], x[0]))
        print(",".join([k for k, v in ret[:int(line)]]))
```

# 找到比自己强的人数 

```
nums = [[2,1],[3,2]]
rel_dict = {}
for num in nums:
    teacher = num[0]
    student = num[1]
    if teacher>student:
        rel_dict[teacher] = rel_dict.setdefault(student,0)+1
    else:
        rel_dict[student] = 0
print(rel_dict)
new_dict = sorted(rel_dict.items(),key=lambda k:k[0])
print(new_dict)
```

# 竖直四子棋

```
def is_sucess(x,y,grids):
    count,jishu = 0,3
    i,j = x,y
    if x<n-3: #竖直方向
        while jishu>0 and grids[x][y]==grids[++i][j]:
            count+=1
            jishu-=1
        if count==3:
            return True
 
    count, jishu = 0, 3
    i, j = x, y
    if y>=3: #左侧横向
        while jishu>0 and grids[x][y]==grids[i][--j]:
            count += 1
            jishu -= 1
        if count == 3:
            return True
 
    count, jishu = 0, 3
    i, j = x, y
    if y<m-3: #右侧横向
        while jishu>0 and grids[x][y]==grids[i][++j]:
            count += 1
            jishu -= 1
        if count == 3:
            return True
 
    count, jishu = 0, 3
    i, j = x, y
    if x<n-3 and y>=3: #左对角线
        while jishu>0 and grids[x][y]==grids[++i][--j]:
            count += 1
            jishu -= 1
        if count == 3:
            return True
 
    count, jishu = 0, 3
    i, j = x, y
    if x<n-3 and y<m-3: #右对角线
        while jishu>0 and grids[x][y]==grids[++i][++j]:
            count += 1
            jishu -= 1
        if count == 3:
            return True
 
    return False
 
def siziqi(grids):
    for i in range(len(nums)):
        y_index = -1
        color =1
        if nums[i]<=0 or nums[i]>m or grids[0][nums[i]-1]!=0:
            is_over=True
            return (i+1,"error")
 
        if i%2!=0:
            color = 2
 
        for j in range(n-1,-1,-1):
            if grids[j][nums[i]-1] ==0:
                index = j
                grids[j][nums[i] - 1] = color
                break
        if index ==-1:
            is_over=True
            return (i+1,"error")
 
        if i>=6 and is_sucess(nums[i]-1,index,grids):
            if color==1:
                is_over = True
                return (i + 1, "red")
            else:
                is_over = True
                return (i + 1, "blue")
            break
    if not is_over:
        return (0,"draw")
 
m = 5
n = 5
nums = [0,1,2,2,3,3,4,4]
nums = [1 ,1 ,2 ,2 ,3 ,3, 4, 4]
grids = [[0]*m for i in range(n)]
is_over = False
print(siziqi(grids))
```

# 字符串比较

```
import sys
 
if __name__ == "__main__":
    string1 = sys.stdin.readline().strip("\n")
    string2 = sys.stdin.readline().strip("\n")
    V = int(sys.stdin.readline().strip("\n"))
    sumlist = []
    length = []
    for i in range(len(string1)):
        sum1 = abs(ord(string1[i]) - ord(string2[i]))
        if sum1 < V:
            for j in range(i + 1, len(string1)):
                sum1 = sum1 + abs(ord(string1[j]) - ord(string2[j]))
                if sum1 > V:
                    break
                else:
                    length.append(j - i + 1)
        elif sum1 == V:
            length.append(1)
        else:
            length.append(0)
    print(max(length))
```

# 导师请吃火锅

```
n, m = map(int, input().split())
d = set()
for i in range(n):
    d.add(sum(map(int, input().split())))
l = sorted(list(d))
count = 1
t = 0
for i in range(1, len(l)):
    if l[i] - l[t] >= m:
        count += 1
        t = i
print(count)
```

# 最小传输时延

```
if __name__ == "__main__":
    m, n = map(int, input().split())
    grid = []
    for i in range(m):
        grid.append(list(map(int, input().split())))
    from heapq import *
 
 
    def search(grid):
        visited = set()
        p = [(grid[0][0], 0, 0, grid[0][0])]
        visited.add((0, 0))
        heapify(p)
        while p:
            t, i, j, pre = heappop(p)
            if i == len(grid) - 1 and j == len(grid[0]) - 1:
                return t
            for i_new, j_new in [(i - 1, j - 1), (i - 1, j), (i, j - 1), (i + 1, j + 1), (i + 1, j), (i, j + 1),
                                 (i - 1, j + 1), (i + 1, j - 1)]:
                if 0 <= i_new < len(grid) and 0 <= j_new < len(grid[0]) and (i_new, j_new) not in visited:
                    visited.add((i_new, j_new))
                    if pre == grid[i_new][j_new]:
                        heappush(p, (t + grid[i_new][j_new] - 1, i_new, j_new, grid[i_new][j_new]))
                    else:
                        heappush(p, (t + grid[i_new][j_new], i_new, j_new, grid[i_new][j_new]))
 
 
    out = search(grid)
    print(out)
```

# TLV解析

```
s="0F04ABABABAB01021111030111"
length = len(s)
print(length)
index=0
i=0
res_dict ={}
res_list = []
vlaue_len = 0
while index<length:
    if i==0:
        tag = int(s[index:index+2],16)
        index += 2
        if index < length:
            res_dict[tag] = []
            res_list.append(tag)
    elif i==1:
        len1 = int(s[index:index+2],16)
        vlaue_len = len1
        index += 2
        if index<length:
            res_dict[tag].append(len1)
        else:
            del res_dict[tag]
            res_list.remove(tag)
    elif i==2:
        value_offset = index//2
        index +=vlaue_len*2
        if index <=length:
            res_dict[tag].append(value_offset)
        else:
            del res_dict[tag]
            res_list.remove(tag)
    i = i+1
    if i==3:
        i=0
 
nums = [15,17]
for i in range(2):
    if nums[i] in res_list:
        print(res_dict[nums[i]][0],res_dict[nums[i]][1])
    else:
        print(0,0)
print(res_dict)
print(res_list)
```

# 矩阵扩散

```
m, n, i, j, k, l = list(map(int, input().split(',')))
# 处理输入，转化为 二维数组
map = [[0]*n for _ in range(m)]
map[i][j] = 1
map[k][l] = 1
 
spots = [(i, j), (k, l)]
count = 0
 
def _check(x, y, dct):
    if 0 <= x < m \
            and 0 <= y < n \
            and map[x][y] == 0:
        map[x][y] = 1
        dct.append((x, y))
 
while spots:
    tmp = []
    for spot in spots:
        _check(spot[0]+1, spot[1], tmp)
        _check(spot[0]-1, spot[1], tmp)
        _check(spot[0], spot[1]+1, tmp)
        _check(spot[0], spot[1]-1, tmp)
    if tmp:
        count += 1
    spots = tmp
    tmp = []
print(count)
```

# 图像物体的边界

```
def edges(grid, row, col):
    def dfs(grid, i, j):
        grid[i][j] = 6
        for x in range(i - 3, i + 4):
            for y in range(j - 3, j + 4):
                if x < 0 or y < 0 or x >= row or y >= col:
                    continue
 
                if grid[x][y] == 5:
                    dfs(grid, x, y)
 
    res = 0
    for i in range(row):
        for j in range(col):
            if grid[i][j] == 5:
                res += 1
                dfs(grid, i, j)
 
    return res
 
 
if __name__ == '__main__':
    row, col = 20, 20
     grid = [[1, 1, 1, 1, 1, 1,],
             [1, 5, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 5,] ]
 
 
    res = edges(grid, row, col)
    print(res)
```

# 找单词

```
n = int(input())
map = [input().split(',') for _ in range(n)]
target = input()
 
def next_step(x, y, route):
    """
    :param x:当前位置的下标x
    :param y:当前位置的下标y
    :param route:已走当前路径
    :return:
    """
    # 当前点是否已经越界
    if x > n-1 or x < 0 or y > n-1 or y < 0:
        return False
    # 当前点是否已经走过
    if (x, y) in route:
        return False
    # 当前点是否满足路径要求
    if map[x][y] != target[len(route)]:
        return False
    route.append((x, y))
    # 是否已经到达终点
    if len(route) == len(target):
        return route
    # 继续下一步
    return (next_step(x + 1, y, route.copy())
            or next_step(x, y + 1, route.copy())
            or next_step(x - 1, y, route.copy())
            or next_step(x, y - 1, route.copy()))
 
# 记录起始点
starts = []
for x in range(n):
    for y in range(n):
        if map[x][y] == target[0]:
            starts.append((x, y))
 
if not starts:
    print("N")
else:
    for spot in starts:
        ret = next_step(*spot, route=[])
        if ret:
            print(ret)
            break
    else:
        print("N")
```

#  跳格子

```
while 1:
    try:
        n = int(input())
 
        nums = []
        for _ in range(n):
            x = input().split()
            if x and len(x) == 2:
                nums.append(tuple(map(int, x)))
            else:
                break
 
        nums = sorted(nums, key=lambda x: x[0])
 
        state = [1] * n
        for start, end in nums:
            state[end] = 0
 
        if max(state) == 0:
            print("no")
            continue
 
        dp = [0]
 
 
        def dfs(s, link):
            if len(link) == len(nums) and sorted(link, key=lambda x: x[0]) == nums:
                dp.append(1)
                return
 
            ends = []
            for start_, end_ in nums:
                if s == start_:
                    link.append((start_, end_))
                    ends.append(end_)
 
            for end_ in ends:
                dfs(end_, link)
 
 
        for i in range(n):
            if state[i] == 1:
                dfs(i, [])
 
        if max(dp):
            print("yes")
        else:
            print("no")
 
    except Exception as e:
        break
```

# 城市聚集度

```
class RelationShip:
    def __init__(self, num):
        self.roots = list(range(num+1))
 
    def get_root_find(self, node):
        while self.roots[node] != node:
            node = self.roots[node]
        return node
 
    def node_connected(self, x, y):
        find_x = self.get_root_find(x)
        find_y = self.get_root_find(y)
        if find_x != find_y:
            self.roots[find_x] = find_y
        return
 
    def max_citys(self, node, num, ls):
        self.__init__(num)
        temp_ls = []
        for i in range(len(ls)):
            if node not in ls[i]:
                temp_ls.append(ls[i])
        for city in temp_ls:
            self.node_connected(city[0], city[1])
        dic = {}
        for k in range(1, num + 1):
            dic[self.get_root_find(k)] = dic.get(self.get_root_find(k), 0) + 1
        return node, max(dic.values())
 
 
num = int(input())
dsu = RelationShip(num)
ls = []
for i in range(num - 1):
    ls.append([int(j) for j in input().split() if int(j) <= num])
reslut = []
for i in range(1, num + 1):
    reslut.append(dsu.max_citys(i, num, ls))
min_num = min([s[1] for s in reslut])
for k in reslut:
    if k[1] == min_num:
        print(k[0], end=' ')
```

# 补种未成活胡杨 

```
while True:
    try:
        n = int(input())
        m = int(input())
        death = list(map(int, input().split()))
        k = int(input())
        s = '1' * n  # 字符串表示所有树
        for i in death:
            s = s[0:i - 1] + '0' + s[i:]  # 死掉的树用0表示
        tmp = list(map(str, s.split('0')))  # 用0分隔字符串，存到列表，每两项代表中间有一棵死掉的树
        res = 0  # 保存最终结果
        for i in range(len(tmp) - k):  # 最长肯定是项越多越好，补一颗可以连两项，以此类推
            l = 0  # 第i项开始，加后面k项的长度
            for j in range(i, i + k + 1):
                l += len(tmp[j])
            res = max(res, l + k)  # 加上补种的k棵树
        print(res)
    except:
        break
        
        
        
 while 1:
    try:
        n = int(input())
        m = int(input())
        nums = list(map(int, input().split()))
        k = int(input())
 
        nums = [0 if i + 1 in nums else 1 for i in range(n)]
 
        max_ = 0
        i = 0
        j = min(k, n)
        while j < len(nums):
            count = nums[i:j].count(0)
            if count < k:
                j += 1
            elif count == k:
                max_ = max([j - i, max_])
                j += 1
            else:
                i += 1
        else:
            max_ = max([j - i, max_])
 
        print(max_)
    except Exception as e:
        break
```

# 水仙花数

```
# 1.提取字符及其ASCII码
s = input()
ls = list(s)
nums = []
for i in s:
    nums.append(ord(i))
# 2.列出所有三位数的水仙花数
narcissus_nums = []
for i in range(100, 1000):
    i = str(i)
    if int(i[0]) ** 3 + int(i[1]) ** 3 + int(i[2]) ** 3 == int(i):
        narcissus_nums.append(int(i))
 
 
# 3.回溯
def backtrack(ls, nums, stk):
    if sum(nums) in narcissus_nums:
        stk.append("".join(ls))
        res.append(stk[:])
        stk.pop()
        return
    for i in range(1, len(nums)):
        if sum(nums[:i]) in narcissus_nums:
            stk.append("".join(ls[:i]))
            backtrack(ls[i:], nums[i:], stk)
            stk.pop()
 
 
res = []  # 只有满足条件的分组才会存入res
backtrack(ls, nums, [])
# 4.输出
if len(res) == 0:  # 分割不成功，res为空
    print(0)
elif len(res) == 1:  # 分割唯一，输出子串数
    print(len(res[0]))
else:  # 分割不唯一，事实上 len(res) > 1
    print(-1)
```

# 敏感字段加密

```
if __name__ == "__main__":
    while 1:
        try:
            k = int(input())
 
            nums = input()
 
            dp = []
 
            temp = ""
            for c in nums:
                if c == "_":
                    if '"' not in temp and temp:
                        dp.append(temp)
                        temp = ""
                    elif '"' in temp:
                        temp += c
                elif c == '"':
                    if temp and '"' in temp:
                        temp += c
                        dp.append(temp)
                        temp = ""
                    elif temp and '"' not in temp:
                        dp.append(temp)
                        temp = c
                    elif not temp:
                        temp = c
                else:
                    temp += c
            if temp:
                dp.append(temp)
 
            if k < len(dp):
                dp[k] = "*" * 6
                print("_".join(dp))
            else:
                print("ERROR")
        except Exception as e:
            break
```

# 解密犯罪时间

```
def decrypt_crime_time(s):
    nums_list = [int(i) for i in s if i != ":"]
    H, M = [int(i) for i in s.split(":")]
    # ['11', '10', '15', '13', '01', '00', '05', '03', '51', '50', '55', '53', '31', '30', '35', '33']
    time = []
    for i in nums_list:
        for j in nums_list:
            time.append(str(i) + str(j))
    print(time)
    time1 = []
    time2 = []
   
    for i in range(len(time)):
        if M < int(time[i]) <= 59: 
            time1.append(time[i])
 
    if len(time1) > 0:
        time1.sort()
        if H < 10:  
            return '0' + str(H) + ":" + time1[0]
        else:
            return str(H) + ":" + time1[0]
    else:
        for i in range(len(time)):
            if H < int(time[i]) <= 23:
                time2.append(time[i])
        if len(time2) > 0:
            time2.sort()
            return str(time2[0]) + ":" + str(min(time))
        else:
            return str(min(time)) + ":" + str(min(time))
 
 
if __name__ == "__main__":
    s = "23:33"
    print(decrypt_crime_time(s))
```

# 最少交换次数

```
def func():
    nums = list(map(int, input().split()))
    k = int(input())
    num = 0
    for i in nums:
        if i < k:
            num += 1
    res = num
    for i in range(len(nums) - num + 1):
        window = nums[i:i + num]
        win = 0
        for j in window:
            if j < k:
                win += 1
        res = min(res, num - win)
    print(res)
 
 
if __name__ == "__main__":
    func()
```

#  ipv4地址转换成整数

```
while 1:
    try:
        nums = list(map(int, input().split("#")))
        if len(nums) != 4:
            print("invalid IP")
        else:
            dp = ""
            for i in range(4):
                if not ((i == 0 and 1 <= nums[i] <= 128) or (i > 0 and 0 <= nums[i] <= 255)):
                    print("invalid IP")
                    break
                dp += bin(nums[i])[2:].zfill(8)
            else:
                print(int(dp, 2))
    except Exception as e:
        break+
```

#  矩形相交的面积

```
while 1:
    try:
        xs = []
        ys = []
 
        coms_d = []
        coms_e = []
        for _ in range(int(input())):
            l = input().split()
            x1, y1, x2, y2 = list(map(int, l[1:]))
            xs.append(x1)
            xs.append(x2)
            ys.append(y1)
            ys.append(y2)
            if l[0] == 'd':
                coms_d.append((x1, y1, x2, y2))
            else:
                coms_e.append((x1, y1, x2, y2))
 
        min_x, max_x = min(xs), max(xs)
        min_y, max_y = min(ys), max(ys)
 
        # 坐标轴偏移量
        x = 0 - min_x
        y = 0 - min_y
        dp = [[0] * abs(max_y-min_y) for _ in range(abs(max_x-min_x))]
 
        for x1, y1, x2, y2 in coms_d:
            # 需要 转成 二维数组的下标
            for i in range(min((x2, x1)) + x, max((x2, x1)) + x):
                for j in range(min((y2, y1)) + y, max((y2, y1)) + y):
                    dp[i][j] = 1
        for x1, y1, x2, y2 in coms_e:
            for i in range(min((x2, x1)) + x, max((x2, x1)) + x):
                for j in range(min((y2, y1)) + y, max((y2, y1)) + y):
                    dp[i][j] = 0
 
        print(sum([sum(i) for i in dp]))
    except Exception as e:
        break
```

# 正方形数量

```
# Python
 
while True:
    try:
        N = int(input())
        pos_list = []
        for i in range(N):
            pos_list.append(tuple(map(int, input().split())))
        count = 0
        if N < 4:
            print(count)
        else:
            for i in range(len(pos_list) - 1):
                for j in range(i + 1, len(pos_list)):
                    x1 = pos_list[i][0]
                    y1 = pos_list[i][1]
                    x2 = pos_list[j][0]
                    y2 = pos_list[j][1]
                    x3_1 = x1 - (y1 - y2)
                    y3_1 = y1 + (x1 - x2)
                    x4_1 = x2 - (y1 - y2)
                    y4_1 = y2 + (x1 - x2)
                    if (x3_1, y3_1) in pos_list and (x4_1, y4_1) in pos_list:
                        count += 1
                    x3_2 = x1 + (y1 - y2)
                    y3_2 = y1 - (x1 - x2)
                    x4_2 = x2 + (y1 - y2)
                    y4_2 = y2 - (x1 - x2)
                    if (x3_2, y3_2) in pos_list and (x4_2, y4_2) in pos_list:
                        count += 1
            print(int(count/4))
 
    except:
        break
```

# We Are A Team

```
class Node:
    def __init__(self, n):
        self.parent = list(range(n + 1))
 
    def get_root(self, i):  
        while i != self.parent[i]:
            i = self.parent[i]
        return i
 
 
def one_team(self, i, j):  
    return self.get_root(i) == self.get_root(j)
 
 
def union(self, i, j):  
    i_root = self.get_root(i)
    j_root = self.get_root(j)
    self.parent[i_root] = j_root
 
 
while True:
    try:
        m, n = map(int, input().split())
        team = Node(m)
        if m < 1 or m > 100000 or n < 1 or n > 100000:
            print("NULL")
            break
        for i in range(n):
            x, y, c = map(int, input().split())
            # uinion a, b in one team
            if x < 1 or x > m or y < 1 or y > m:
                print("da pian zi")
                continue
            if c == 0:
                team.union(x, y)
            elif c == 1:
                ret = team.one_team(x, y)
                if ret == True:
                    print("We are a team")
                else:
                    print("We are not a team")
            else:
                print("da pian zi")
    except:
        break
```

# 数组连续和 

```
total = 10000
n = 10 
 
nums= [1,2,3,4,5,6,7,8,9,10]
count = 0
res = 0
for i in range(n):
    count = nums[i]
    if count >total:
        res+=n-i
        break
    for j in range(i+1,n):
        count+=nums[j]
        if count>=total:
            res+=n-j
            break
print(res)
```

# 翻牌求最大分

```
n= "1,-5,-6,4,7,2,-2"
if  __name__ == '__main__':
    n = list(map(int,n.split(",")))
    if sum(n[:3])<0:
        num=0
    else:
        num=sum(n[:3])
    for i in range(3,len(n)):
        tmp=num+n[i]
        if tmp>num:
            num=tmp
    print(num)
```

# 冠亚军排名

```
import bisect
 
 
def func():
    n = int(input().strip())
    alist = []
    for i in range(n):
        name, gold, silver, bronze = input().strip().split()  # 获取每一行的数据
        gold, silver, bronze = -int(gold), -int(silver), -int(bronze)  # 将奖牌数变为负数并与排序
        atup = tuple((gold, silver, bronze, name))  # 将需要排序的奖牌数和国家名称加入到元组中
        bisect.insort(alist, atup)  # 调用bisect方法对每个加入的元素进行排序
    for tmp in alist:
        print(tmp[3])
 
 
if __name__ == "__main__":
    func()
```

#  数大雁

```
+class Solution:
    def minNumberOfQuacks(self, quackOfQuacks: str) -> int:
        dic = {'q': 0, 'u': 0, 'a': 0, 'c': 0, 'k': 0}
        for i in quackOfQuacks:
            dic[i] += 1
        if not dic['q'] == dic['u'] == dic['a'] == dic['c'] == dic['k']:
            return -1
 
        m = 0
        dic = {'q': 0, 'u': 0, 'a': 0, 'c': 0, 'k': 0}
        for i in range(len(quackOfQuacks)):
            dic[quackOfQuacks[i]] += 1
            if not (dic['q'] >= dic['u'] >= dic['a'] >= dic['c'] >= dic['k']):
                return -1
            if all(val > 0 for val in list(dic.values())):
                for c in 'quack':
                    dic[c] -= 1
            else:
                m = max(m, dic['q'])
        return m
```

+++++++++++++++++++++++++++++

# VLAN资源池

```
while 1:
    try:
        nums = input().split(",")
        vid = int(input())
 
        vlans = []
        # 还原 vid
        # 比如从 1-4 还原为 1,2,3,4
        for p in nums:
            val = p.split("-")
            if len(val) == 1:
                s = e = val[0]
            else:
                s, e = val
            vlans += list(range(int(s), int(e) + 1))
 
        # 移除申请的vlan
        if vid in vlans:
            vlans.remove(vid)
 
        vlans = sorted(vlans)
 
        # 重新生成 缩略格式
        # 1,2,3,4 转 1-4
        ret = []
        t = [vlans[0]]
        for vid in vlans[1:]:
            if t[-1] + 1 == vid:
                if len(t) < 2:
                    t.append(vid)
                else:
                    t[-1] = vid
            else:
                ret.append("-".join(map(str, t)))
                t = [vid]
        if t:
            ret.append("-".join(map(str, t)))
 
        print(",".join(ret))
    except Exception as e:
        break
```

# 篮球比赛

```
def basketball(s):
    from itertools import combinations
    a1 = [int(x) for x in str(s).split(" ")]
    a2 = list(combinations(a1, len(a1) // 2)) 
    min_diff = abs(sum(a1) - 2 * sum(a2[0]))
    for arr in a2:
        if abs(sum(a1) - 2 * sum(arr)) < min_diff:
            min_diff = abs(sum(a1) - 2 * sum(arr))
    return min_diff
 
 
print(basketball("10 9 8 7 6 5 4 3 2 1"))
```

#  数字反转打印

```
def firstNum(n):
    if n==1:
        return 1
    return firstNum(n-1) + n-1 #根据规律推出第n行的头为n-1的头加上n-1
 
# n = int(input().strip())
n=6
lists = [] #总集合
 
for i in range(1,n+1):
    list = []
    fn = firstNum(i)
    new_nums = [j for j in range(fn,fn+i)]
    temp = "    "*(n-i)
    if i %2 ==0:
        new_nums.reverse()
    for num in new_nums:
        temp += str(num) + "*"*(4-len(str(num))) + "    "
    print(temp)
```

# 判断一组不等式是否满足约束并输出最大差

```
def max_difference(str):
    l = str.split(";")
    a1 = [x.split(',') for x in l[-3:]]
    a2 = l[:-3]
    b = []
    for i in range(len(a2)):
        c = a2[i].split(',')
        s = 0
        for j in range(len(c)):
            s += float(c[j]) * float(a1[0][j])
        b.append([s, a1[-1][i], float(a1[-2][i])])
    return all([eval('%s %s %s' % (x[0], x[1], x[2])) for x in b]), int(max([x[0] - x[-1] for x in b]))
 
 
if __name__ == "__main__":
    print(max_difference("2.3,3,5.6,7,6;11,3,8.6,25,1;0.3,9,5.3,66,7.8;1,3,2,7,5;340,670,80.6;<=,<=,<="))
```

# 求字符串中所有整数的最小和

```
s = input()
res = 0
flag = False  
num = ""  
for c in s:
    if c.isdigit():
        if flag:
            num += c
        else:
            res += int(c)
    elif c == '-':
        if flag and len(num) > 0:
            res -= int(num)
            num = ""
        flag = True
    else:
        if flag and len(num) > 0:
            res -= int(num)
            num = ""
        flag = False
if flag and len(num) > 0:
    res -= int(num)
print(res)
```

# 最长子字符串的长度

```
str= "bcbcbc"
nums = str.count("o")
if nums %2 == 0:
    print(len(str))
else:
    print(len(str)-1)
```

# 表达式括号匹配

```
str= ")(1+(2+3)*(3+(8+0))+1-2)"
stack = []
num = 0
for i in str:
    if i =="(":
        stack.append(i)
    elif i ==")" :
        if stack==[]:
            num = -1
            break
        else:
            temp = stack.pop(-1)
            if temp !="(":
                num = -1
                break
            elif temp == "(":
                num+=1
print(num)
```

#  括号匹配

```
SYMBOLS = {'}':'{',']':'[',')':'(','>':'<'}
SYMBOLS_L,SYMBOLS_R = SYMBOLS.values(),SYMBOLS.keys()
def check(s):
    arr = []
    for c in s:
        if c in SYMBOLS_L:
            #左括号入栈
            arr.append(c)
        elif c in SYMBOLS_R:
            # 右符号要么出栈，要么匹配失败
            if arr and arr[-1] == SYMBOLS[c]:
                arr.pop()
            else:
                return False
        return True
print(check("(1+2)/(0.5+1)"))
```

#  最大括号深度

```
while 1:
    try:
        nums = input()
        max_ = 0
        stack = []
        for c in nums:
            if c in "{[(":
                stack.append(c)
            else:
                if not stack:
                    print(0)
                    break
                max_ = max(max_, len(stack))
                cr = stack.pop()
                if f"{cr}{c}" not in ["{}", "[]", "()"]:
                    print(0)
                    break
        else:
            print(max_)
    except Exception as e:
        break
```

#  消消乐游戏

```
+if __name__ == "__main__":
    while 1:
        try:
            nums = input()
            i = 0
            while i < len(nums):
                if nums[i] * 2 in nums:
                    nums = nums.replace(nums[i] * 2, "")
                    i = max(0, i-1)
                else:
                    i += 1
            print(len(nums))
        except Exception as e:
            break
```

# 字符串分割

```
# k = int(input().strip())
# str = input().strip()
k=3
str = "12abc-abCABc-4aB@"
str_list = str.split("-")
res = [str_list[0]]
new_str = "".join(str_list[1:])
 
for i in range(0,len(new_str),k):
    temp = new_str[i:i+k]
    upper_num = 0
    lower_num = 0
    for j in temp:
        if j.isupper():
            upper_num+=1
        elif j.islower():
            lower_num +=1
    if upper_num <lower_num:
        temp = temp.lower()
    elif upper_num >lower_num:
        temp = temp.upper()
    res.append(temp)
print("-".join(res))
```

# 求满足条件的最长子串的长度

```
import re
 
s = input()
maxLen = -1
pat1 = '[a-zA-Z]'
pat2 = '[0-9]'
for i in range(len(s) - 1):
    for j in range(i + 1, len(s)):
        arr1 = re.findall(pat1, s[i:j + 1])  
        arr2 = re.findall(pat2, s[i:j + 1])  
        if len(arr1) >= 2:  
            break
        elif len(arr1) == 1 and len(arr2) > 0:  
            maxLen = max(maxLen, len(s[i:j + 1]))
print(maxLen)
```

# 一种字符串压缩表示的解压

```
def getUnZipStr(zipStr):
    if not zipStr:
        return None
 
    Nums = ""
    NewStr = ""
    for x in zipStr:
        if x.islower():  # 小写字母，压缩后只能是数字和小写字母
            if Nums and Nums != "":
                for i in range(int(Nums)):
                    NewStr += x
                Nums = ""  # 对应nums的x字符已经拼接完成，要置空，也许后面还要使用
            else:
                NewStr += x
        elif x.isdigit():  # 小写字母，压缩后只能是数字和小写字母
            if int(x) <= 2 and Nums == "":  # 只有超过2个相同字母才会压缩，否则报异常
                return None
            Nums = Nums + x  # 有可能第1、2、3...都是数字，需要统计总的数字，先利用字符串拼接，用的时候转换成数字
        else:  # 大写字符，特殊字符等都输出异常
            return None
    return NewStr
 
 
if __name__ == "__main__":
    zipStr = "4dff"
    result = getUnZipStr(zipStr)
    if result:
        print(result)
    else:
        print("!error")
```

# 小朋友排队-2

```
H,N = map(int,input().split())
list_H = list(map(int,sorted(input().split())))
diff = []
for i in range(len(list_H)):
    diff.append((list_H[i],abs(H-list_H[i])))
diff = sorted(diff,key=lambda x:(x[1],x[0]))
res = []
for j,k in diff:
    res.append(str(j))
print(" ".join(res))
```

# 数组组成的最小数字

```
# -*- coding:utf-8 -*-
class Solution:
     def PrintMinNumber(self, numbers):
         # write code here
         lamb = lambda n1,n2 : int(str(n1)+str(n2))-int(str(n2)+str(n1))
         numbers=sorted(numbers,lamb)
         return ''.join([str(i) for i in numbers])
 
if __name__ == "__main__":
    nums = [0, 2, 4, 1, 6, 44]
    nums.sorted()
    print(nums)
    length = len(nums)
    new_nums = []
    if length < 3:
        new_nums = nums
    else:
        new_nums = nums[0:3]
    Solution().PrintMinNumber(nums[0:3])
```

# 堆栈中的剩余数字

```
if __name__ == "__main__":
    nums = list(map(int, input().split()))
    res = []
    while len(nums) > 0:
        num = nums.pop(0)
        while num > 0:
            l = len(res)
            if l == 0:  # 如果res列表为空，直接入栈
                res.append(num)
                num = 0  # num入栈后清零，退出循环
            else:
                curSum = 0
                flag = True  # 是否找到满足条件的元素
                for i in range(l - 1, -1, -1):
                    curSum += res[i]
                    if curSum == num:  # 找到满足条件的元素
                        res = res[:i]  # 下标i到末尾的元素全部出栈
                        num = num * 2  # 需要入栈的新元素
                        flag = False  # 标志位改变
                        break
                if flag:  # 如果没找到满足条件的元素
                    res.append(num)
                    num = 0  # num入栈后清零，退出循环
    print(' '.join(map(str, reversed(res))))  # 逆序输出
```

# 矩阵最大值

```
n = int(input())
nums = []
maxSum = 0
for _ in range(n):
    row = input().split(',')
    nums.append(row)
for row in nums:
    curMax = int(''.join(row), 2)
    for _ in range(n - 1):
        row = list(row[-1]) + row[:-1]
        curMax = max(curMax, int(''.join(row), 2))
    maxSum += curMax
print(maxSum)
```

#  免单统计

```
while 1:
    try:
        size = int(input())
        order_time = [input() for _ in range(size)]
 
        dp = {}
 
        for ct in order_time:
            _ct, mint = ct.split('.')
            if _ct in dp:
                if dp[_ct]["val"] == mint:
                    dp[_ct]["count"] += 1
                elif dp[_ct]["val"] > mint:
                    # 最早时间刷新，同时刷新计数
                    dp[_ct]["val"] = mint
                    dp[_ct]["count"] = 1
            else:
                # 首次出现的时间点，计数为1
                dp[_ct] = {
                    "val": mint,
                    "count": 1
                }
 
        total = sum(v["count"] for v in dp.values())
        print(total)
    except Exception as e:
        break
```

# 最大矩阵和

```
n,m = map(int,input().strip().split(" "))
#test = ["-3,5,-1,5", "2,4,-2,4", "-1,3,-1,3"]
 
ints = []
for i in range(n):
    hang = list(map(int,input().strip().split(" ")))
    ints.append(hang)
print(ints)
 
max_ = 0
 
for start_row in range(n):
    for start_col in range(m):
        for end_row in range(start_row,n):
            jisuan = 0
            for end_col in range(start_col,m):
                row_index = end_row
                while row_index >= start_row:
                    jisuan +=ints[row_index][end_col]
                    row_index-=1
                max_ = max(max_,jisuan)
print(max_)
```

# 单词接龙

```
def func():
    while True:
        try:
            index = int(input())
            n = int(input())
            data = []
            for _ in range(n):
                data.append(input())
            res = data[index]
            data.remove(data[index])
            for i in range(n - 1):
                target = res[-1]
                aa1 = []
                aa2 = []
                for j in data:
                    if j.startswith(target):
                        aa1.append(j)
                        aa2.append(len(j))
                if aa1:
                    max_len = max(aa2)
                    if aa2.count(max_len) == 1:
                        res += aa1[aa2.index(max_len)]
                        data.remove(aa1[aa2.index(max_len)])
                    else:
                        aa3 = list(filter(lambda x: len(x) == max_len, aa1))
                        aa3.sort()
                        res += aa3[0]
                        data.remove(aa3[0])
                else:
                    break
            print(res)
        except:
            break
 
 
if __name__ == "__main__":
    func()
```

# 整型数组按个位值排序

```
if __name__ == "__main__":
    a_list = input().split(",")
 
    def takeLast(elem):
        return elem[-1]
 
    a_list.sort(key=takeLast)
    print(",".join(a_list))
```

# 用连续自然数之和来表达整数

```
import functools
 
n = int(input())
res = []
for i in range(1, n + 1):
    curSum = i
    tmp = [str(i)]
    while True:
        if curSum + i + 1 <= n:
            tmp.append(str(i + 1))
            curSum += i + 1
            i = i + 1
        else:
            break
    if curSum == n:
        res.append(tmp)
 
 
def compare(arr1: list, arr2: list):
    return len(arr1) - len(arr2)
 
 
res = sorted(res, key=functools.cmp_to_key(compare))
for arr in res:
    print(str(n) + "=" + '+'.join(arr))
print("Result:" + str(len(res)))
```

# 找终点 

```
nums = list(map(int, input().split()))
length = len(nums)
res = []
for i in range(1, length // 2):
    step = 1
    index = i
    while index < length - 1:
        index += nums[index]
        step += 1
    if index == length - 1:
        res.append(step)
if len(res) > 0:
    res.sort()
    print(res[0])
else:
    print(-1)
```

# 找出符合要求的字符串子串

```
str1 = input().strip()
str2 = input().strip()
res = ""
for i in range(len(str1)):
    if str1[i] in str2:
        res+=str1[i]
res.sorted()
print(res)
```

# 执行时长

```
n = int(input())
m = int(input())
nums = list(map(int, input().split()))
res = 0
rem = 0
for i in nums:
    res += 1
    if rem + i > n:
        rem = rem + i - n
    else:
        rem = 0
while rem > 0:
    res += 1
    rem -= n
print(res)

```

# 运维日志排序

```
def get_sort(temp_list):
    return list(map(int, temp_list))
 
 
num = int(input())
s_list = []
for i in range(num):
    s_list.append(input().replace('.', ':').split(':'))
 
length = len(s_list)
s_list.sort(key=get_sort)
 
for i in range(length):
    temp = ':'.join(s_list[i][0:3])
    print(temp + "." + s_list[i][-1])
```

# 用户调度问题

```
n = int(input())
res = 0
preIndex = -1
for i in range(n):
    times = list(map(int, input().split()))
    minTime = 0
    if preIndex < 0:
        minTime = min(times)
    else:
        tmp = []
        for j, v in enumerate(times):
            if j == preIndex:
                continue
            tmp.append(v)
        minTime = min(tmp)
    preIndex = times.index(minTime)
    res += minTime
print(res)
```

# 字符串加密

```
n = int(input())
s = input()
res = ""
a = [0] * 50
a[0] = 1
a[1] = 2
a[2] = 4
for i in range(3, len(s)):
    a[i] = a[i - 1] + a[i - 2] + a[i - 3]
for i in range(len(s)):
    if ord(s[i]) + a[i] <= ord('z'):
        res += chr(ord(s[i]) + a[i])
    else:
        res += chr(ord(s[i]) + a[i] % 26 - 26)
print(res)
```

#  5键键盘

```
def FiveKeyBoard(s):
    screen = ''
    clip = ''
    selected = False
    for i in s:
        if i == '1' and not selected:  # a
            screen += 'a'
        elif i == '1' and selected:  # a
            screen = 'a'
            selected = False
        elif i == '2' and selected and screen:  
            clip = screen
        elif i == '3' and selected and screen:  
            clip = screen
            screen = ''
            selected = False
        elif i == '4' and selected:  
            screen = clip
            selected = False
        elif i == '4' and not selected:  
            screen += clip
        elif i == '5' and screen: 
            selected = True
    return len(screen)
 
 
if __name__ == "__main__":
    line = str(input().strip())
    print(FiveKeyBoard(line))
```

# 查找众数及中位数

```
import collections
 
nums = list(map(int, input().split()))
dic = collections.defaultdict(list)
for i in set(nums):
    t = nums.count(i)
    # 以出现次数为key，相同出现次数的数字组成的列表为value
    dic[t].append(i)
maxT = max(dic.keys())  # 找到最大的出现次数
numsT = dic[maxT]  # 取出最大出现次数的数字列表
# print(numsT)
lenT = len(numsT)
if lenT % 2 != 0:
    # 如果列表长度为奇数，中间位数的数字即为中位数
    print(numsT[lenT // 2])
else:
    # 如果长度为偶数，中位数为中间两个数字的平均值
    print((numsT[lenT // 2] + numsT[lenT // 2 - 1]) // 2)
    
```

#  最大N个数与最小N个数的和

```
m = int(input())
nums = list(map(int, input().split()))
n = int(input())
nums = sorted(list(set(nums)))
res = set(nums[:n] + nums[-n:])
if len(res) != n * 2:
    print(-1)
else:
    print(sum(res))
```

#  报数游戏

```
m = int(input())
if m <= 1 or m >= 100:
    print("ERROR!")
else:
    a = []
    for i in range(100):
        a.append(i + 1)  
    index = count = 0
    while len(a) >= m:  
        count += 1
        if count == m:  
            a.pop(index)  
            count = 0  
            if index > len(a) - 1:  
                index = 0  
        else:
            if index == len(a) - 1:
                index = 0
            else:
                index += 1
    print(','.join(map(str, a)))
```

# 英文输入法

```
import re
import collections
 
words = re.split(r' |\,|\'|\.', input())
pre = input()
dic = collections.defaultdict(list)
for word in words:
    if word == '':
        continue
    c = word[0]
    if word not in dic[c]:
        dic[c].append(word)
if pre in dic.keys():
    print(sorted(dic[pre]))
else:
    print(pre)
```

# 按索引范围翻转文章片段

```
s = input().split()
sta = int(input())
end = int(input())
if len(s[sta:end + 1]) > 1:
    res = s[:sta] + s[sta:end + 1][::-1] + s[end + 1:]
    print(' '.join(res))
else:
    print("EMPTY")
```

# 高矮个子排队

```
while 1:
    try:
 
        s = input()
 
        l = list(map(int, s.split(" ")))
        print(l)
 
        ll = l.copy()
        ll.sort(reverse=True)
        print(ll)
        if len(ll) % 2 == 0:
            e = int(len(ll) / 2)
        else:
            e = int(len(ll) / 2) + 1
        print(e)
 
        for i in range(0, len(l), 2):
            if l[i] not in ll[0:e]:
                for j in range(1, len(l), 2):
                    if l[j] in ll[0:e]:
                        tmp = l[i]
                        l[i] = l[j]
                        l[j] = tmp
                        break
        print(" ".join(map(str, l)))
 
        break
 
    except Exception as e:
        print("[]")
        break
```

# 靠谱的车

```
# n = int(input())
res = n
tmp = t = 0
i = 1
while n > 0:
    if n % 10 > 4:
        tmp += (n % 10 - 1) * t + i
    else:
        tmp += (n % 10) * t
    t = t * 9 + i
    i *= 10
    n = n // 10
print(res - tmp)
```

# 工号不够用了怎么办

```
while 1:
    try:
        max_, y = list(map(int, input().split()))
 
        z = 26 ** y
        for i in range(1, 9 - y):
            if z * (10 ** i) >= max_:
                print(i)
                break
 
    except Exception as e:
        break
```

# 分班问题

```
try:
    s = input().split()
    res = [[], []]
    preFlag = 0  
    for i, child in enumerate(s):
        index, isSame = child.split('/')
        if i == 0:
            res[0].append(index)
        else:
            if isSame == 'N':
                preFlag = int(not preFlag)
            res[preFlag].append(index)
    for i in range(2):
        print(' '.join(sorted(res[i])))
except:
    print("ERROR")
```

# 最大花费金额 

```
from itertools import combinations
 
num_list = input().split(',')
money = int(input())
num_list = [int(x) for x in num_list]
print(num_list)
kind_list = list(combinations(num_list, 3))
kind_list = [list(x) for x in kind_list]
new_list = []
for x in kind_list:
 
    temp_sum = x[0] + x[1] + x[2]
    if temp_sum <= 78:
        cs = 78 - temp_sum
        x.append(cs)
        new_list.append(x)
if len(new_list) == 0:
    print('-1')
else:
    a = sorted(new_list, key=lambda x: x[3])
    print(a[0][0] + a[0][1] + a[0][2])
```

# 最长连续子序列

```
nums = list(map(int, input().split(',')))
reqSum = int(input())
maxLen = -1
for i in range(len(nums) - 1):
    curLen = -1
    curSum = nums[i]
    if nums[i] == reqSum:
        curLen = 1
        continue
    elif nums[i] > reqSum:
        continue
    for j in range(i + 1, len(nums)):
        if curSum + nums[j] == reqSum:
            curLen = j - i + 1
        elif curSum + nums[j] < reqSum:
            curSum += nums[j]
        else:
            break
    maxLen = max(maxLen, curLen)
print(maxLen)
```

# 滑动窗口最大值

```
def find_max_window(nums: int, array: list, window_size: int):
 
    if window_size > nums:
        raise ValueError("window size must be less than nums")
    if window_size == nums:
        return sum(array)
    left_point = 0
    right_point = window_size
    max_num = 0
    while right_point <= nums:
        max_num = max(max_num, sum(array[left_point: right_point]))
        left_point += 1
        right_point += 1
    return max_num
```

# 字符统计及重排

```
import collections
 
while 1:
    try:
        nums = input()
        # 统计字符出现的次数，返回 dict
        nums = collections.Counter(nums)
 
 
        # 定义排序规则
        def sort(x):
            # ord("A") 65
            # ord("a") 97
            # 需要减一个值来满足 排序要求
            if "A" <= x[0] <= "Z":
                return x[1], -ord(x[0]) - 100
            return x[1], -ord(x[0])
 
 
        nums = sorted(nums.items(), key=sort, reverse=True)
 
        # 格式化输出
        ret = []
        for k, v in nums:
            ret.append(f"{k}:{v}")
        print(";".join(ret))
 
    except Exception as e:
        break
```

# TLV解析

```
Tag = int(input())  # 待解码信元的tag
Lists = input().split()  # 待解码的16进制码流
 
Tag = 30
Lists = "32 01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC".split()  # tag=0,4,9
q = 0
# print(Lists)
while q < len(Lists):
    NewTag = int(Lists[q])  # 新的信元tag值
    NewLenght = int(Lists[q + 2] + Lists[q + 1], 16)  # 小段序，逆序存储(字符串是可以直接通过+进行连接的)；大端序，正序存储，先计算Lenght长度
    NewValue = Lists[q + 3:q + 3 + NewLenght]  # 统计对应信元的value，因为小短序已经到q+2了，所有value要从q+3开始，对应长度再加NewLenght
    # print(q, NewTag, NewLenght, NewValue)
    if NewTag == Tag:
        print(" ".join(NewValue))
        break
    else:
        q = q + 3 + NewLenght  # 如果没有找到，则跳得写一个信元tag的位置；因为tag长度为1，Lenght长度为2，所以要+3，后面还有对应Lenght长度的Value
```

# 数组去重和排序

```
class Solution():
    def remove_duplicates_sort(self, arry):
        dict = {}
        for i in arry:
            dict[i] = arry.count(i)
        print(dict)
        dict = sorted(dict.items(), key=lambda x: x[1], reverse=True)
        print(dict)
        arry1 = []
        for i in dict:
            arry1.append(i[0])
        print(arry1)
        return arry1
 
 
if __name__ == "__main__":
    Solution().remove_duplicates_sort([1, 3, 3, 3, 2, 4, 4, 5])
```

# 字符串筛选排序

```
s = input()
k = int(input())
sortList = sorted(s)
maxASCII = ''
if k > len(sortList):
    maxASCII = sortList[-1]
else:
    maxASCII = sortList[k - 1]
print(s.index(maxASCII))
```

# 连续字母长度

```
if __name__ == "__main__":
    Strs = "ABC"
    k = 2
    index = 0  
    HashMap = dict()
    for i in range(len(Strs)):
        if Strs[i] != Strs[index]: 
            if HashMap.get(Strs[index]) and HashMap.get(Strs[index]) < i - index:
                del HashMap[Strs[index]]  
            HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), i - index)
            index = i
            if index == len(Strs) - 1:  
                HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), 1)
        elif Strs[i] == Strs[index] and i == len(Strs) - 1:  
            HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), i - index + 1)
    ll = sorted(HashMap.items(), key=lambda x: x[1], reverse=1)
    print(ll[k - 1][1])
```

# 停车场车辆统计

```
def Func():
    cars = ("".join(i for i in (input().split(",")))).split("0") 
    # print(cars)
    num = 0 
    for i in cars:
        lennum = (len(i)) 
        if lennum == 0:
            num = num
        elif not lennum % 3 and len != 0:  
            num = num + lennum / 3
        elif lennum % 3:
            num = num + (lennum - lennum % 3) / 3 + 1
    print(int(num))
 
 
if __name__ == "__main__":
    Func()
```

# 比赛

```
from functools import cmp_to_key
 
 
m, n = map(int,input().split(','))
nums = []
for i in range(m):
 
    num = list(map(int,input().split(',')))
    nums.append(num)
def comp(x,y):
    if x[2] != y[2]:
        return y[2] - x[2]
    else:
        return int(y[1]) - int(x[1])
 
def main(nums,m,n):
    if m < 3 or m > 10 or n < 3 or n > 100:
        return -1
    scores = []
    for i in range(n):
        score = []
        for j in range(m):
            if nums[j][i] >10 or nums[j][i] <1:
                return -1
            score.append(nums[j][i])
        score.sort()
        scores.append([i+1,"".join(map(str,score)),sum(score)])
    scores.sort(key=cmp_to_key(comp))
    result = [scores[i][0] for i in range(3)]
    return " ".join(map(str,result))
 
 
print(main(nums, m, n))
```

# 太阳能板最大面积

```
class Solution:
    def sunboard_area(self, list):
        high = list[0] / 2
        chang = 0
        for i in list[1:]:
            if i < high:
                break
            else:
                chang += 1
        area = chang * high
        print(area)
        return area
 
 
if __name__ == "__main__":
    Solution().sunboard_area([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])
```

# 绘图机器

```
[n, e] = list(map(int, input().split()))
res = currentX = currentY = 0
for _ in range(n):
    [x, offset] = list(map(int, input().split()))
    res += (x - currentX) * abs(currentY)
    currentX = x
    currentY += offset
if currentX < e:
    res += (e - currentX) * abs(currentY)
print(res)
```

# 组成最大时间

```
from itertools import permutations
class Solution:
    def largest_time_from_digits(selfself,A):
        max_time,res = 0,""
        for ht,hb,mt,mb,st,sb in permutations(A):
            hour,minute,second = ht*10+hb,mt*10+mb,st*10+sb
            t = hour*60*60 + minute*60 + second
            if hour <24 and minute<60 and second<60 and t>=max_time:
                max_time,res = t,"{}{}:{}{}:{}{}".format(ht,hb,mt,mb,st,sb)
        return res
```

#  第k个排列

```
import itertools
 
n = int(input())
k = int(input())
res = []
for item in itertools.permutations(range(1, n + 1)):
    s = ''.join(map(str, item))
    res.append(int(s))
res.sort()
print(res[k - 1])
```

# 拼接url

```
s = input().split(',')
res = ""
if len(s) == 0:
    res = '/'
else:
    res = '/'.join(s)
    res = res.replace('///', '/').replace('//', '/')
print(res)
```

# 非严格递增连续数字序列

```
s = input()
maxLen = 0
index = 0
while index <= len(s) - 1:
    if s[index].isdigit():  
        lastNum = int(s[index])
        curLen = 1
        for i in range(index + 1, len(s)):
            if s[i].isdigit() and int(s[i]) >= lastNum:
                curLen += 1
                lastNum = int(s[i])
            else:
                index = i - 1
                break
        maxLen = max(maxLen, curLen)
    index += 1
print(maxLen)
```

# 分糖果

```
def candy(x: int):
    if x == 2:
        return 1  
    if x % 2 == 0:
        return candy(x // 2) + 1  
    else:
        return min(candy(x + 1) + 1, candy(x - 1) + 1)
 
 
if __name__ == "__main__":
    n = int(input())
    res = candy(n)
    print(res)
```

# 数字涂色

```
n = int(input())
nums = list(map(int, input().split()))
if nums.count(1) > 0:  
    print(1)
else:
    res = nums.copy()  
    for i in range(0, n - 1):
        for j in range(i + 1, n):
            if nums[j] % nums[i] == 0:
                res.remove(nums[j])
    print(len(res))
```

# 数组拼接

```
while 1:
    try:
        n = int(input())
 
        nums = [input().split(',') for _ in range(n-1)]
 
        dp = []
        i = 0
        while nums:
            if len(nums[i]) > n:
                temp = nums[i][:n]
                nums[i] = nums[i][n:]
            else:
                temp = nums[i]
                nums.pop(i)
            dp += temp
            i += 1
 
            if i >= len(nums):
                i = 0
 
        print(",".join(dp))
    except Exception as e:
        break
```

# 整数对最小和

```
arr1 = list(map(int, input().split()))
arr2 = list(map(int, input().split()))
k = int(input())
sums = []
for i in arr1:
    for j in arr2:
        sums.append(i + j)
sums.sort()
print(sum(sums[:k]))
```

# 相对开音节

```
import re  
 
words = input().split()
res = 0
pat1 = re.compile('[^a-zA-Z]')
pat2 = re.compile('[^aeiou][aeiou][^aeiour]e')
for word in words:
    if pat1.search(word) != None:
        continue
    word = word[::-1]
    # print(word)
    for i in range(len(word) - 3):
        if pat2.search(word[i:i + 4]) != None:
            # print(word[i:i+4])
            res += 1
print(res)
```

# 喊7的次数重排

```
passTimes = list(map(int, input().split()))
n = len(passTimes)
sumN = sum(passTimes)
res = [0] * n
times = 0
for i in range(1, 200):
    if i % 7 == 0 or str(i).count('7'):
        index = i % n - 1
        res[index] += 1
        times += 1
        if times == sumN:
            break
res = list(map(str, res))
print(' '.join(res))
```

# 计算礼品发放的最小分组数目

```
value = int(input())
nums = [int(i) for i in input().split(" ")]
nums.sort()
total = len(nums)
right,left = 0,total-1
while left > right:
    if nums[left] + nums[right] >value:
        right -=1
    else:
        totals -=1
        left +=1
        right-=1
print(total)
```

# 火星文计算 

```
while 1:
    try:
        nums = input()
        # 无符号数
        index_list = [i for i, c in enumerate(nums) if c in "#$"]
 
        # 按操作符 分隔字符串
        stack = []
        s = 0
        for e in index_list:
            stack.append(int(nums[s:e]))
            stack.append(nums[e])
            s = e + 1
        else:
            stack.append(int(nums[s:]))
 
            # 计算 优先级高的$ f"3*{x}+{y}+2")
            r_stack = []
            while stack:
                item = stack.pop()
                if item == "$":
                    x = stack.pop()
                    y = r_stack.pop()
                    stack.append(eval(f"3*{x}+{y}+2"))
                else:
                    r_stack.append(item)
            stack += r_stack[::-1]
 
            # 计算 2*{x}+3*{y}+4"
            x = stack[0]
            for i in range(2, len(stack), 2):
                y = stack[i]
                x = eval(f"2*{x}+3*{y}+4")
            print(x)
    except Exception as e:
        break
```

# 最远足迹 

```
def func(info):
    length = len(info)
    max_index = "(0,0)"
    i = 0
    while i < length:
        max_dis = 0
        l_index = info.find("(", i)
        r_index = info.find(")", i)
        i = r_index + 1
        if l_index >= 0 and r_index >= 0:
            temp = info[l_index + 1:r_index].split(",")
        else:
            break
        if temp[0][0:1:] != '0' and temp[1][0:1:] != '0':
            x = int(temp[0])
            y = int(temp[1])
            if 0 < x < 1000 and 0 < y < 1000 and (x ** 2 + y ** 2) > max_dis:
                max_dis = (x ** 2 + y ** 2)
                max_index = "(" + temp[0] + "," + temp[1] + ")"
    return max_index
 
 
if __name__ == "__main__":
    line = input().strip()
    print(func(line))
```

# 字符串序列判定 

```
if __name__ == "__main__":
    target = input()[::-1]
    source = input()[::-1]
    find_str = source
    res = -1
    len_target = len(target)
    for i, v in enumerate(target):
        index = find_str.find(v)
        if index == -1:
            res = -1
            break
        elif i == len_target - 1:
            res = len(find_str) - 1 - index
            break
        elif index == len(find_str) - 1:
            res = -1
            break
        else:
            find_str = find_str[index + 1:]
    print(res)
```

# 按身高和体重排队

```
n = int(input())
height = input().split()
weight = input().split()
 
arr1 = []
for i in range(n):
    arr1.append(((int(height[i]), int(weight[i])), i + 1))
 
 
def sorted_by_length_weight(x):
    return x[0][0], x[0][1]
 
 
arr2 = sorted(arr1, key=sorted_by_length_weight)
print(" ".join(str(x) for x in list(tuple(i[1] for i in arr2))))
```

# 找车位 

```
if __name__ == "__main__":
    inputLine = "".join(input().split(","))
    line = inputLine.replace("010", "01210").split("2")
 
    res = []
    for item in line:
        zeroLength = len("".join(item.split("1")))
        if item.startswith("1") and item.endswith("1"):
            length = (zeroLength + 1) // 2
        else:
            length = zeroLength
        res.append(length)
    print(max(res))
```

# 最长元音子串的长度

```
def maxVowelLength(s):
    result = ''
    for i in range(len(s) - 1):
        if s[i] not in 'aeiouAEIOU':
            continue
        for j in range(i + 1, len(s)):
            if s[j] in 'aeiouAEIOU':
                if len(s[i:j + 1]) > len(result):
                    result = s[i:j + 1]
            else:
                break
    return result
 
 
if __name__ == "__main__":
    line = str(input().strip())
    print(len(maxVowelLength(line)))
```

# 磁盘容量排序

```
import sys
import re
pattern = re.compile("(\d+[MGT])")
 
n = int(input())
lines = []
for i in range(n):
    lines.append(sys.stdin.readline().strip())
res = []
for line in lines:
    items = pattern.findall(line)
    item2 = 0
    for item in items:
        if item[-1] == 'M':
            item2 += int(item[:-1]) * 1024
        elif item[-1] == 'G':
            item2 += int(item[:-1]) * 1024 * 1024
        elif item[-1] == 'T':
            item2 += int(item[:-1]) * 1024 * 1024 * 1024
        else:
            item2 = int(item)
    res.append((line, item2))
 
 
def sorted_by_count(x):
    return x[1]
 
sortRes = sorted(res, key=sorted_by_count)
for i in sortRes:
    print(i[0])
```

# 乱序整数序列两数之和绝对值最小

```
def Func():
    nums = sorted(input().split(" "))
    minsum = -1
    for x in range(0, len(nums) - 1):
        for y in range(x + 1, len(nums)):
            sum = abs(int(nums[x]) + int(nums[y]))
            if minsum == -1 or sum < minsum:
                minsum = sum
                numx = nums[x]
                numy = nums[y]
                if numx > numy:
                    t = numx
                    numx = numy
                    numy = t
    print(numx, numy, minsum)
 
 
if __name__ == "__main__":
    Func()
```

# 考勤信息

```
import sys
 
 
def award(s):
    if s.count('absent') > 1:  
        return 'false'
    if s.count('late late') > 0 or s.count('leaveearly leaveearly') > 0 or s.count('late leaveearly') or s.count(
            'leaveearly late'):  
        return 'false'
    sl = s.split(" ")  
    for i in range(len(sl)):  
        if sl[i] == 'absent' or sl[i] == 'late' or sl[i] == 'leaveearly':
            num = 0
            l = sl[i + 1:i + 7]
            num += l.count('absent')
            num += l.count('late')
            num += l.count('leaveearly')
            if num > 2:
                return 'false'
    return 'true'
 
 
if __name__ == "__main__":
    n = int(sys.stdin.readline())  
    res = []
    for i in range(n):
        line = sys.stdin.readline().strip()
        res.append(award(line))
    print(" ".join(res))
```

# 快递运输

```
class Solution:
    def getMastnum(self, N: int, things: str) -> int:
        things = things.split(",")
        l = list(map(int, things))
        heigh = 0
        num = 0
        l.sort()
        for i in range(len(l)):
            heigh += int(l[i])
            if heigh <= N:
                num += 1
        return num
 
 
if __name__ == "__main__":
    solo = Solution()
    print(solo.getMastnum(20, "5,10,2,11"))
```

# 计算最大乘积

```
import functools
 
words = input().split(',')
maxRes = 0
 
 
# 按字符串长度降序排序
def compare(s1: str, s2: str):
    return len(s1) - len(s2)
 
 
words.sort(key=functools.cmp_to_key(compare), reverse=True)
# print(words)
for i in range(len(words) - 1):
    for j in range(i + 1, len(words)):
        flag = True
        for c in words[j]:
            if c in words[i]:
                flag = False
                break
        tmp = len(words[i]) * len(words[j])
        if flag:
            maxRes = max(maxRes, tmp)
print(maxRes)
```

# 求符合要求的结对方式 

```
from itertools import combinations
n = 5
nums = [1,2,2,2,3]
total = 4
res = 0
for i in combinations(nums,2):
    print(i)
    if sum(i) == total:
        res+=1
print(res)
```

# 数列描述

```
n = int(input())
pre = "1"  
if n == 0:
    print(pre)  
else:
    for i in range(1, n + 1):
        cur = ""
        # print(pre)
        curNum = pre[0]  
        count = 1
        if len(pre) == 1:
            cur = str(count) + curNum
        else:
            
            for j in pre[1:]:
                if curNum == j:
                    count += 1
                else:
                    cur += str(count) + curNum
                    count = 1  
                    curNum = j  
            cur += str(count) + curNum
        pre = cur  
    print(pre)
```

# 玩牌高手

```
nums = [1,-5,-6,4,3,6,-2]
res = []
for i in range(0,len(nums)):
    temp = nums[i]
    if i<3:
        res.append(max(0+temp,0))
    else:
        res.append(max(res[i-3],res[-1]+temp))
print(res)
```

# 关联子串 

```
str1 = "abc"
str2 = "efghiccaiii"
length = len(str1)
temp=[]
for i in range(len(str2)-length):
    temp = list(str2[i:i+length])
    j=0
    while j<length:
        if str1[j] in temp:
            temp.remove(str1[j])
        j+=1
    if temp==[]:
        print(i)
        break
if temp != []:
    print(-1)
```

# 全排列 

```
def permutation(s:str):
    if len(s) <= 1:
        return [s]
    return list(set(s[i] + perm for i in range(len(s)) for perm in permutation(s[:i] + s[i+1:])))
s = input()
res = permutation(s)
print(len(res))
```

# 组成最大数

```
def func(mock_input):
    nums = mock_input.split(",")
    length = len(nums)
    for i in range(length):
        for j in range(i + 1, length):
            if nums[i] + nums[j] < nums[j] + nums[i]:
                temp = nums[i]
                nums[i] = nums[j]
                nums[j] = temp
    result = str(int("".join(nums)))
    return result
 
 
if __name__ == "__main__":
    line = input().strip()
    print(func(line))
```

# 检查是否存在满足条件的数字组合

```
while 1:
    try:
        n = int(input())
        nums = list(map(int, input().split()))
        # 去重
        nums = list(set(nums))
        # 降序
        nums.sort(reverse=True)
 
        def dfs(total, sub):
            for i in range(len(sub)):
                for j in range(len(sub)):
                    if i != j:
                        _t = sub[i] + sub[j] * 2
                        if total == _t:
                            return f"{total} {sub[i]} {sub[j]}"
                        elif total < _t:
                            break
 
        for i in range(0, n-2):
            r = dfs(nums[i], nums[i+1:][::-1])
            if r:
                print(r)
                break
        else:
            print(0)
    except Exception as e:
        break
```

# 素数之积

```
def check(nums):
    for i in range(2, int(nums ** 0.5) + 1):
        if nums % i == 0:
            return False
    return True
 
 
def func():
    n = int(input())
 
    ans = []
    for i in range(2, n + 1):
        if check(i):
            ans.append(i)
    result = []
    for num in ans:
        while n % num == 0:
            n //= num
            result.append(num)
    if n > 1:
        result.append(n)
    print(' '.join(str(num) for num in result))
 
 
if __name__ == "__main__":
    func()
```

# 字符串变换最小字符串 

```
s = input()
minChar = min(s)
index = s.index(minChar)
res = ""
if index != 0:
    res = s[index] + s[1:index] + s[0] + s[index + 1:]
else:
    res = s
print(res)
```

# 找出经过特定点的路径长度 

```
str1 = "ANTSEDXQOKPUVGIFWHJLYMCRZB"
str2 = "ABC"
 
res = 0
start = str1.index(str2[0])
for i in range(1,len(str2)):
    end = str1.index(str2[i])
    res+=abs(end-start)
    start = end
print(res)
```

# ABR 车路协同场景

```
a = [1,3,5]
b = [2,4,6]
r = 1
 
for i in a:
    for j in range(len(b)):
        if i <=b[j] and b[j]-i<=r:
            print(i,b[j])
            b.pop(j)
            break
        elif i<=b[j]:
            print(i,b[j])
            b.pop(j)
            break
```

# 水仙花数

```
n = int(input())
m = int(input())
num = 0
index = -1
res = 0
if n < 3 or n > 7:
    res = -1
else:
    for i in range(10 ** (n - 1), 10 ** n):
        iStr = str(i)
        if i == int(iStr[0]) ** n + int(iStr[1]) ** n + int(iStr[2]) ** n:
            num = i
            index += 1
            if index == m:
                break
    if index < m:
        res = num * m
    else:
        res = num
print(res)
```

# 全量和已占用字符集

```
import collections
 
allCharStr, usedCharStr = input().split('@')
allChars = collections.defaultdict(list)
res = []
for i, charStr in enumerate(allCharStr.split(',')):
    char, num = charStr.split(':')
    allChars[char] = [i, int(num)]
# print(allChars)
for usedChar in usedCharStr.split(','):
    char, num = usedChar.split(':')
    charInfo = allChars[char]
    charInfo[1] = charInfo[1] - int(num)
allChars = sorted(allChars.items(), key=lambda item: item[1])
for char, charInfo in allChars:
    if charInfo[1] == 0:
        continue
    res.append(char + ':' + str(charInfo[1]))
print(','.join(res))
```

# 密钥格式化

```
while 1:
    try:
        # 分割第一的 - 前后的字符串 位 s1 s2
        s1, s2 = input().split("-", 1)
        k = int(input())
 
        # s2 需要去除分隔符，转大写
        # 按长度 k 重新分隔
        s2 = s2.replace("-", "").upper()
 
        dp = []
        for i in range(0, len(s2), k):
            dp.append(s2[i: i + k])
 
        s2 = "-".join(dp)
        print(f"{s1}-{s2}")
    except Exception as e:
        break
```

# 数字字符串组合倒序 

```
import re 
s = input().strip()
pattern = re.compile("[a-zA-Z0-9-]+")
res = pattern.findall(s)
new_s = []
for i in res:
    if "--" in i:
        temp = i.split("--")
        for j in temp:
            new_s.append(j.strip("-"))
    else:
        new_s.append(i.strip("-"))
print(new_s[::-1])
```

# 查找接口成功率最优时间段

```
min_aver = int(input().strip())
nums = map(int,input().strip().split(" "))
 
temp = []
res = []
for i in range(len(nums)):
    for j in range(i+1,len(nums)+1):
        if sum(nums[i:j]) <= min_aver*(j-i+1):
            res.append([len(nums[i:j]),i,j-1])
            
new_res = sorted(res,key=lambda x:x[0],reverse=True)
max_num = new_res[0][0]
result = []
for i in new_res:
    if i[0] == max_num:
        print("-".join([str(i[1]),str(i[-1])]))
    else:
        break
```

# 路灯照明问题

```
n = int(input())
rNums = list(map(int, input().split()))
res = []
lightSum = 0
for i in range(n):
    l = max(0, 100 * i - rNums[i])
    r = min((n - 1) * 100, 100 * i + rNums[i])
    while len(res) > 0 and res[-1][1] > l:
        left, right = res.pop(len(res) - 1)
        lightSum -= right - left
        l = min(left, l)  
        r = max(right, r)  
    lightSum += r - l  
    res.append([l, r])  
print((n - 1) * 100 - lightSum)
```

# 出错的或电路

```
 
s1 = "110"
s2 = "110"
n=3
s1_zero = s1.count("0")
s1_one = s1.count("1")
s2_zero = 0
s2_one = 0
for i in range(n):
    if s2[i]=="0" and s1[i] == "0":
        s2_zero +=1
    if s2[i] == "0" and s1[i] == "1":
        s2_one += 1
 
total = s1_zero*s2_one + s1_one*s2_zero
print(total)
print(s1_zero)
```




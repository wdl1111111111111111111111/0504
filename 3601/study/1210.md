## 出错的或电路

```
 
s1 = "110"
s2 = "110"
n=3
s1_zero = s1.count("0")
s1_one = s1.count("1")
s2_zero = 0
s2_one = 0
for i in range(n):
    if s2[i]=="0" and s1[i] == "0":
        s2_zero +=1
    if s2[i] == "0" and s1[i] == "1":
        s2_one += 1
 
total = s1_zero*s2_one + s1_one*s2_zero
print(total)
print(s1_zero)
```

## 路灯照明问题

```
if __name__ == "__main__":
    N = 8
    Lights = list(map(int, "10 10 10 250 10 10 10 10".split()))
    res = []
    LightSum = 0
    for i in range(N):
        left = max(0, 100*i-Lights[i])
        right = min((N-1)*100, 100*i+Lights[i])
        while len(res) > 0 and res[-1][1] > left:
            left_new, right_rew = res.pop(len(res)-1)
            LightSum -= right_rew - left_new
            left = min(left_new, left)
            right = max(right_rew, right)
        LightSum += right - left
        res.append([left, right])
    print((N-1)*100 - LightSum)
```

## 查找接口成功率最优时间段 

```
min_aver = int(input().strip())
nums = map(int,input().strip().split(" "))
 
temp = []
res = []
for i in range(len(nums)):
    for j in range(i+1,len(nums)+1):
        if sum(nums[i:j]) <= min_aver*(j-i+1):
            res.append([len(nums[i:j]),i,j-1])
            
new_res = sorted(res,key=lambda x:x[0],reverse=True)
max_num = new_res[0][0]
result = []
for i in new_res:
    if i[0] == max_num:
        print("-".join([str(i[1]),str(i[-1])]))
    else:
        break
```

## 数字字符串组合倒序

```
import re 
s = input().strip()
pattern = re.compile("[a-zA-Z0-9-]+")
res = pattern.findall(s)
new_s = []
for i in res:
    if "--" in i:
        temp = i.split("--")
        for j in temp:
            new_s.append(j.strip("-"))
    else:
        new_s.append(i.strip("-"))
print(new_s[::-1])
```

## 全量和已占用字符集

```
```



while 1:
    try:
        a, b = input().split("@")
        lst = [c.split(':') for c in a.split(',')]
        if not b:
            print(f"{a}@")
            break
        dct = {}

        for c in b.split(','):
            k, v = c.split(':')
            dct[k] = int(v)
     
        for item in lst:
            if item[0] in dct:
                count = int(item[1]) - dct[item[0]]
                if count > 0:
                    item[1] = str(count)
                else:
                    lst.remove(item)
     
        print(",".join([f"{i[0]}:{i[1]}" for i in lst]))
    except Exception as e:
        break

## 水仙花数

```
n = int(input())
m = int(input())
num = 0
index = -1
res = 0
if n < 3 or n > 7:
    res = -1
else:
    for i in range(10 ** (n - 1), 10 ** n):
        iStr = str(i)
        if i == int(iStr[0]) ** n + int(iStr[1]) ** n + int(iStr[2]) ** n:
            num = i
            index += 1
            if index == m:
                break
    if index < m:
        res = num * m
    else:
        res = num
print(res)
```

## 字符串排序 

```
import functools
s = "Hello hello world"
s = "i LOVE Cc I love CC Hello Hel Hellow"
s_list = s.split(" ")
visited = []
new_s = []
for i in s_list:
    if i.upper() not in visited:
        visited.append(i.upper())
        new_s.append(i)
 
def compare(x,y):
    len1 = len(x)
    len2 = len(y)
    min_length = min(len1,len2)
    for i in range(min_length):
        if x[i].upper()!=y[i].upper():
            return ord(x[i].upper()) - ord(y[i].upper())
 
    if len1>len2:
        return 1
    else:
        return -1
 
new_new_s = sorted(new_s,key=functools.cmp_to_key(compare))
 
print(new_new_s)
```

## 解密犯罪时间 

```
def decrypt_crime_time(s):
    nums_list = [int(i) for i in s if i != ":"]
    H, M = [int(i) for i in s.split(":")]
    # ['11', '10', '15', '13', '01', '00', '05', '03', '51', '50', '55', '53', '31', '30', '35', '33']
    time = []
    for i in nums_list:
        for j in nums_list:
            time.append(str(i) + str(j))
    print(time)
    time1 = []
    time2 = []
   
    for i in range(len(time)):
        if M < int(time[i]) <= 59: 
            time1.append(time[i])
 
    if len(time1) > 0:
        time1.sort()
        if H < 10:  
            return '0' + str(H) + ":" + time1[0]
        else:
            return str(H) + ":" + time1[0]
    else:
        for i in range(len(time)):
            if H < int(time[i]) <= 23:
                time2.append(time[i])
        if len(time2) > 0:
            time2.sort()
            return str(time2[0]) + ":" + str(min(time))
        else:
            return str(min(time)) + ":" + str(min(time))
 
 
if __name__ == "__main__":
    s = "23:33"
    print(decrypt_crime_time(s))
```

## ABR 车路协同场景

```
a = [1,3,5]
b = [2,4,6]
r = 1
p = 0
q = 0
while p<len(a) and q <len(b):
    if a[p] <=b[q] and b[q] -a[p] <r:
        print(a[p],b[q])
        p+=1
    elif a[p]<=b[q]:
        print(a[p],b[q])
        p+=1
    q+=1
```

## 找出经过特定点的路径长度

```
str1 = "ANTSEDXQOKPUVGIFWHJLYMCRZB"
str2 = "ABC"
 
res = 0
start = str1.index(str2[0])
for i in range(1,len(str2)):
    end = str1.index(str2[i])
    res+=abs(end-start)
    start = end
print(res)
```

## 字符串变换最小字符串

```
s = input()
minChar = min(s)
index = s.index(minChar)
res = ""
if index != 0:
    res = s[index] + s[1:index] + s[0] + s[index + 1:]
else:
    res = s
print(res)
```

## 素数之积 

```
def check(nums):
    for i in range(2, int(nums ** 0.5) + 1):
        if nums % i == 0:
            return False
    return True
 
 
def func():
    n = int(input())
 
    ans = []
    for i in range(2, n + 1):
        if check(i):
            ans.append(i)
    result = []
    for num in ans:
        while n % num == 0:
            n //= num
            result.append(num)
    if n > 1:
        result.append(n)
    print(' '.join(str(num) for num in result))
 
 
if __name__ == "__main__":
    func()
```

## A=B+2C

```
while 1:
    try:
        n = int(input())
        nums = list(map(int, input().split()))
        # 去重
        nums = list(set(nums))
        # 降序
        nums.sort(reverse=True)
 
        def dfs(total, sub):
            for i in range(len(sub)):
                for j in range(len(sub)):
                    if i != j:
                        _t = sub[i] + sub[j] * 2
                        if total == _t:
                            return f"{total} {sub[i]} {sub[j]}"
                        elif total < _t:
                            break
 
        for i in range(0, n-2):
            r = dfs(nums[i], nums[i+1:][::-1])
            if r:
                print(r)
                break
        else:
            print(0)
    except Exception as e:
        break
```

## 组成最大数

```
def func(mock_input):
    nums = mock_input.split(",")
    length = len(nums)
    for i in range(length):
        for j in range(i + 1, length):
            if nums[i] + nums[j] < nums[j] + nums[i]:
                temp = nums[i]
                nums[i] = nums[j]
                nums[j] = temp
    result = str(int("".join(nums)))
    return result
 
 
if __name__ == "__main__":
    line = input().strip()
    print(func(line))
```

## 全排列

```
def permutation(s:str):
    if len(s) <= 1:
        return [s]
    return list(set(s[i] + perm for i in range(len(s)) for perm in permutation(s[:i] + s[i+1:])))
s = input()
res = permutation(s)
print(len(res))
```

##  关联子串

```
str1 = "abc"
str2 = "efghiccaiii"
length = len(str1)
temp=[]
for i in range(len(str2)-length):
    temp = list(str2[i:i+length])
    j=0
    while j<length:
        if str1[j] in temp:
            temp.remove(str1[j])
        j+=1
    if temp==[]:
        print(i)
        break
if temp != []:
    print(-1)
```

##  玩牌高手

```
nums = [1,-5,-6,4,3,6,-2]
res = []
for i in range(0,len(nums)):
    temp = nums[i]
    if i<3:
        res.append(max(0+temp,0))
    else:
        res.append(max(res[i-3],res[-1]+temp))
print(res)
```

 ##  数列描述

```
n = int(input())
pre = "1"  
if n == 0:
    print(pre)  
else:
    for i in range(1, n + 1):
        cur = ""
        # print(pre)
        curNum = pre[0]  
        count = 1
        if len(pre) == 1:
            cur = str(count) + curNum
        else:
            
            for j in pre[1:]:
                if curNum == j:
                    count += 1
                else:
                    cur += str(count) + curNum
                    count = 1  
                    curNum = j  
            cur += str(count) + curNum
        pre = cur  
    print(pre)
```

##  求符合要求的结对方式 

```
from itertools import combinations
n = 5
nums = [1,2,2,2,3]
total = 4
res = 0
for i in combinations(nums,2):
    print(i)
    if sum(i) == total:
        res+=1
print(res)
```

## 计算最大乘积

```
import functools
 
words = input().split(',')
maxRes = 0
 
 
# 按字符串长度降序排序
def compare(s1: str, s2: str):
    return len(s1) - len(s2)
 
 
words.sort(key=functools.cmp_to_key(compare), reverse=True)
# print(words)
for i in range(len(words) - 1):
    for j in range(i + 1, len(words)):
        flag = True
        for c in words[j]:
            if c in words[i]:
                flag = False
                break
        tmp = len(words[i]) * len(words[j])
        if flag:
            maxRes = max(maxRes, tmp)
print(maxRes)
```

## 快递运输

```
class Solution:
    def getMastnum(self, N: int, things: str) -> int:
        things = things.split(",")
        l = list(map(int, things))
        heigh = 0
        num = 0
        l.sort()
        for i in range(len(l)):
            heigh += int(l[i])
            if heigh <= N:
                num += 1
        return num
 
 
if __name__ == "__main__":
    solo = Solution()
    print(solo.getMastnum(20, "5,10,2,11"))
```

## 考勤信息

```
import sys
 
 
def award(s):
    if s.count('absent') > 1:  
        return 'false'
    if s.count('late late') > 0 or s.count('leaveearly leaveearly') > 0 or s.count('late leaveearly') or s.count(
            'leaveearly late'):  
        return 'false'
    sl = s.split(" ")  
    for i in range(len(sl)):  
        if sl[i] == 'absent' or sl[i] == 'late' or sl[i] == 'leaveearly':
            num = 0
            l = sl[i + 1:i + 7]
            num += l.count('absent')
            num += l.count('late')
            num += l.count('leaveearly')
            if num > 2:
                return 'false'
    return 'true'
 
 
if __name__ == "__main__":
    n = int(sys.stdin.readline())  
    res = []
    for i in range(n):
        line = sys.stdin.readline().strip()
        res.append(award(line))
    print(" ".join(res))
```

##  乱序整数序列两数之和绝对值最小 

```
def Func():
    nums = sorted(input().split(" "))
    minsum = -1
    for x in range(0, len(nums) - 1):
        for y in range(x + 1, len(nums)):
            sum = abs(int(nums[x]) + int(nums[y]))
            if minsum == -1 or sum < minsum:
                minsum = sum
                numx = nums[x]
                numy = nums[y]
                if numx > numy:
                    t = numx
                    numx = numy
                    numy = t
    print(numx, numy, minsum)
 
 
if __name__ == "__main__":
    Func()
```

## 最长元音子串的长度

```
def maxVowelLength(s):
    result = ''
    for i in range(len(s) - 1):
        if s[i] not in 'aeiouAEIOU':
            continue
        for j in range(i + 1, len(s)):
            if s[j] in 'aeiouAEIOU':
                if len(s[i:j + 1]) > len(result):
                    result = s[i:j + 1]
            else:
                break
    return result
 
 
if __name__ == "__main__":
    line = str(input().strip())
    print(len(maxVowelLength(line)))
```

## 找车位 

```
if __name__ == "__main__":
    inputLine = "".join(input().split(","))
    line = inputLine.replace("010", "01210").split("2")
 
    res = []
    for item in line:
        zeroLength = len("".join(item.split("1")))
        if item.startswith("1") and item.endswith("1"):
            length = (zeroLength + 1) // 2
        else:
            length = zeroLength
        res.append(length)
    print(max(res))
```

## 按身高和体重排队

```
n = int(input())
height = input().split()
weight = input().split()
 
arr1 = []
for i in range(n):
    arr1.append(((int(height[i]), int(weight[i])), i + 1))
 
 
def sorted_by_length_weight(x):
    return x[0][0], x[0][1]
 
 
arr2 = sorted(arr1, key=sorted_by_length_weight)
print(" ".join(str(x) for x in list(tuple(i[1] for i in arr2))))
```

## 字符串序列判定

```
if __name__ == "__main__":
    S = input()
    L = input()
    n = len(S)
    m = len(L)
    j = 0
    k = 0
    while j < n and k < m:  
        if S[j] == L[k]:
            j += 1
        k += 1
    if j == n:
        print(L.index(S[-1]))
    else:
        print("-1")
```

## 最远足迹

```
def func(info):
    length = len(info)
    max_index = "(0,0)"
    i = 0
    while i < length:
        max_dis = 0
        l_index = info.find("(", i)
        r_index = info.find(")", i)
        i = r_index + 1
        if l_index >= 0 and r_index >= 0:
            temp = info[l_index + 1:r_index].split(",")
        else:
            break
        if temp[0][0:1:] != '0' and temp[1][0:1:] != '0':
            x = int(temp[0])
            y = int(temp[1])
            if 0 < x < 1000 and 0 < y < 1000 and (x ** 2 + y ** 2) > max_dis:
                max_dis = (x ** 2 + y ** 2)
                max_index = "(" + temp[0] + "," + temp[1] + ")"
    return max_index
 
 
if __name__ == "__main__":
    line = input().strip()
    print(func(line))
```

## 火星文计算

```
while 1:
    try:
        nums = input()
        # 无符号数
        index_list = [i for i, c in enumerate(nums) if c in "#$"]
 
        # 按操作符 分隔字符串
        stack = []
        s = 0
        for e in index_list:
            stack.append(int(nums[s:e]))
            stack.append(nums[e])
            s = e + 1
        else:
            stack.append(int(nums[s:]))
 
            # 计算 优先级高的$ f"3*{x}+{y}+2")
            r_stack = []
            while stack:
                item = stack.pop()
                if item == "$":
                    x = stack.pop()
                    y = r_stack.pop()
                    stack.append(eval(f"3*{x}+{y}+2"))
                else:
                    r_stack.append(item)
            stack += r_stack[::-1]
 
            # 计算 2*{x}+3*{y}+4"
            x = stack[0]
            for i in range(2, len(stack), 2):
                y = stack[i]
                x = eval(f"2*{x}+3*{y}+4")
            print(x)
    except Exception as e:
        break
```

## 勾股数元祖

```
n = int(input())
m = int(input())
flag = True
 
 
def isRel(x: int, y: int):
    minNum = min(x, y)
    for i in range(2, minNum + 1):
        if x % i == 0 and y % i == 0:  
            return False
    return True
 
 
for i in range(n, m - 1):
    for j in range(i + 1, m):
        for k in range(j + 1, m + 1):
            if isRel(i, j) and isRel(i, k) and isRel(j, k) and i ** 2 + j ** 2 == k ** 2:
                print(str(i) + ' ' + str(j) + ' ' + str(k))
                flag = False
if flag:
    print("Na")
```

## 计算礼品发放的最小分组数目 

```
value = int(input())
nums = [int(i) for i in input().split(" ")]
nums.sort()
total = len(nums)
right,left = 0,total-1
while left > right:
    if nums[left] + nums[right] >value:
        right -=1
    else:
        totals -=1
        left +=1
        right-=1
print(total)
```

## 喊7的次数重排

```
passTimes = list(map(int, input().split()))
n = len(passTimes)
sumN = sum(passTimes)
res = [0] * n
times = 0
for i in range(1, 200):
    if i % 7 == 0 or str(i).count('7'):
        index = i % n - 1
        res[index] += 1
        times += 1
        if times == sumN:
            break
res = list(map(str, res))
print(' '.join(res))
```

## 整数对最小和 

```
import heapq
 
 
def Func():
    array1 = input().split()
    array2 = input().split()
    k = int(input())
    if len(array1) >= 100 or len(array2) >= 100:
        print("字符串长度超过标准")
    else:
        size1 = min(int(array1[0]), len(array1) - 1)
        size2 = min(int(array2[0]), len(array2) - 1)
        array3 = []
        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                heapq.heappush(array3, [int(array1[i]), int(array2[j])])
        min = 0
        for i in range(k):
            min += sum(array3[i])
        print(min)
 
 
if __name__ == "__main__":
    Func()
```

## 数组拼接 

```
while 1:
    try:
        n = int(input())
 
        nums = [input().split(',') for _ in range(n-1)]
 
        dp = []
        i = 0
        while nums:
            if len(nums[i]) > n:
                temp = nums[i][:n]
                nums[i] = nums[i][n:]
            else:
                temp = nums[i]
                nums.pop(i)
            dp += temp
            i += 1
 
            if i >= len(nums):
                i = 0
 
        print(",".join(dp))
    except Exception as e:
        break
```

## 数字涂色

```
def paint_nums(s):
    arr = [int(x) for x in s.split(" ")]
    arr.sort()
    l = len(arr)
    i = 0
    start = arr[0]
    color = 1
    while arr:
        if i > l - 1:
            i = 0
            color += 1  
            start = arr[i]
        elif arr[i] % start == 0:
            arr.pop(i)
            l -= 1
        else:
            i += 1
    return color
 
 
if __name__ == "__main__":
    print(paint_nums("2 5 4 7 6"))
```

## 分糖果

```
def candy(x: int):
    if x == 2:
        return 1  
    if x % 2 == 0:
        return candy(x // 2) + 1  
    else:
        return min(candy(x + 1) + 1, candy(x - 1) + 1)
 
 
if __name__ == "__main__":
    n = int(input())
    res = candy(n)
    print(res)
```

## 非严格递增连续数字序列

```
s = input()
maxLen = 0
index = 0
while index <= len(s) - 1:
    if s[index].isdigit():  
        lastNum = int(s[index])
        curLen = 1
        for i in range(index + 1, len(s)):
            if s[i].isdigit() and int(s[i]) >= lastNum:
                curLen += 1
                lastNum = int(s[i])
            else:
                index = i - 1
                break
        maxLen = max(maxLen, curLen)
    index += 1
print(maxLen)
```

## 第k个排列

```
import itertools
 
n = int(input())
k = int(input())
res = []
for item in itertools.permutations(range(1, n + 1)):
    s = ''.join(map(str, item))
    res.append(int(s))
res.sort()
print(res[k - 1])
```

##  绘图机器

```
[n, e] = list(map(int, input().split()))
res = currentX = currentY = 0
for _ in range(n):
    [x, offset] = list(map(int, input().split()))
    res += (x - currentX) * abs(currentY)
    currentX = x
    currentY += offset
if currentX < e:
    res += (e - currentX) * abs(currentY)
print(res)
```

## 太阳能板最大面积

```
class Solution:
    def sunboard_area(self, list):
        high = list[0] / 2
        chang = 0
        for i in list[1:]:
            if i < high:
                break
            else:
                chang += 1
        area = chang * high
        print(area)
        return area
 
 
if __name__ == "__main__":
    Solution().sunboard_area([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])
```

## 比赛

```
def compare_score(A, B, score_list):
    scoreA = [ac[A] for ac in score_list]
    scoreB = [ac[B] for ac in score_list]
    scoreA.sort(reverse=True)  
    scoreB.sort(reverse=True)  
    totalA = sum(scoreA)
    totalB = sum(scoreB)
    if totalA > totalB:
        return A
    elif totalA < totalB:
        return B
    else:
        for index in range(int(m)):
            if scoreA[index] - scoreB[index] > 0:
                return A
            elif scoreA[index] - scoreB[index] < 0:
                return B
            else:
                continue
 
 
def check_variable(score_list):
    for li in score_list:
        for l in li:
            if int(l) > 10 or int(l) < 1:
                return False
    return True
 
 
try:
    m, n = input().split(',')
    score_list = []
    flag = 1
    if 2 <= int(m) <= 10 and 3 <= int(n) <= 100:
        for i in range(int(m)):
            score = input().split(',')
            score_list.append([int(s) for s in score])
        flag = check_variable(score_list)  
        if flag:
            namelist = []
            for loop in range(3): 
                A = 0
                for j in range(int(n) - 1):
                    if int(A) + 1 in namelist or j + 2 in namelist:
                        continue
                    big = compare_score(A, j + 1, score_list)
                    A = big
                namelist.append(int(A) + 1)  
            print(','.join(namelist))
        else:
            print(-1)
    else:
        print(-1)
except:
    print(-1)
```

##  停车场车辆统计

```
def Func():
    cars = ("".join(i for i in (input().split(",")))).split("0") 
    # print(cars)
    num = 0 
    for i in cars:
        lennum = (len(i)) 
        if lennum == 0:
            num = num
        elif not lennum % 3 and len != 0:  
            num = num + lennum / 3
        elif lennum % 3:
            num = num + (lennum - lennum % 3) / 3 + 1
    print(int(num))
 
 
if __name__ == "__main__":
    Func()
```

## 连续字母长度

```
if __name__ == "__main__":
    Strs = "ABC"
    k = 2
    index = 0  
    HashMap = dict()
    for i in range(len(Strs)):
        if Strs[i] != Strs[index]: 
            if HashMap.get(Strs[index]) and HashMap.get(Strs[index]) < i - index:
                del HashMap[Strs[index]]  
            HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), i - index)
            index = i
            if index == len(Strs) - 1:  
                HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), 1)
        elif Strs[i] == Strs[index] and i == len(Strs) - 1:  
            HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), i - index + 1)
    ll = sorted(HashMap.items(), key=lambda x: x[1], reverse=1)
    print(ll[k - 1][1])
```

##  字符串筛选排序

```
s = input()
k = int(input())
sortList = sorted(s)
maxASCII = ''
if k > len(sortList):
    maxASCII = sortList[-1]
else:
    maxASCII = sortList[k - 1]
print(s.index(maxASCII))
```

## 数组去重和排序 

```
class Solution():
    def remove_duplicates_sort(self, arry):
        dict = {}
        for i in arry:
            dict[i] = arry.count(i)
        print(dict)
        dict = sorted(dict.items(), key=lambda x: x[1], reverse=True)
        print(dict)
        arry1 = []
        for i in dict:
            arry1.append(i[0])
        print(arry1)
        return arry1
 
 
if __name__ == "__main__":
    Solution().remove_duplicates_sort([1, 3, 3, 3, 2, 4, 4, 5])
```

##  TLV解析

```
Tag = int(input())  # 待解码信元的tag
Lists = input().split()  # 待解码的16进制码流
 
Tag = 30
Lists = "32 01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC".split()  # tag=0,4,9
q = 0
# print(Lists)
while q < len(Lists):
    NewTag = int(Lists[q])  # 新的信元tag值
    NewLenght = int(Lists[q + 2] + Lists[q + 1], 16)  # 小段序，逆序存储(字符串是可以直接通过+进行连接的)；大端序，正序存储，先计算Lenght长度
    NewValue = Lists[q + 3:q + 3 + NewLenght]  # 统计对应信元的value，因为小短序已经到q+2了，所有value要从q+3开始，对应长度再加NewLenght
    # print(q, NewTag, NewLenght, NewValue)
    if NewTag == Tag:
        print(" ".join(NewValue))
        break
    else:
        q = q + 3 + NewLenght  # 如果没有找到，则跳得写一个信元tag的位置；因为tag长度为1，Lenght长度为2，所以要+3，后面还有对应Lenght长度的Value
```

## 滑动窗口最大值

```
def find_max_window(nums: int, array: list, window_size: int):
 
    if window_size > nums:
        raise ValueError("window size must be less than nums")
    if window_size == nums:
        return sum(array)
    left_point = 0
    right_point = window_size
    max_num = 0
    while right_point <= nums:
        max_num = max(max_num, sum(array[left_point: right_point]))
        left_point += 1
        right_point += 1
    return max_num
```

## 最长连续子序列

```
nums = list(map(int, input().split(',')))
reqSum = int(input())
maxLen = -1
for i in range(len(nums) - 1):
    curLen = -1
    curSum = nums[i]
    if nums[i] == reqSum:
        curLen = 1
        continue
    elif nums[i] > reqSum:
        continue
    for j in range(i + 1, len(nums)):
        if curSum + nums[j] == reqSum:
            curLen = j - i + 1
        elif curSum + nums[j] < reqSum:
            curSum += nums[j]
        else:
            break
    maxLen = max(maxLen, curLen)
print(maxLen)
```

## 最大花费金额

``` import itertools
 
goods = list(map(int, input().split(',')))
maxMoney = int(input())
res = []
for a in itertools.combinations(goods, 3):
    tmp = sum(a)
    if tmp <= maxMoney:
        res.append(tmp)
if len(res) > 0:
    print(max(res))
else:
    print(-1)
```

## 分班问题

```
try:
    s = input().split()
    res = [[], []]
    preFlag = 0  
    for i, child in enumerate(s):
        index, isSame = child.split('/')
        if i == 0:
            res[0].append(index)
        else:
            if isSame == 'N':
                preFlag = int(not preFlag)
            res[preFlag].append(index)
    for i in range(2):
        print(' '.join(sorted(res[i])))
except:
    print("ERROR")
```

## 工号不够用

```
while 1:
    try:
        max_, y = list(map(int, input().split()))
 
        z = 26 ** y
        for i in range(1, 9 - y):
            if z * (10 ** i) >= max_:
                print(i)
                break
 
    except Exception as e:
        break
```

## 靠谱的车

```
n = int(input())
res = n
tmp = t = 0
i = 1
while n > 0:
    if n % 10 > 4:
        tmp += (n % 10 - 1) * t + i
    else:
        tmp += (n % 10) * t
    t = t * 9 + i
    i *= 10
    n = n // 10
print(res - tmp)
```

## 高矮个子排队

```
while 1:
    try:
 
        s = input()
 
        l = list(map(int, s.split(" ")))
        print(l)
 
        ll = l.copy()
        ll.sort(reverse=True)
        print(ll)
        if len(ll) % 2 == 0:
            e = int(len(ll) / 2)
        else:
            e = int(len(ll) / 2) + 1
        print(e)
 
        for i in range(0, len(l), 2):
            if l[i] not in ll[0:e]:
                for j in range(1, len(l), 2):
                    if l[j] in ll[0:e]:
                        tmp = l[i]
                        l[i] = l[j]
                        l[j] = tmp
                        break
        print(" ".join(map(str, l)))
 
        break
 
    except Exception as e:
        print("[]")
        break
```

## 报数游戏

```
m = int(input())
if m <= 1 or m >= 100:
    print("ERROR!")
else:
    a = []
    for i in range(100):
        a.append(i + 1)  
    index = count = 0
    while len(a) >= m:  
        count += 1
        if count == m:  
            a.pop(index)  
            count = 0  
            if index > len(a) - 1:  
                index = 0  
        else:
            if index == len(a) - 1:
                index = 0
            else:
                index += 1
    print(','.join(map(str, a)))
```

## 5键键盘

```
def FiveKeyBoard(s):
    screen = ''
    clip = ''
    selected = False
    for i in s:
        if i == '1' and not selected:  # a
            screen += 'a'
        elif i == '1' and selected:  # a
            screen = 'a'
            selected = False
        elif i == '2' and selected and screen:  
            clip = screen
        elif i == '3' and selected and screen:  
            clip = screen
            screen = ''
            selected = False
        elif i == '4' and selected:  
            screen = clip
            selected = False
        elif i == '4' and not selected:  
            screen += clip
        elif i == '5' and screen: 
            selected = True
    return len(screen)
 
 
if __name__ == "__main__":
    line = str(input().strip())
    print(FiveKeyBoard(line))
```

## 用户调度问题

```
n = int(input())
res = 0
preIndex = -1
for i in range(n):
    times = list(map(int, input().split()))
    minTime = 0
    if preIndex < 0:
        minTime = min(times)
    else:
        tmp = []
        for j, v in enumerate(times):
            if j == preIndex:
                continue
            tmp.append(v)
        minTime = min(tmp)
    preIndex = times.index(minTime)
    res += minTime
print(res)
```

## GPU执行时长

```
n = int(input())
m = int(input())
nums = list(map(int, input().split()))
res = 0
rem = 0
for i in nums:
    res += 1
    if rem + i > n:
        rem = rem + i - n
    else:
        rem = 0
while rem > 0:
    res += 1
    rem -= n
print(res)
```

## 找终点 

```
nums = list(map(int, input().split()))
length = len(nums)
res = []
for i in range(1, length // 2):
    step = 1
    index = i
    while index < length - 1:
        index += nums[index]
        step += 1
    if index == length - 1:
        res.append(step)
if len(res) > 0:
    res.sort()
    print(res[0])
else:
    print(-1)
```

## 单词接龙

```##
class Solution():
    def word_dragon(self, start_index, n, word_list):
        result = word_list[start_index]
        start = word_list[start_index]
        word_list.remove(start)
        next_word = self.next_word(start[-1], word_list)
        while next_word != "":
            result += next_word
            start = next_word
            word_list.remove(next_word)
            next_word = self.next_word(start[-1], word_list)
        print(result)
        return result
 
    def next_word(self, end, word_list):
        list1 = []
        for i in word_list:
            if i[0] == end:
                list1.append(i)
        print(list1)
        if list1 == []:
            longest_word = ""
            return longest_word
        max_length = 0
        longest_word = list1[0]
        for i in list1:
            length = len(i)
            if max_length < length:
                max_length = length
                longest_word = i
            elif max_length == length:
                longest_word = min(i, longest_word)
        print(longest_word)
        return longest_word
 
 
if __name__ == "__main__":
    Solution().word_dragon(0, 6, ["word", "dd", "da", "dc", "dword", "d"])
```

## 最大子矩阵和

```
n,m = map(int,input().strip().split(" "))
#test = ["-3,5,-1,5", "2,4,-2,4", "-1,3,-1,3"]
 
ints = []
for i in range(n):
    hang = list(map(int,input().strip().split(" ")))
    ints.append(hang)
print(ints)
 
max_ = 0
 
for start_row in range(n):
    for start_col in range(m):
        for end_row in range(start_row,n):
            jisuan = 0
            for end_col in range(start_col,m):
                row_index = end_row
                while row_index >= start_row:
                    jisuan +=ints[row_index][end_col]
                    row_index-=1
                max_ = max(max_,jisuan)
print(max_)
```

## 矩阵最大值

```python
nums = []
maxSum = 0
for _ in range(n):
    row = input().split(',')
    nums.append(row)
for row in nums:
    curMax = int(''.join(row), 2)
    for _ in range(n - 1):
        row = list(row[-1]) + row[:-1]
        curMax = max(curMax, int(''.join(row), 2))
    maxSum += curMax
print(maxSum)
```

## 堆栈中的剩余数字

```
if __name__ == "__main__":
    nums = list(map(int, input().split()))
    res = []
    while len(nums) > 0:
        num = nums.pop(0)
        while num > 0:
            l = len(res)
            if l == 0:  # 如果res列表为空，直接入栈
                res.append(num)
                num = 0  # num入栈后清零，退出循环
            else:
                curSum = 0
                flag = True  # 是否找到满足条件的元素
                for i in range(l - 1, -1, -1):
                    curSum += res[i]
                    if curSum == num:  # 找到满足条件的元素
                        res = res[:i]  # 下标i到末尾的元素全部出栈
                        num = num * 2  # 需要入栈的新元素
                        flag = False  # 标志位改变
                        break
                if flag:  # 如果没找到满足条件的元素
                    res.append(num)
                    num = 0  # num入栈后清零，退出循环
    print(' '.join(map(str, reversed(res))))  # 逆序输出
```

## 数组组成的最小数字

```
# -*- coding:utf-8 -*-
class Solution:
     def PrintMinNumber(self, numbers):
         # write code here
         lamb = lambda n1,n2 : int(str(n1)+str(n2))-int(str(n2)+str(n1))
         numbers=sorted(numbers,lamb)
         return ''.join([str(i) for i in numbers])
 
if __name__ == "__main__":
    nums = [0, 2, 4, 1, 6, 44]
    nums.sorted()
    print(nums)
    length = len(nums)
    new_nums = []
    if length < 3:
        new_nums = nums
    else:
        new_nums = nums[0:3]
    Solution().PrintMinNumber(nums[0:3])
```

##  小朋友排队-2

```
H,N = map(int,input().split())
list_H = list(map(int,sorted(input().split())))
diff = []
for i in range(len(list_H)):
    diff.append((list_H[i],abs(H-list_H[i])))
diff = sorted(diff,key=lambda x:(x[1],x[0]))
res = []
for j,k in diff:
    res.append(str(j))
print(" ".join(res))
```

## 字符串压缩

```
def getUnZipStr(zipStr):
    if not zipStr:
        return None
 
    Nums = ""
    NewStr = ""
    for x in zipStr:
        if x.islower():  # 小写字母，压缩后只能是数字和小写字母
            if Nums and Nums != "":
                for i in range(int(Nums)):
                    NewStr += x
                Nums = ""  # 对应nums的x字符已经拼接完成，要置空，也许后面还要使用
            else:
                NewStr += x
        elif x.isdigit():  # 小写字母，压缩后只能是数字和小写字母
            if int(x) <= 2 and Nums == "":  # 只有超过2个相同字母才会压缩，否则报异常
                return None
            Nums = Nums + x  # 有可能第1、2、3...都是数字，需要统计总的数字，先利用字符串拼接，用的时候转换成数字
        else:  # 大写字符，特殊字符等都输出异常
            return None
    return NewStr
 
 
if __name__ == "__main__":
    zipStr = "4dff"
    result = getUnZipStr(zipStr)
    if result:
        print(result)
    else:
        print("!error")
```

## 字符串分割

```
# k = int(input().strip())
# str = input().strip()
k=3
str = "12abc-abCABc-4aB@"
str_list = str.split("-")
res = [str_list[0]]
new_str = "".join(str_list[1:])
 
for i in range(0,len(new_str),k):
    temp = new_str[i:i+k]
    upper_num = 0
    lower_num = 0
    for j in temp:
        if j.isupper():
            upper_num+=1
        elif j.islower():
            lower_num +=1
    if upper_num <lower_num:
        temp = temp.lower()
    elif upper_num >lower_num:
        temp = temp.upper()
    res.append(temp)
print("-".join(res))
```

## 消消乐游戏

````
inputStr = input()
line = []
for item in inputStr:
    if len(line) == 0:
        line.append(item)
    elif item == line[-1]:
        line.pop()
    else:
        line.append(item)
if inputStr.isalpha():
    print(len(line))
else:
    print(0)
````

## 最大括号深度

```
while 1:
    try:
        nums = input()
        max_ = 0
        stack = []
        for c in nums:
            if c in "{[(":
                stack.append(c)
            else:
                if not stack:
                    print(0)
                    break
                max_ = max(max_, len(stack))
                cr = stack.pop()
                if f"{cr}{c}" not in ["{}", "[]", "()"]:
                    print(0)
                    break
        else:
            print(max_)
    except Exception as e:
        break
```

## 表达式括号匹配

```
str= ")(1+(2+3)*(3+(8+0))+1-2)"
stack = []
num = 0
for i in str:
    if i =="(":
        stack.append(i)
    elif i ==")" :
        if stack==[]:
            num = -1
            break
        else:
            temp = stack.pop(-1)
            if temp !="(":
                num = -1
                break
            elif temp == "(":
                num+=1
print(num)
```

## 求字符串中所有整数的最小和

```
s = input()
res = 0
flag = False  
num = ""  
for c in s:
    if c.isdigit():
        if flag:
            num += c
        else:
            res += int(c)
    elif c == '-':
        if flag and len(num) > 0:
            res -= int(num)
            num = ""
        flag = True
    else:
        if flag and len(num) > 0:
            res -= int(num)
            num = ""
        flag = False
if flag and len(num) > 0:
    res -= int(num)
print(res)
```

## VLAN资源池

```
pools = input().split(',')
req = int(input())
res = []
resStr = []
for pool in pools:
    poolIDs = list(map(int, pool.split('-')))
    if len(poolIDs) == 1:
        if poolIDs[0] != req:
            res.append(poolIDs[0])
    else:
        sta = poolIDs[0]
        end = poolIDs[1]
        for i in range(sta, end + 1):
            if i == req:
                continue
            res.append(i)
res.sort()
# print(res)
sta = end = res[0]
for i in range(1, len(res)):
    if res[i] == end + 1:
        end = res[i]
    else:
        if sta == end:
            resStr.append(str(sta))
        else:
            resStr.append(str(sta) + '-' + str(end))
        sta = end = res[i]
if sta == end:
    resStr.append(str(sta))
else:
    resStr.append(str(sta) + '-' + str(end))
print(','.join(resStr))
```

## 篮球比赛 

```
def basketball(s):
    from itertools import combinations
    a1 = [int(x) for x in str(s).split(" ")]
    a2 = list(combinations(a1, len(a1) // 2)) 
    min_diff = abs(sum(a1) - 2 * sum(a2[0]))
    for arr in a2:
        if abs(sum(a1) - 2 * sum(arr)) < min_diff:
            min_diff = abs(sum(a1) - 2 * sum(arr))
    return min_diff
 
 
print(basketball("10 9 8 7 6 5 4 3 2 1"))
```

## 翻牌求最大分

```
n= "1,-5,-6,4,7,2,-2"
if  __name__ == '__main__':
    n = list(map(int,n.split(",")))
    if sum(n[:3])<0:
        num=0
    else:
        num=sum(n[:3])
    for i in range(3,len(n)):
        tmp=num+n[i]
        if tmp>num:
            num=tmp
    print(num)
```

# 数组连续和 

```
total = 10000
n = 10 
 
nums= [1,2,3,4,5,6,7,8,9,10]
count = 0
res = 0
for i in range(n):
    count = nums[i]
    if count >total:
        res+=n-i
        break
    for j in range(i+1,n):
        count+=nums[j]
        if count>=total:
            res+=n-j
            break
print(res)
```

##  we are a team

```
class Node:
    def __init__(self, n):
        self.parent = list(range(n + 1))
 
    def get_root(self, i):  
        while i != self.parent[i]:
            i = self.parent[i]
        return i
 
 
def one_team(self, i, j):  
    return self.get_root(i) == self.get_root(j)
 
 
def union(self, i, j):  
    i_root = self.get_root(i)
    j_root = self.get_root(j)
    self.parent[i_root] = j_root
 
 
while True:
    try:
        m, n = map(int, input().split())
        team = Node(m)
        if m < 1 or m > 100000 or n < 1 or n > 100000:
            print("NULL")
            break
        for i in range(n):
            x, y, c = map(int, input().split())
            # uinion a, b in one team
            if x < 1 or x > m or y < 1 or y > m:
                print("da pian zi")
                continue
            if c == 0:
                team.union(x, y)
            elif c == 1:
                ret = team.one_team(x, y)
                if ret == True:
                    print("We are a team")
                else:
                    print("We are not a team")
            else:
                print("da pian zi")
    except:
        break
```

## 矩形相交的面积

```
while 1:
    try:
        xs = []
        ys = []
 
        nums = []
        for _ in range(3):
            x1, y1, w, h = list(map(int, input().split()))
            x2 = x1 + w
            y2 = y1 - h
            xs += [x1, x2]
            ys += [y1, y2]
            nums.append((x1, y1, x2, y2))
 
        min_x, max_x = min(xs), max(xs)
        min_y, max_y = min(ys), max(ys)
 
        x = 0 - min_x
        y = 0 - min_y
        dp = [[0] * abs(max_y-min_y) for _ in range(abs(max_x-min_x))]
 
        for x1, y1, x2, y2 in nums:
            for i in range(min((x2, x1)) + x, max((x2, x1)) + x):
                for j in range(min((y2, y1)) + y, max((y2, y1)) + y):
                    dp[i][j] += 1
 
        ret = 0
        for i in range(len(dp)):
            for j in range(len(dp[0])):
                if dp[i][j] == 3:
                    ret += 1
        print(ret)
    except Exception as e:
        break
```

## ipv4地址转换成整数

```
while 1:
    try:
        nums = list(map(int, input().split("#")))
        if len(nums) != 4:
            print("invalid IP")
        else:
            dp = ""
            for i in range(4):
                if not ((i == 0 and 1 <= nums[i] <= 128) or (i > 0 and 0 <= nums[i] <= 255)):
                    print("invalid IP")
                    break
                dp += bin(nums[i])[2:].zfill(8)
            else:
                print(int(dp, 2))
    except Exception as e:
        break
        
```

## 最少交换次数

```
while 1:
    try:
        nums = list(map(int, input().split()))
        k = int(input())
 
        for i in range(len(nums)):
            if nums[i] < k:
                nums[i] = 1
            else:
                nums[i] = 0
 
        n = len(nums)
        m = sum(nums)
 
        dp = []
        for i in range(n):
            dp.append(sum(nums[i: i + m]))
 
        print(m - max(dp))
    except Exception as e:
        break
```

## 敏感字段加密

```
if __name__ == "__main__":
    while 1:
        try:
            k = int(input())
 
            nums = input()
 
            dp = []
 
            temp = ""
            for c in nums:
                if c == "_":
                    if '"' not in temp and temp:
                        dp.append(temp)
                        temp = ""
                    elif '"' in temp:
                        temp += c
                elif c == '"':
                    if temp and '"' in temp:
                        temp += c
                        dp.append(temp)
                        temp = ""
                    elif temp and '"' not in temp:
                        dp.append(temp)
                        temp = c
                    elif not temp:
                        temp = c
                else:
                    temp += c
            if temp:
                dp.append(temp)
 
            if k < len(dp):
                dp[k] = "*" * 6
                print("_".join(dp))
            else:
                print("ERROR")
        except Exception as e:
            break
```

## 补种未成活胡杨

while 1:
    try:
        n = int(input())
        m = int(input())
        nums = list(map(int, input().split()))
        k = int(input())

        nums = [0 if i + 1 in nums else 1 for i in range(n)]
     
        max_ = 0
        i = 0
        j = min(k, n)
        while j < len(nums):
            count = nums[i:j].count(0)
            if count < k:
                j += 1
            elif count == k:
                max_ = max([j - i, max_])
                j += 1
            else:
                i += 1
        else:
            max_ = max([j - i, max_])
     
        print(max_)
    except Exception as e:
        break

## 跳格子

```
while 1:
    try:
        n = int(input())
 
        nums = []
        for _ in range(n):
            x = input().split()
            if x and len(x) == 2:
                nums.append(tuple(map(int, x)))
            else:
                break
 
        nums = sorted(nums, key=lambda x: x[0])
 
        state = [1] * n
        for start, end in nums:
            state[end] = 0
 
        if max(state) == 0:
            print("no")
            continue
 
        dp = [0]
 
 
        def dfs(s, link):
            if len(link) == len(nums) and sorted(link, key=lambda x: x[0]) == nums:
                dp.append(1)
                return
 
            ends = []
            for start_, end_ in nums:
                if s == start_:
                    link.append((start_, end_))
                    ends.append(end_)
 
            for end_ in ends:
                dfs(end_, link)
 
 
        for i in range(n):
            if state[i] == 1:
                dfs(i, [])
 
        if max(dp):
            print("yes")
        else:
            print("no")
 
    except Exception as e:
        break
```

## 图像物体的边界

```
def edges(grid, row, col):
    def dfs(grid, i, j):
        grid[i][j] = 6
        for x in range(i - 3, i + 4):
            for y in range(j - 3, j + 4):
                if x < 0 or y < 0 or x >= row or y >= col:
                    continue
 
                if grid[x][y] == 5:
                    dfs(grid, x, y)
 
    res = 0
    for i in range(row):
        for j in range(col):
            if grid[i][j] == 5:
                res += 1
                dfs(grid, i, j)
 
    return res
 
 
if __name__ == '__main__':
    row, col = 20, 20
     grid = [[1, 1, 1, 1, 1, 1,],
             [1, 5, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 5,] ]
 
 
    res = edges(grid, row, col)
    print(res)
```

##  lisp运输

```
def lisp(string_words):
    string_words = string_words.split()
    if string_words[0] == "add":
        del string_words[0]
        return sum([int(i) for i in string_words])
    if string_words[0] == "sub":
        return int(string_words[1]) - int(string_words[2])
    if string_words[0] == "mul":
        result = 1
        for i in range(1, len(string_words)):
            result *= int(string_words[i])
        return result
    if string_words[0] == "div":
        if string_words[2] == "0":
            return "error"
        else:
            return round(int(string_words[1]) // int(string_words[2]))
n = input()
while "(" in n:
    k = ''.join(n[::-1].split("(")[0])[::-1].split((")"))[0]
    n = n.replace(f'({k})', str(lisp(k)))
print(n)
```

## 导师火锅

```
n, m = map(int, input().split())
d = set()
for i in range(n):
    d.add(sum(map(int, input().split())))
l = sorted(list(d))
count = 1
t = 0
for i in range(1, len(l)):
    if l[i] - l[t] >= m:
        count += 1
        t = i
print(count)
```

## 面试

```\
while 1:
    try:
        n = int(input())
 
        nums = []
        for _ in range(n):
            nums.append(list(map(int, input().split())))
 
        nums = sorted(nums, key=lambda x: x[0])
        max_ = max([e for s, e in nums])
 
        dp = [0] * (max_+1)
 
        for s, e in nums:
            for i in range(s, e+1):
                dp[i] += 1
 
        print(max(dp))
    except Exception as e:
        break
 
nums = [[1,2],[2,3],[3,4],[4,5],[5,6]]
nums = sorted(nums, key=lambda x: x[0])
max_ = max([e for s, e in nums])
dp = [0] * (max_ + 1)
for s, e in nums:
    for i in range(s, e + 1):
        dp[i] += 1
print(max(dp))
```

## 分糖果

```
n = int(input())
a = [int(x) for x in input().split()]
sums = 0
for x in a:
    sums = sums ^ x
if sums != 0:
    print('NO')
else:
    print(sum(a) - min(a))
```

## 斗地主之顺子

```
s1 = "2 9 J 2 3 4 K A 7 9 A 5 6"
s_dic = {3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0}
s_list = [0,0,0,0,0,0,0,0,0,0,0,0]
new_s = []
for i in s1.split(" "):
    if i !="2":
        if i == "J":
            s_dic[11] = s_dic[11]+1
            new_s.append(11)
            s_list[8] = s_list[8]+1
        elif i == "Q":
            new_s.append(12)
            s_dic[11] = s_dic[11] + 1
            s_list[9] = s_list[9] + 1
        elif i == "K":
            new_s.append(13)
            s_list[10] = s_list[10]+1
        elif i == "A":
            new_s.append(14)
            s_dic[11] = s_dic[11] + 1
            s_list[11] = s_list[11] + 1
        else:
            new_s.append(int(i))
            s_dic[int(i)] = s_dic[int(i)] + 1
            s_list[int(i)-3] = s_list[int(i)-3] + 1
print(new_s)
 
 
new_s.sort()
print(new_s)
print(s_list)
temp = []
res = []
for i in range(len(s_list)):
    if s_list[i] !=0:
        if i+3 == 11:
            temp.append("J")
        elif i+3 == 12:
            temp.append("Q")
        elif i + 3 == 13:
            temp.append("K")
        elif i + 3 == 14:
            temp.append("A")
        else:
            temp.append(i+3)
    else:
        if len(temp)>=5:
            res.append(temp)
        temp = []
if len(temp)>=5:
    res.append(temp)
if res !=[]:
    print(res)
else:
    print("No")
```

## 字符串比较

```
s1 = "xxcdefg"
s2 = "cdefghi"
v = 5
size = len(s1)
res = []
for i in range(size):
    sum = abs(ord(s1[i]) - ord(s2[i]))
    if sum <v:
        for j in range(i+1,size):
            sum +=abs(ord(s1[j]) - ord(s2[j]))
            if sum>v:
                res.append(j-i)
                break
        if sum <v:
            res.append(j - i+1)
    elif sum == v:
        res.append(1)
    else:
        res.append(0)
print(res)
```

## 报文解压缩

```
class Solution:
    def decodeString(self, s: str) -> str:
        stack, a, n = [['', 1, '']], '', ''
        for c in s:
            if c.isalpha():
                a += c
            elif c.isdigit():
                n += c
            elif c == '[':
                stack.append([a, int(n), ''])
                a = n = ''
            else:
                p, t, b = stack.pop()
                stack[-1][-1] += p + t * (b + a)
                a = ''
        return stack.pop()[-1] + a
 
 
if __name__ == "__main__":
    input_str = str(input().strip())
    function = Solution()
    results = function.decodeString(input_str)
    print(results)
```

## 污染水域

```
nums = [1,0,1,0,0,0,1,0,1]
length = int(len(nums)**0.5)
grids = []
queue=[]
for i in range(0,len(nums),3):
    grids.append(nums[i:i+3])
for i in range(length):
    for j in range (length):
        if grids[i][j] == 1:
            queue.append([i,j])
time =-1
while queue:
    len1 = len(queue)
    for _ in range(len1):
        x, y = queue.pop(0)
        for i,j in [(1,0),(0,-1),(-1,0),(0,1)]:
            temp_x = x + i
            temp_y = y + j
            if temp_x>=0 and temp_x <length and temp_y>=0 and temp_y <length and grids[temp_x][temp_y] == 0:
                grids[temp_x][temp_y] = 1
                queue.append([temp_x,temp_y])
    time +=1
for i in grids:
    if 0 in i:
        print(-1)
        break
else:
    print(time)
```

## 连续出牌数量

```
a = input().split()
b = input().split()
 
t_list = {}
for i in range(len(a)):
    if a[i] not in t_list.keys():
        t_list[a[i]] = {}
    t_list[a[i]][i] = b[i]
    if b[i] not in t_list.keys():
        t_list[b[i]] = {}
    t_list[b[i]][i] = a[i]
 
num_list = []
 
max_list = []
 
def dfs(num):
    if num in num_list:
        return
    num_list.append(num)
 
    for i in [a[num], b[num]]:
        v = t_list[i]
        for k1, v1 in v.items():
            dfs(k1)
        max_list.append(len(num_list))
    num_list.pop()
 
 
for i in range(len(a)):
    dfs(i)
print(max(max_list))
```

## 区间交集

```
import sys
 
arr = []
for line in sys.stdin.readlines():
    if line == '\n':
        break
    arr.append(list(map(int, line.split(' '))))
if len(arr) == 1:
    print(arr[0])
arr.sort(key=lambda x: x[0])
comm_section = []
for i in range(len(arr) - 1):
    for j in range(i + 1, len(arr)):
        if arr[i][-1] >= arr[j][0]:
            comm_section.append([arr[j][0], min(arr[i][-1], arr[j][-1])])
            if len(comm_section) == 1:
                print(comm_section)
comm_section.sort(key=lambda x: x[0])
l = len(comm_section)
i = 0
while i <= l - 2:
    if comm_section[i][-1] > comm_section[i + 1][0]:
        comm_section[i][-1] = max(comm_section[i][-1], comm_section[i + 1][-1])
        comm_section.pop(i + 1)
        l -= 1
    else:
        i += 1
    print(comm_section)
```


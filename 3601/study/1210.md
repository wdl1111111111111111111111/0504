## 出错的或电路

```
 
s1 = "110"
s2 = "110"
n=3
s1_zero = s1.count("0")
s1_one = s1.count("1")
s2_zero = 0
s2_one = 0
for i in range(n):
    if s2[i]=="0" and s1[i] == "0":
        s2_zero +=1
    if s2[i] == "0" and s1[i] == "1":
        s2_one += 1
 
total = s1_zero*s2_one + s1_one*s2_zero
print(total)
print(s1_zero)
```

## 路灯照明问题

```
if __name__ == "__main__":
    N = 8
    Lights = list(map(int, "10 10 10 250 10 10 10 10".split()))
    res = []
    LightSum = 0
    for i in range(N):
        left = max(0, 100*i-Lights[i])
        right = min((N-1)*100, 100*i+Lights[i])
        while len(res) > 0 and res[-1][1] > left:
            left_new, right_rew = res.pop(len(res)-1)
            LightSum -= right_rew - left_new
            left = min(left_new, left)
            right = max(right_rew, right)
        LightSum += right - left
        res.append([left, right])
    print((N-1)*100 - LightSum)
```

## 查找接口成功率最优时间段 

```
min_aver = int(input().strip())
nums = map(int,input().strip().split(" "))
 
temp = []
res = []
for i in range(len(nums)):
    for j in range(i+1,len(nums)+1):
        if sum(nums[i:j]) <= min_aver*(j-i+1):
            res.append([len(nums[i:j]),i,j-1])
            
new_res = sorted(res,key=lambda x:x[0],reverse=True)
max_num = new_res[0][0]
result = []
for i in new_res:
    if i[0] == max_num:
        print("-".join([str(i[1]),str(i[-1])]))
    else:
        break
```

## 数字字符串组合倒序

```
import re 
s = input().strip()
pattern = re.compile("[a-zA-Z0-9-]+")
res = pattern.findall(s)
new_s = []
for i in res:
    if "--" in i:
        temp = i.split("--")
        for j in temp:
            new_s.append(j.strip("-"))
    else:
        new_s.append(i.strip("-"))
print(new_s[::-1])
```

## 全量和已占用字符集

```
```



while 1:
    try:
        a, b = input().split("@")
        lst = [c.split(':') for c in a.split(',')]
        if not b:
            print(f"{a}@")
            break
        dct = {}

        for c in b.split(','):
            k, v = c.split(':')
            dct[k] = int(v)
     
        for item in lst:
            if item[0] in dct:
                count = int(item[1]) - dct[item[0]]
                if count > 0:
                    item[1] = str(count)
                else:
                    lst.remove(item)
     
        print(",".join([f"{i[0]}:{i[1]}" for i in lst]))
    except Exception as e:
        break

## 水仙花数

```
n = int(input())
m = int(input())
num = 0
index = -1
res = 0
if n < 3 or n > 7:
    res = -1
else:
    for i in range(10 ** (n - 1), 10 ** n):
        iStr = str(i)
        if i == int(iStr[0]) ** n + int(iStr[1]) ** n + int(iStr[2]) ** n:
            num = i
            index += 1
            if index == m:
                break
    if index < m:
        res = num * m
    else:
        res = num
print(res)
```

## 字符串排序 

```
import functools
s = "Hello hello world"
s = "i LOVE Cc I love CC Hello Hel Hellow"
s_list = s.split(" ")
visited = []
new_s = []
for i in s_list:
    if i.upper() not in visited:
        visited.append(i.upper())
        new_s.append(i)
 
def compare(x,y):
    len1 = len(x)
    len2 = len(y)
    min_length = min(len1,len2)
    for i in range(min_length):
        if x[i].upper()!=y[i].upper():
            return ord(x[i].upper()) - ord(y[i].upper())
 
    if len1>len2:
        return 1
    else:
        return -1
 
new_new_s = sorted(new_s,key=functools.cmp_to_key(compare))
 
print(new_new_s)
```

## 解密犯罪时间 

```
def decrypt_crime_time(s):
    nums_list = [int(i) for i in s if i != ":"]
    H, M = [int(i) for i in s.split(":")]
    # ['11', '10', '15', '13', '01', '00', '05', '03', '51', '50', '55', '53', '31', '30', '35', '33']
    time = []
    for i in nums_list:
        for j in nums_list:
            time.append(str(i) + str(j))
    print(time)
    time1 = []
    time2 = []
   
    for i in range(len(time)):
        if M < int(time[i]) <= 59: 
            time1.append(time[i])
 
    if len(time1) > 0:
        time1.sort()
        if H < 10:  
            return '0' + str(H) + ":" + time1[0]
        else:
            return str(H) + ":" + time1[0]
    else:
        for i in range(len(time)):
            if H < int(time[i]) <= 23:
                time2.append(time[i])
        if len(time2) > 0:
            time2.sort()
            return str(time2[0]) + ":" + str(min(time))
        else:
            return str(min(time)) + ":" + str(min(time))
 
 
if __name__ == "__main__":
    s = "23:33"
    print(decrypt_crime_time(s))
```

## ABR 车路协同场景

```
a = [1,3,5]
b = [2,4,6]
r = 1
p = 0
q = 0
while p<len(a) and q <len(b):
    if a[p] <=b[q] and b[q] -a[p] <r:
        print(a[p],b[q])
        p+=1
    elif a[p]<=b[q]:
        print(a[p],b[q])
        p+=1
    q+=1
```

## 找出经过特定点的路径长度

```
str1 = "ANTSEDXQOKPUVGIFWHJLYMCRZB"
str2 = "ABC"
 
res = 0
start = str1.index(str2[0])
for i in range(1,len(str2)):
    end = str1.index(str2[i])
    res+=abs(end-start)
    start = end
print(res)
```

## 字符串变换最小字符串

```
s = input()
minChar = min(s)
index = s.index(minChar)
res = ""
if index != 0:
    res = s[index] + s[1:index] + s[0] + s[index + 1:]
else:
    res = s
print(res)
```

## 素数之积 

```
def check(nums):
    for i in range(2, int(nums ** 0.5) + 1):
        if nums % i == 0:
            return False
    return True
 
 
def func():
    n = int(input())
 
    ans = []
    for i in range(2, n + 1):
        if check(i):
            ans.append(i)
    result = []
    for num in ans:
        while n % num == 0:
            n //= num
            result.append(num)
    if n > 1:
        result.append(n)
    print(' '.join(str(num) for num in result))
 
 
if __name__ == "__main__":
    func()
```

## A=B+2C

```
while 1:
    try:
        n = int(input())
        nums = list(map(int, input().split()))
        # 去重
        nums = list(set(nums))
        # 降序
        nums.sort(reverse=True)
 
        def dfs(total, sub):
            for i in range(len(sub)):
                for j in range(len(sub)):
                    if i != j:
                        _t = sub[i] + sub[j] * 2
                        if total == _t:
                            return f"{total} {sub[i]} {sub[j]}"
                        elif total < _t:
                            break
 
        for i in range(0, n-2):
            r = dfs(nums[i], nums[i+1:][::-1])
            if r:
                print(r)
                break
        else:
            print(0)
    except Exception as e:
        break
```

## 组成最大数

```
def func(mock_input):
    nums = mock_input.split(",")
    length = len(nums)
    for i in range(length):
        for j in range(i + 1, length):
            if nums[i] + nums[j] < nums[j] + nums[i]:
                temp = nums[i]
                nums[i] = nums[j]
                nums[j] = temp
    result = str(int("".join(nums)))
    return result
 
 
if __name__ == "__main__":
    line = input().strip()
    print(func(line))
```

## 全排列

```
def permutation(s:str):
    if len(s) <= 1:
        return [s]
    return list(set(s[i] + perm for i in range(len(s)) for perm in permutation(s[:i] + s[i+1:])))
s = input()
res = permutation(s)
print(len(res))
```

##  关联子串

```
str1 = "abc"
str2 = "efghiccaiii"
length = len(str1)
temp=[]
for i in range(len(str2)-length):
    temp = list(str2[i:i+length])
    j=0
    while j<length:
        if str1[j] in temp:
            temp.remove(str1[j])
        j+=1
    if temp==[]:
        print(i)
        break
if temp != []:
    print(-1)
```

##  玩牌高手

```
nums = [1,-5,-6,4,3,6,-2]
res = []
for i in range(0,len(nums)):
    temp = nums[i]
    if i<3:
        res.append(max(0+temp,0))
    else:
        res.append(max(res[i-3],res[-1]+temp))
print(res)
```

 ##  数列描述

```
n = int(input())
pre = "1"  
if n == 0:
    print(pre)  
else:
    for i in range(1, n + 1):
        cur = ""
        # print(pre)
        curNum = pre[0]  
        count = 1
        if len(pre) == 1:
            cur = str(count) + curNum
        else:
            
            for j in pre[1:]:
                if curNum == j:
                    count += 1
                else:
                    cur += str(count) + curNum
                    count = 1  
                    curNum = j  
            cur += str(count) + curNum
        pre = cur  
    print(pre)
```

##  求符合要求的结对方式 

```
from itertools import combinations
n = 5
nums = [1,2,2,2,3]
total = 4
res = 0
for i in combinations(nums,2):
    print(i)
    if sum(i) == total:
        res+=1
print(res)
```

## 计算最大乘积

```
import functools
 
words = input().split(',')
maxRes = 0
 
 
# 按字符串长度降序排序
def compare(s1: str, s2: str):
    return len(s1) - len(s2)
 
 
words.sort(key=functools.cmp_to_key(compare), reverse=True)
# print(words)
for i in range(len(words) - 1):
    for j in range(i + 1, len(words)):
        flag = True
        for c in words[j]:
            if c in words[i]:
                flag = False
                break
        tmp = len(words[i]) * len(words[j])
        if flag:
            maxRes = max(maxRes, tmp)
print(maxRes)
```

## 快递运输

```
class Solution:
    def getMastnum(self, N: int, things: str) -> int:
        things = things.split(",")
        l = list(map(int, things))
        heigh = 0
        num = 0
        l.sort()
        for i in range(len(l)):
            heigh += int(l[i])
            if heigh <= N:
                num += 1
        return num
 
 
if __name__ == "__main__":
    solo = Solution()
    print(solo.getMastnum(20, "5,10,2,11"))
```

## 考勤信息

```
import sys
 
 
def award(s):
    if s.count('absent') > 1:  
        return 'false'
    if s.count('late late') > 0 or s.count('leaveearly leaveearly') > 0 or s.count('late leaveearly') or s.count(
            'leaveearly late'):  
        return 'false'
    sl = s.split(" ")  
    for i in range(len(sl)):  
        if sl[i] == 'absent' or sl[i] == 'late' or sl[i] == 'leaveearly':
            num = 0
            l = sl[i + 1:i + 7]
            num += l.count('absent')
            num += l.count('late')
            num += l.count('leaveearly')
            if num > 2:
                return 'false'
    return 'true'
 
 
if __name__ == "__main__":
    n = int(sys.stdin.readline())  
    res = []
    for i in range(n):
        line = sys.stdin.readline().strip()
        res.append(award(line))
    print(" ".join(res))
```

##  乱序整数序列两数之和绝对值最小 

```
def Func():
    nums = sorted(input().split(" "))
    minsum = -1
    for x in range(0, len(nums) - 1):
        for y in range(x + 1, len(nums)):
            sum = abs(int(nums[x]) + int(nums[y]))
            if minsum == -1 or sum < minsum:
                minsum = sum
                numx = nums[x]
                numy = nums[y]
                if numx > numy:
                    t = numx
                    numx = numy
                    numy = t
    print(numx, numy, minsum)
 
 
if __name__ == "__main__":
    Func()
```

## 最长元音子串的长度

```
def maxVowelLength(s):
    result = ''
    for i in range(len(s) - 1):
        if s[i] not in 'aeiouAEIOU':
            continue
        for j in range(i + 1, len(s)):
            if s[j] in 'aeiouAEIOU':
                if len(s[i:j + 1]) > len(result):
                    result = s[i:j + 1]
            else:
                break
    return result
 
 
if __name__ == "__main__":
    line = str(input().strip())
    print(len(maxVowelLength(line)))
```

## 找车位 

```
if __name__ == "__main__":
    inputLine = "".join(input().split(","))
    line = inputLine.replace("010", "01210").split("2")
 
    res = []
    for item in line:
        zeroLength = len("".join(item.split("1")))
        if item.startswith("1") and item.endswith("1"):
            length = (zeroLength + 1) // 2
        else:
            length = zeroLength
        res.append(length)
    print(max(res))
```

## 按身高和体重排队

```
n = int(input())
height = input().split()
weight = input().split()
 
arr1 = []
for i in range(n):
    arr1.append(((int(height[i]), int(weight[i])), i + 1))
 
 
def sorted_by_length_weight(x):
    return x[0][0], x[0][1]
 
 
arr2 = sorted(arr1, key=sorted_by_length_weight)
print(" ".join(str(x) for x in list(tuple(i[1] for i in arr2))))
```

## 字符串序列判定

```
if __name__ == "__main__":
    S = input()
    L = input()
    n = len(S)
    m = len(L)
    j = 0
    k = 0
    while j < n and k < m:  
        if S[j] == L[k]:
            j += 1
        k += 1
    if j == n:
        print(L.index(S[-1]))
    else:
        print("-1")
```

## 最远足迹

```
def func(info):
    length = len(info)
    max_index = "(0,0)"
    i = 0
    while i < length:
        max_dis = 0
        l_index = info.find("(", i)
        r_index = info.find(")", i)
        i = r_index + 1
        if l_index >= 0 and r_index >= 0:
            temp = info[l_index + 1:r_index].split(",")
        else:
            break
        if temp[0][0:1:] != '0' and temp[1][0:1:] != '0':
            x = int(temp[0])
            y = int(temp[1])
            if 0 < x < 1000 and 0 < y < 1000 and (x ** 2 + y ** 2) > max_dis:
                max_dis = (x ** 2 + y ** 2)
                max_index = "(" + temp[0] + "," + temp[1] + ")"
    return max_index
 
 
if __name__ == "__main__":
    line = input().strip()
    print(func(line))
```

## 火星文计算

```
while 1:
    try:
        nums = input()
        # 无符号数
        index_list = [i for i, c in enumerate(nums) if c in "#$"]
 
        # 按操作符 分隔字符串
        stack = []
        s = 0
        for e in index_list:
            stack.append(int(nums[s:e]))
            stack.append(nums[e])
            s = e + 1
        else:
            stack.append(int(nums[s:]))
 
            # 计算 优先级高的$ f"3*{x}+{y}+2")
            r_stack = []
            while stack:
                item = stack.pop()
                if item == "$":
                    x = stack.pop()
                    y = r_stack.pop()
                    stack.append(eval(f"3*{x}+{y}+2"))
                else:
                    r_stack.append(item)
            stack += r_stack[::-1]
 
            # 计算 2*{x}+3*{y}+4"
            x = stack[0]
            for i in range(2, len(stack), 2):
                y = stack[i]
                x = eval(f"2*{x}+3*{y}+4")
            print(x)
    except Exception as e:
        break
```

## 勾股数元祖

```
n = int(input())
m = int(input())
flag = True
 
 
def isRel(x: int, y: int):
    minNum = min(x, y)
    for i in range(2, minNum + 1):
        if x % i == 0 and y % i == 0:  
            return False
    return True
 
 
for i in range(n, m - 1):
    for j in range(i + 1, m):
        for k in range(j + 1, m + 1):
            if isRel(i, j) and isRel(i, k) and isRel(j, k) and i ** 2 + j ** 2 == k ** 2:
                print(str(i) + ' ' + str(j) + ' ' + str(k))
                flag = False
if flag:
    print("Na")
```

## 计算礼品发放的最小分组数目 

```
value = int(input())
nums = [int(i) for i in input().split(" ")]
nums.sort()
total = len(nums)
right,left = 0,total-1
while left > right:
    if nums[left] + nums[right] >value:
        right -=1
    else:
        totals -=1
        left +=1
        right-=1
print(total)
```

## 喊7的次数重排

```
passTimes = list(map(int, input().split()))
n = len(passTimes)
sumN = sum(passTimes)
res = [0] * n
times = 0
for i in range(1, 200):
    if i % 7 == 0 or str(i).count('7'):
        index = i % n - 1
        res[index] += 1
        times += 1
        if times == sumN:
            break
res = list(map(str, res))
print(' '.join(res))
```

## 整数对最小和 

```
import heapq
 
 
def Func():
    array1 = input().split()
    array2 = input().split()
    k = int(input())
    if len(array1) >= 100 or len(array2) >= 100:
        print("字符串长度超过标准")
    else:
        size1 = min(int(array1[0]), len(array1) - 1)
        size2 = min(int(array2[0]), len(array2) - 1)
        array3 = []
        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                heapq.heappush(array3, [int(array1[i]), int(array2[j])])
        min = 0
        for i in range(k):
            min += sum(array3[i])
        print(min)
 
 
if __name__ == "__main__":
    Func()
```

## 数组拼接 

```
while 1:
    try:
        n = int(input())
 
        nums = [input().split(',') for _ in range(n-1)]
 
        dp = []
        i = 0
        while nums:
            if len(nums[i]) > n:
                temp = nums[i][:n]
                nums[i] = nums[i][n:]
            else:
                temp = nums[i]
                nums.pop(i)
            dp += temp
            i += 1
 
            if i >= len(nums):
                i = 0
 
        print(",".join(dp))
    except Exception as e:
        break
```

## 数字涂色

```
def paint_nums(s):
    arr = [int(x) for x in s.split(" ")]
    arr.sort()
    l = len(arr)
    i = 0
    start = arr[0]
    color = 1
    while arr:
        if i > l - 1:
            i = 0
            color += 1  
            start = arr[i]
        elif arr[i] % start == 0:
            arr.pop(i)
            l -= 1
        else:
            i += 1
    return color
 
 
if __name__ == "__main__":
    print(paint_nums("2 5 4 7 6"))
```

## 分糖果

```
def candy(x: int):
    if x == 2:
        return 1  
    if x % 2 == 0:
        return candy(x // 2) + 1  
    else:
        return min(candy(x + 1) + 1, candy(x - 1) + 1)
 
 
if __name__ == "__main__":
    n = int(input())
    res = candy(n)
    print(res)
```

## 非严格递增连续数字序列

```
s = input()
maxLen = 0
index = 0
while index <= len(s) - 1:
    if s[index].isdigit():  
        lastNum = int(s[index])
        curLen = 1
        for i in range(index + 1, len(s)):
            if s[i].isdigit() and int(s[i]) >= lastNum:
                curLen += 1
                lastNum = int(s[i])
            else:
                index = i - 1
                break
        maxLen = max(maxLen, curLen)
    index += 1
print(maxLen)
```

## 第k个排列

```
import itertools
 
n = int(input())
k = int(input())
res = []
for item in itertools.permutations(range(1, n + 1)):
    s = ''.join(map(str, item))
    res.append(int(s))
res.sort()
print(res[k - 1])
```

##  绘图机器

```
[n, e] = list(map(int, input().split()))
res = currentX = currentY = 0
for _ in range(n):
    [x, offset] = list(map(int, input().split()))
    res += (x - currentX) * abs(currentY)
    currentX = x
    currentY += offset
if currentX < e:
    res += (e - currentX) * abs(currentY)
print(res)
```

## 太阳能板最大面积

```
class Solution:
    def sunboard_area(self, list):
        high = list[0] / 2
        chang = 0
        for i in list[1:]:
            if i < high:
                break
            else:
                chang += 1
        area = chang * high
        print(area)
        return area
 
 
if __name__ == "__main__":
    Solution().sunboard_area([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])
```

## 比赛

```
def compare_score(A, B, score_list):
    scoreA = [ac[A] for ac in score_list]
    scoreB = [ac[B] for ac in score_list]
    scoreA.sort(reverse=True)  
    scoreB.sort(reverse=True)  
    totalA = sum(scoreA)
    totalB = sum(scoreB)
    if totalA > totalB:
        return A
    elif totalA < totalB:
        return B
    else:
        for index in range(int(m)):
            if scoreA[index] - scoreB[index] > 0:
                return A
            elif scoreA[index] - scoreB[index] < 0:
                return B
            else:
                continue
 
 
def check_variable(score_list):
    for li in score_list:
        for l in li:
            if int(l) > 10 or int(l) < 1:
                return False
    return True
 
 
try:
    m, n = input().split(',')
    score_list = []
    flag = 1
    if 2 <= int(m) <= 10 and 3 <= int(n) <= 100:
        for i in range(int(m)):
            score = input().split(',')
            score_list.append([int(s) for s in score])
        flag = check_variable(score_list)  
        if flag:
            namelist = []
            for loop in range(3): 
                A = 0
                for j in range(int(n) - 1):
                    if int(A) + 1 in namelist or j + 2 in namelist:
                        continue
                    big = compare_score(A, j + 1, score_list)
                    A = big
                namelist.append(int(A) + 1)  
            print(','.join(namelist))
        else:
            print(-1)
    else:
        print(-1)
except:
    print(-1)
```

##  停车场车辆统计

```
def Func():
    cars = ("".join(i for i in (input().split(",")))).split("0") 
    # print(cars)
    num = 0 
    for i in cars:
        lennum = (len(i)) 
        if lennum == 0:
            num = num
        elif not lennum % 3 and len != 0:  
            num = num + lennum / 3
        elif lennum % 3:
            num = num + (lennum - lennum % 3) / 3 + 1
    print(int(num))
 
 
if __name__ == "__main__":
    Func()
```

## 连续字母长度

```
if __name__ == "__main__":
    Strs = "ABC"
    k = 2
    index = 0  
    HashMap = dict()
    for i in range(len(Strs)):
        if Strs[i] != Strs[index]: 
            if HashMap.get(Strs[index]) and HashMap.get(Strs[index]) < i - index:
                del HashMap[Strs[index]]  
            HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), i - index)
            index = i
            if index == len(Strs) - 1:  
                HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), 1)
        elif Strs[i] == Strs[index] and i == len(Strs) - 1:  
            HashMap[Strs[index]] = max(HashMap.get(Strs[index], 0), i - index + 1)
    ll = sorted(HashMap.items(), key=lambda x: x[1], reverse=1)
    print(ll[k - 1][1])
```

##  字符串筛选排序

```
s = input()
k = int(input())
sortList = sorted(s)
maxASCII = ''
if k > len(sortList):
    maxASCII = sortList[-1]
else:
    maxASCII = sortList[k - 1]
print(s.index(maxASCII))
```

## 数组去重和排序 

```
class Solution():
    def remove_duplicates_sort(self, arry):
        dict = {}
        for i in arry:
            dict[i] = arry.count(i)
        print(dict)
        dict = sorted(dict.items(), key=lambda x: x[1], reverse=True)
        print(dict)
        arry1 = []
        for i in dict:
            arry1.append(i[0])
        print(arry1)
        return arry1
 
 
if __name__ == "__main__":
    Solution().remove_duplicates_sort([1, 3, 3, 3, 2, 4, 4, 5])
```

##  TLV解析

```
Tag = int(input())  # 待解码信元的tag
Lists = input().split()  # 待解码的16进制码流
 
Tag = 30
Lists = "32 01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC".split()  # tag=0,4,9
q = 0
# print(Lists)
while q < len(Lists):
    NewTag = int(Lists[q])  # 新的信元tag值
    NewLenght = int(Lists[q + 2] + Lists[q + 1], 16)  # 小段序，逆序存储(字符串是可以直接通过+进行连接的)；大端序，正序存储，先计算Lenght长度
    NewValue = Lists[q + 3:q + 3 + NewLenght]  # 统计对应信元的value，因为小短序已经到q+2了，所有value要从q+3开始，对应长度再加NewLenght
    # print(q, NewTag, NewLenght, NewValue)
    if NewTag == Tag:
        print(" ".join(NewValue))
        break
    else:
        q = q + 3 + NewLenght  # 如果没有找到，则跳得写一个信元tag的位置；因为tag长度为1，Lenght长度为2，所以要+3，后面还有对应Lenght长度的Value
```

## 滑动窗口最大值

```
def find_max_window(nums: int, array: list, window_size: int):
 
    if window_size > nums:
        raise ValueError("window size must be less than nums")
    if window_size == nums:
        return sum(array)
    left_point = 0
    right_point = window_size
    max_num = 0
    while right_point <= nums:
        max_num = max(max_num, sum(array[left_point: right_point]))
        left_point += 1
        right_point += 1
    return max_num
```

## 最长连续子序列

```
nums = list(map(int, input().split(',')))
reqSum = int(input())
maxLen = -1
for i in range(len(nums) - 1):
    curLen = -1
    curSum = nums[i]
    if nums[i] == reqSum:
        curLen = 1
        continue
    elif nums[i] > reqSum:
        continue
    for j in range(i + 1, len(nums)):
        if curSum + nums[j] == reqSum:
            curLen = j - i + 1
        elif curSum + nums[j] < reqSum:
            curSum += nums[j]
        else:
            break
    maxLen = max(maxLen, curLen)
print(maxLen)
```

## 最大花费金额

``` import itertools
 
goods = list(map(int, input().split(',')))
maxMoney = int(input())
res = []
for a in itertools.combinations(goods, 3):
    tmp = sum(a)
    if tmp <= maxMoney:
        res.append(tmp)
if len(res) > 0:
    print(max(res))
else:
    print(-1)
```

## 分班问题

```
try:
    s = input().split()
    res = [[], []]
    preFlag = 0  
    for i, child in enumerate(s):
        index, isSame = child.split('/')
        if i == 0:
            res[0].append(index)
        else:
            if isSame == 'N':
                preFlag = int(not preFlag)
            res[preFlag].append(index)
    for i in range(2):
        print(' '.join(sorted(res[i])))
except:
    print("ERROR")
```

## 工号不够用

```
while 1:
    try:
        max_, y = list(map(int, input().split()))
 
        z = 26 ** y
        for i in range(1, 9 - y):
            if z * (10 ** i) >= max_:
                print(i)
                break
 
    except Exception as e:
        break
```

## 靠谱的车

```
n = int(input())
res = n
tmp = t = 0
i = 1
while n > 0:
    if n % 10 > 4:
        tmp += (n % 10 - 1) * t + i
    else:
        tmp += (n % 10) * t
    t = t * 9 + i
    i *= 10
    n = n // 10
print(res - tmp)
```

## 高矮个子排队

```
while 1:
    try:
 
        s = input()
 
        l = list(map(int, s.split(" ")))
        print(l)
 
        ll = l.copy()
        ll.sort(reverse=True)
        print(ll)
        if len(ll) % 2 == 0:
            e = int(len(ll) / 2)
        else:
            e = int(len(ll) / 2) + 1
        print(e)
 
        for i in range(0, len(l), 2):
            if l[i] not in ll[0:e]:
                for j in range(1, len(l), 2):
                    if l[j] in ll[0:e]:
                        tmp = l[i]
                        l[i] = l[j]
                        l[j] = tmp
                        break
        print(" ".join(map(str, l)))
 
        break
 
    except Exception as e:
        print("[]")
        break
```

## 报数游戏

```
m = int(input())
if m <= 1 or m >= 100:
    print("ERROR!")
else:
    a = []
    for i in range(100):
        a.append(i + 1)  
    index = count = 0
    while len(a) >= m:  
        count += 1
        if count == m:  
            a.pop(index)  
            count = 0  
            if index > len(a) - 1:  
                index = 0  
        else:
            if index == len(a) - 1:
                index = 0
            else:
                index += 1
    print(','.join(map(str, a)))
```

## 5键键盘

```
def FiveKeyBoard(s):
    screen = ''
    clip = ''
    selected = False
    for i in s:
        if i == '1' and not selected:  # a
            screen += 'a'
        elif i == '1' and selected:  # a
            screen = 'a'
            selected = False
        elif i == '2' and selected and screen:  
            clip = screen
        elif i == '3' and selected and screen:  
            clip = screen
            screen = ''
            selected = False
        elif i == '4' and selected:  
            screen = clip
            selected = False
        elif i == '4' and not selected:  
            screen += clip
        elif i == '5' and screen: 
            selected = True
    return len(screen)
 
 
if __name__ == "__main__":
    line = str(input().strip())
    print(FiveKeyBoard(line))
```

## 用户调度问题

```
n = int(input())
res = 0
preIndex = -1
for i in range(n):
    times = list(map(int, input().split()))
    minTime = 0
    if preIndex < 0:
        minTime = min(times)
    else:
        tmp = []
        for j, v in enumerate(times):
            if j == preIndex:
                continue
            tmp.append(v)
        minTime = min(tmp)
    preIndex = times.index(minTime)
    res += minTime
print(res)
```

## GPU执行时长

```
n = int(input())
m = int(input())
nums = list(map(int, input().split()))
res = 0
rem = 0
for i in nums:
    res += 1
    if rem + i > n:
        rem = rem + i - n
    else:
        rem = 0
while rem > 0:
    res += 1
    rem -= n
print(res)
```

## 找终点 

```
nums = list(map(int, input().split()))
length = len(nums)
res = []
for i in range(1, length // 2):
    step = 1
    index = i
    while index < length - 1:
        index += nums[index]
        step += 1
    if index == length - 1:
        res.append(step)
if len(res) > 0:
    res.sort()
    print(res[0])
else:
    print(-1)
```

## 单词接龙

```##
class Solution():
    def word_dragon(self, start_index, n, word_list):
        result = word_list[start_index]
        start = word_list[start_index]
        word_list.remove(start)
        next_word = self.next_word(start[-1], word_list)
        while next_word != "":
            result += next_word
            start = next_word
            word_list.remove(next_word)
            next_word = self.next_word(start[-1], word_list)
        print(result)
        return result
 
    def next_word(self, end, word_list):
        list1 = []
        for i in word_list:
            if i[0] == end:
                list1.append(i)
        print(list1)
        if list1 == []:
            longest_word = ""
            return longest_word
        max_length = 0
        longest_word = list1[0]
        for i in list1:
            length = len(i)
            if max_length < length:
                max_length = length
                longest_word = i
            elif max_length == length:
                longest_word = min(i, longest_word)
        print(longest_word)
        return longest_word
 
 
if __name__ == "__main__":
    Solution().word_dragon(0, 6, ["word", "dd", "da", "dc", "dword", "d"])
```

## 最大子矩阵和

```
n,m = map(int,input().strip().split(" "))
#test = ["-3,5,-1,5", "2,4,-2,4", "-1,3,-1,3"]
 
ints = []
for i in range(n):
    hang = list(map(int,input().strip().split(" ")))
    ints.append(hang)
print(ints)
 
max_ = 0
 
for start_row in range(n):
    for start_col in range(m):
        for end_row in range(start_row,n):
            jisuan = 0
            for end_col in range(start_col,m):
                row_index = end_row
                while row_index >= start_row:
                    jisuan +=ints[row_index][end_col]
                    row_index-=1
                max_ = max(max_,jisuan)
print(max_)
```

## 矩阵最大值

```python
nums = []
maxSum = 0
for _ in range(n):
    row = input().split(',')
    nums.append(row)
for row in nums:
    curMax = int(''.join(row), 2)
    for _ in range(n - 1):
        row = list(row[-1]) + row[:-1]
        curMax = max(curMax, int(''.join(row), 2))
    maxSum += curMax
print(maxSum)
```

## 堆栈中的剩余数字

```
if __name__ == "__main__":
    nums = list(map(int, input().split()))
    res = []
    while len(nums) > 0:
        num = nums.pop(0)
        while num > 0:
            l = len(res)
            if l == 0:  # 如果res列表为空，直接入栈
                res.append(num)
                num = 0  # num入栈后清零，退出循环
            else:
                curSum = 0
                flag = True  # 是否找到满足条件的元素
                for i in range(l - 1, -1, -1):
                    curSum += res[i]
                    if curSum == num:  # 找到满足条件的元素
                        res = res[:i]  # 下标i到末尾的元素全部出栈
                        num = num * 2  # 需要入栈的新元素
                        flag = False  # 标志位改变
                        break
                if flag:  # 如果没找到满足条件的元素
                    res.append(num)
                    num = 0  # num入栈后清零，退出循环
    print(' '.join(map(str, reversed(res))))  # 逆序输出
```

## 数组组成的最小数字

```
# -*- coding:utf-8 -*-
class Solution:
     def PrintMinNumber(self, numbers):
         # write code here
         lamb = lambda n1,n2 : int(str(n1)+str(n2))-int(str(n2)+str(n1))
         numbers=sorted(numbers,lamb)
         return ''.join([str(i) for i in numbers])
 
if __name__ == "__main__":
    nums = [0, 2, 4, 1, 6, 44]
    nums.sorted()
    print(nums)
    length = len(nums)
    new_nums = []
    if length < 3:
        new_nums = nums
    else:
        new_nums = nums[0:3]
    Solution().PrintMinNumber(nums[0:3])
```

##  小朋友排队-2

```
H,N = map(int,input().split())
list_H = list(map(int,sorted(input().split())))
diff = []
for i in range(len(list_H)):
    diff.append((list_H[i],abs(H-list_H[i])))
diff = sorted(diff,key=lambda x:(x[1],x[0]))
res = []
for j,k in diff:
    res.append(str(j))
print(" ".join(res))
```

## 字符串压缩

```
def getUnZipStr(zipStr):
    if not zipStr:
        return None
 
    Nums = ""
    NewStr = ""
    for x in zipStr:
        if x.islower():  # 小写字母，压缩后只能是数字和小写字母
            if Nums and Nums != "":
                for i in range(int(Nums)):
                    NewStr += x
                Nums = ""  # 对应nums的x字符已经拼接完成，要置空，也许后面还要使用
            else:
                NewStr += x
        elif x.isdigit():  # 小写字母，压缩后只能是数字和小写字母
            if int(x) <= 2 and Nums == "":  # 只有超过2个相同字母才会压缩，否则报异常
                return None
            Nums = Nums + x  # 有可能第1、2、3...都是数字，需要统计总的数字，先利用字符串拼接，用的时候转换成数字
        else:  # 大写字符，特殊字符等都输出异常
            return None
    return NewStr
 
 
if __name__ == "__main__":
    zipStr = "4dff"
    result = getUnZipStr(zipStr)
    if result:
        print(result)
    else:
        print("!error")
```

## 字符串分割

```
# k = int(input().strip())
# str = input().strip()
k=3
str = "12abc-abCABc-4aB@"
str_list = str.split("-")
res = [str_list[0]]
new_str = "".join(str_list[1:])
 
for i in range(0,len(new_str),k):
    temp = new_str[i:i+k]
    upper_num = 0
    lower_num = 0
    for j in temp:
        if j.isupper():
            upper_num+=1
        elif j.islower():
            lower_num +=1
    if upper_num <lower_num:
        temp = temp.lower()
    elif upper_num >lower_num:
        temp = temp.upper()
    res.append(temp)
print("-".join(res))
```

## 消消乐游戏

````
inputStr = input()
line = []
for item in inputStr:
    if len(line) == 0:
        line.append(item)
    elif item == line[-1]:
        line.pop()
    else:
        line.append(item)
if inputStr.isalpha():
    print(len(line))
else:
    print(0)
````

## 最大括号深度

```
while 1:
    try:
        nums = input()
        max_ = 0
        stack = []
        for c in nums:
            if c in "{[(":
                stack.append(c)
            else:
                if not stack:
                    print(0)
                    break
                max_ = max(max_, len(stack))
                cr = stack.pop()
                if f"{cr}{c}" not in ["{}", "[]", "()"]:
                    print(0)
                    break
        else:
            print(max_)
    except Exception as e:
        break
```

## 表达式括号匹配

```
str= ")(1+(2+3)*(3+(8+0))+1-2)"
stack = []
num = 0
for i in str:
    if i =="(":
        stack.append(i)
    elif i ==")" :
        if stack==[]:
            num = -1
            break
        else:
            temp = stack.pop(-1)
            if temp !="(":
                num = -1
                break
            elif temp == "(":
                num+=1
print(num)
```

## 求字符串中所有整数的最小和

```
s = input()
res = 0
flag = False  
num = ""  
for c in s:
    if c.isdigit():
        if flag:
            num += c
        else:
            res += int(c)
    elif c == '-':
        if flag and len(num) > 0:
            res -= int(num)
            num = ""
        flag = True
    else:
        if flag and len(num) > 0:
            res -= int(num)
            num = ""
        flag = False
if flag and len(num) > 0:
    res -= int(num)
print(res)
```

## VLAN资源池

```
pools = input().split(',')
req = int(input())
res = []
resStr = []
for pool in pools:
    poolIDs = list(map(int, pool.split('-')))
    if len(poolIDs) == 1:
        if poolIDs[0] != req:
            res.append(poolIDs[0])
    else:
        sta = poolIDs[0]
        end = poolIDs[1]
        for i in range(sta, end + 1):
            if i == req:
                continue
            res.append(i)
res.sort()
# print(res)
sta = end = res[0]
for i in range(1, len(res)):
    if res[i] == end + 1:
        end = res[i]
    else:
        if sta == end:
            resStr.append(str(sta))
        else:
            resStr.append(str(sta) + '-' + str(end))
        sta = end = res[i]
if sta == end:
    resStr.append(str(sta))
else:
    resStr.append(str(sta) + '-' + str(end))
print(','.join(resStr))
```

## 篮球比赛 

```
def basketball(s):
    from itertools import combinations
    a1 = [int(x) for x in str(s).split(" ")]
    a2 = list(combinations(a1, len(a1) // 2)) 
    min_diff = abs(sum(a1) - 2 * sum(a2[0]))
    for arr in a2:
        if abs(sum(a1) - 2 * sum(arr)) < min_diff:
            min_diff = abs(sum(a1) - 2 * sum(arr))
    return min_diff
 
 
print(basketball("10 9 8 7 6 5 4 3 2 1"))
```

## 翻牌求最大分

```
n= "1,-5,-6,4,7,2,-2"
if  __name__ == '__main__':
    n = list(map(int,n.split(",")))
    if sum(n[:3])<0:
        num=0
    else:
        num=sum(n[:3])
    for i in range(3,len(n)):
        tmp=num+n[i]
        if tmp>num:
            num=tmp
    print(num)
```

# 数组连续和 

```
total = 10000
n = 10 
 
nums= [1,2,3,4,5,6,7,8,9,10]
count = 0
res = 0
for i in range(n):
    count = nums[i]
    if count >total:
        res+=n-i
        break
    for j in range(i+1,n):
        count+=nums[j]
        if count>=total:
            res+=n-j
            break
print(res)
```

##  we are a team

```
class Node:
    def __init__(self, n):
        self.parent = list(range(n + 1))
 
    def get_root(self, i):  
        while i != self.parent[i]:
            i = self.parent[i]
        return i
 
 
def one_team(self, i, j):  
    return self.get_root(i) == self.get_root(j)
 
 
def union(self, i, j):  
    i_root = self.get_root(i)
    j_root = self.get_root(j)
    self.parent[i_root] = j_root
 
 
while True:
    try:
        m, n = map(int, input().split())
        team = Node(m)
        if m < 1 or m > 100000 or n < 1 or n > 100000:
            print("NULL")
            break
        for i in range(n):
            x, y, c = map(int, input().split())
            # uinion a, b in one team
            if x < 1 or x > m or y < 1 or y > m:
                print("da pian zi")
                continue
            if c == 0:
                team.union(x, y)
            elif c == 1:
                ret = team.one_team(x, y)
                if ret == True:
                    print("We are a team")
                else:
                    print("We are not a team")
            else:
                print("da pian zi")
    except:
        break
```

## 矩形相交的面积

```
while 1:
    try:
        xs = []
        ys = []
 
        nums = []
        for _ in range(3):
            x1, y1, w, h = list(map(int, input().split()))
            x2 = x1 + w
            y2 = y1 - h
            xs += [x1, x2]
            ys += [y1, y2]
            nums.append((x1, y1, x2, y2))
 
        min_x, max_x = min(xs), max(xs)
        min_y, max_y = min(ys), max(ys)
 
        x = 0 - min_x
        y = 0 - min_y
        dp = [[0] * abs(max_y-min_y) for _ in range(abs(max_x-min_x))]
 
        for x1, y1, x2, y2 in nums:
            for i in range(min((x2, x1)) + x, max((x2, x1)) + x):
                for j in range(min((y2, y1)) + y, max((y2, y1)) + y):
                    dp[i][j] += 1
 
        ret = 0
        for i in range(len(dp)):
            for j in range(len(dp[0])):
                if dp[i][j] == 3:
                    ret += 1
        print(ret)
    except Exception as e:
        break
```

## ipv4地址转换成整数

```
while 1:
    try:
        nums = list(map(int, input().split("#")))
        if len(nums) != 4:
            print("invalid IP")
        else:
            dp = ""
            for i in range(4):
                if not ((i == 0 and 1 <= nums[i] <= 128) or (i > 0 and 0 <= nums[i] <= 255)):
                    print("invalid IP")
                    break
                dp += bin(nums[i])[2:].zfill(8)
            else:
                print(int(dp, 2))
    except Exception as e:
        break
        
```

## 最少交换次数

```
while 1:
    try:
        nums = list(map(int, input().split()))
        k = int(input())
 
        for i in range(len(nums)):
            if nums[i] < k:
                nums[i] = 1
            else:
                nums[i] = 0
 
        n = len(nums)
        m = sum(nums)
 
        dp = []
        for i in range(n):
            dp.append(sum(nums[i: i + m]))
 
        print(m - max(dp))
    except Exception as e:
        break
```

## 敏感字段加密

```
if __name__ == "__main__":
    while 1:
        try:
            k = int(input())
 
            nums = input()
 
            dp = []
 
            temp = ""
            for c in nums:
                if c == "_":
                    if '"' not in temp and temp:
                        dp.append(temp)
                        temp = ""
                    elif '"' in temp:
                        temp += c
                elif c == '"':
                    if temp and '"' in temp:
                        temp += c
                        dp.append(temp)
                        temp = ""
                    elif temp and '"' not in temp:
                        dp.append(temp)
                        temp = c
                    elif not temp:
                        temp = c
                else:
                    temp += c
            if temp:
                dp.append(temp)
 
            if k < len(dp):
                dp[k] = "*" * 6
                print("_".join(dp))
            else:
                print("ERROR")
        except Exception as e:
            break
```

## 补种未成活胡杨

while 1:
    try:
        n = int(input())
        m = int(input())
        nums = list(map(int, input().split()))
        k = int(input())

        nums = [0 if i + 1 in nums else 1 for i in range(n)]
     
        max_ = 0
        i = 0
        j = min(k, n)
        while j < len(nums):
            count = nums[i:j].count(0)
            if count < k:
                j += 1
            elif count == k:
                max_ = max([j - i, max_])
                j += 1
            else:
                i += 1
        else:
            max_ = max([j - i, max_])
     
        print(max_)
    except Exception as e:
        break

## 跳格子

```
while 1:
    try:
        n = int(input())
 
        nums = []
        for _ in range(n):
            x = input().split()
            if x and len(x) == 2:
                nums.append(tuple(map(int, x)))
            else:
                break
 
        nums = sorted(nums, key=lambda x: x[0])
 
        state = [1] * n
        for start, end in nums:
            state[end] = 0
 
        if max(state) == 0:
            print("no")
            continue
 
        dp = [0]
 
 
        def dfs(s, link):
            if len(link) == len(nums) and sorted(link, key=lambda x: x[0]) == nums:
                dp.append(1)
                return
 
            ends = []
            for start_, end_ in nums:
                if s == start_:
                    link.append((start_, end_))
                    ends.append(end_)
 
            for end_ in ends:
                dfs(end_, link)
 
 
        for i in range(n):
            if state[i] == 1:
                dfs(i, [])
 
        if max(dp):
            print("yes")
        else:
            print("no")
 
    except Exception as e:
        break
```

## 图像物体的边界

```
def edges(grid, row, col):
    def dfs(grid, i, j):
        grid[i][j] = 6
        for x in range(i - 3, i + 4):
            for y in range(j - 3, j + 4):
                if x < 0 or y < 0 or x >= row or y >= col:
                    continue
 
                if grid[x][y] == 5:
                    dfs(grid, x, y)
 
    res = 0
    for i in range(row):
        for j in range(col):
            if grid[i][j] == 5:
                res += 1
                dfs(grid, i, j)
 
    return res
 
 
if __name__ == '__main__':
    row, col = 20, 20
     grid = [[1, 1, 1, 1, 1, 1,],
             [1, 5, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 1,],
             [1, 1, 1, 1, 1, 5,] ]
 
 
    res = edges(grid, row, col)
    print(res)
```

##  lisp运输

```
def lisp(string_words):
    string_words = string_words.split()
    if string_words[0] == "add":
        del string_words[0]
        return sum([int(i) for i in string_words])
    if string_words[0] == "sub":
        return int(string_words[1]) - int(string_words[2])
    if string_words[0] == "mul":
        result = 1
        for i in range(1, len(string_words)):
            result *= int(string_words[i])
        return result
    if string_words[0] == "div":
        if string_words[2] == "0":
            return "error"
        else:
            return round(int(string_words[1]) // int(string_words[2]))
n = input()
while "(" in n:
    k = ''.join(n[::-1].split("(")[0])[::-1].split((")"))[0]
    n = n.replace(f'({k})', str(lisp(k)))
print(n)
```

## 导师火锅

```
n, m = map(int, input().split())
d = set()
for i in range(n):
    d.add(sum(map(int, input().split())))
l = sorted(list(d))
count = 1
t = 0
for i in range(1, len(l)):
    if l[i] - l[t] >= m:
        count += 1
        t = i
print(count)
```

## 面试

```\
while 1:
    try:
        n = int(input())
 
        nums = []
        for _ in range(n):
            nums.append(list(map(int, input().split())))
 
        nums = sorted(nums, key=lambda x: x[0])
        max_ = max([e for s, e in nums])
 
        dp = [0] * (max_+1)
 
        for s, e in nums:
            for i in range(s, e+1):
                dp[i] += 1
 
        print(max(dp))
    except Exception as e:
        break
 
nums = [[1,2],[2,3],[3,4],[4,5],[5,6]]
nums = sorted(nums, key=lambda x: x[0])
max_ = max([e for s, e in nums])
dp = [0] * (max_ + 1)
for s, e in nums:
    for i in range(s, e + 1):
        dp[i] += 1
print(max(dp))
```

## 分糖果

```
n = int(input())
a = [int(x) for x in input().split()]
sums = 0
for x in a:
    sums = sums ^ x
if sums != 0:
    print('NO')
else:
    print(sum(a) - min(a))
```

## 斗地主之顺子

```
s1 = "2 9 J 2 3 4 K A 7 9 A 5 6"
s_dic = {3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0}
s_list = [0,0,0,0,0,0,0,0,0,0,0,0]
new_s = []
for i in s1.split(" "):
    if i !="2":
        if i == "J":
            s_dic[11] = s_dic[11]+1
            new_s.append(11)
            s_list[8] = s_list[8]+1
        elif i == "Q":
            new_s.append(12)
            s_dic[11] = s_dic[11] + 1
            s_list[9] = s_list[9] + 1
        elif i == "K":
            new_s.append(13)
            s_list[10] = s_list[10]+1
        elif i == "A":
            new_s.append(14)
            s_dic[11] = s_dic[11] + 1
            s_list[11] = s_list[11] + 1
        else:
            new_s.append(int(i))
            s_dic[int(i)] = s_dic[int(i)] + 1
            s_list[int(i)-3] = s_list[int(i)-3] + 1
print(new_s)
 
 
new_s.sort()
print(new_s)
print(s_list)
temp = []
res = []
for i in range(len(s_list)):
    if s_list[i] !=0:
        if i+3 == 11:
            temp.append("J")
        elif i+3 == 12:
            temp.append("Q")
        elif i + 3 == 13:
            temp.append("K")
        elif i + 3 == 14:
            temp.append("A")
        else:
            temp.append(i+3)
    else:
        if len(temp)>=5:
            res.append(temp)
        temp = []
if len(temp)>=5:
    res.append(temp)
if res !=[]:
    print(res)
else:
    print("No")
```

## 字符串比较

```
s1 = "xxcdefg"
s2 = "cdefghi"
v = 5
size = len(s1)
res = []
for i in range(size):
    sum = abs(ord(s1[i]) - ord(s2[i]))
    if sum <v:
        for j in range(i+1,size):
            sum +=abs(ord(s1[j]) - ord(s2[j]))
            if sum>v:
                res.append(j-i)
                break
        if sum <v:
            res.append(j - i+1)
    elif sum == v:
        res.append(1)
    else:
        res.append(0)
print(res)
```

## 报文解压缩

```
class Solution:
    def decodeString(self, s: str) -> str:
        stack, a, n = [['', 1, '']], '', ''
        for c in s:
            if c.isalpha():
                a += c
            elif c.isdigit():
                n += c
            elif c == '[':
                stack.append([a, int(n), ''])
                a = n = ''
            else:
                p, t, b = stack.pop()
                stack[-1][-1] += p + t * (b + a)
                a = ''
        return stack.pop()[-1] + a
 
 
if __name__ == "__main__":
    input_str = str(input().strip())
    function = Solution()
    results = function.decodeString(input_str)
    print(results)
```

## 污染水域

```
nums = [1,0,1,0,0,0,1,0,1]
length = int(len(nums)**0.5)
grids = []
queue=[]
for i in range(0,len(nums),3):
    grids.append(nums[i:i+3])
for i in range(length):
    for j in range (length):
        if grids[i][j] == 1:
            queue.append([i,j])
time =-1
while queue:
    len1 = len(queue)
    for _ in range(len1):
        x, y = queue.pop(0)
        for i,j in [(1,0),(0,-1),(-1,0),(0,1)]:
            temp_x = x + i
            temp_y = y + j
            if temp_x>=0 and temp_x <length and temp_y>=0 and temp_y <length and grids[temp_x][temp_y] == 0:
                grids[temp_x][temp_y] = 1
                queue.append([temp_x,temp_y])
    time +=1
for i in grids:
    if 0 in i:
        print(-1)
        break
else:
    print(time)
```

## 连续出牌数量

```
a = input().split()
b = input().split()
 
t_list = {}
for i in range(len(a)):
    if a[i] not in t_list.keys():
        t_list[a[i]] = {}
    t_list[a[i]][i] = b[i]
    if b[i] not in t_list.keys():
        t_list[b[i]] = {}
    t_list[b[i]][i] = a[i]
 
num_list = []
 
max_list = []
 
def dfs(num):
    if num in num_list:
        return
    num_list.append(num)
 
    for i in [a[num], b[num]]:
        v = t_list[i]
        for k1, v1 in v.items():
            dfs(k1)
        max_list.append(len(num_list))
    num_list.pop()
 
 
for i in range(len(a)):
    dfs(i)
print(max(max_list))
```

## 区间交集

```
import sys
 
arr = []
for line in sys.stdin.readlines():
    if line == '\n':
        break
    arr.append(list(map(int, line.split(' '))))
if len(arr) == 1:
    print(arr[0])
arr.sort(key=lambda x: x[0])
comm_section = []
for i in range(len(arr) - 1):
    for j in range(i + 1, len(arr)):
        if arr[i][-1] >= arr[j][0]:
            comm_section.append([arr[j][0], min(arr[i][-1], arr[j][-1])])
            if len(comm_section) == 1:
                print(comm_section)
comm_section.sort(key=lambda x: x[0])
l = len(comm_section)
i = 0
while i <= l - 2:
    if comm_section[i][-1] > comm_section[i + 1][0]:
        comm_section[i][-1] = max(comm_section[i][-1], comm_section[i + 1][-1])
        comm_section.pop(i + 1)
        l -= 1
    else:
        i += 1
    print(comm_section)
```

## 最大平分数组

```
def can_partition_ksubsets(nums, k, total):
 
    if total % k > 0:
        return False
    per = total / k
    nums.sort()
    if nums[-1] > per:
        return False
    length = len(nums)
    dp = [False for i in range(1<<length)]
    cur_sum = [0 for i in range(1<<length)]
    dp[0] = True
    for i in range(1<<length):
        if not dp[i]:
            continue
        for j in range(length):
            if cur_sum[i] + nums[j] > per :
                break
            if ((i >> j) & 1) == 0:
                next = i | (1 << j)
                if not dp[next]:
                    cur_sum[next] = (cur_sum[i] + nums[j]) % per
                    dp[next] = True
    return dp[(1 << length) - 1]
 
 
def main():
    #处理输入
    # m = int(input().strip())
    # nums = map(int,input().strip().split(" "))
    m = 7
    nums = [4,3,2,3,5,2,1]
    m = 9
    nums = [5, 2 ,1, 5, 2 ,1, 5 ,2 ,1]
    total = sum(nums)
    #最大可以等分为m个子数组
    for i in range(m,1,-1):
        #从最大的可能行开始, 满足条件即输出
        if can_partition_ksubsets(nums, i, total):
            print(i)
            break
    return 0
main()
```

## 探索地块建立

```
import sys
def maxSideLength(mat, threshold, c):
    m, n = len(mat), len(mat[0])
    P = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + mat[i - 1][j - 1]
 
    ans = 0
    # print (P)
    # 2、遍历前缀和矩阵，获得边长等于c的矩阵
    for i in range(c, m + 1):
        for j in range(c, n + 1):
            # 重点理解：减去点[i-c][j]和点[i][j-c]的矩阵前缀和，剩下来的为一个边长为c正方形，注意点[i-c][j-c]减了两次，需要加一个回来
            if P[i][j] - P[i - c][j] - P[i][j - c] + P[i - c][j - c] >= threshold:
                ans += 1
 
    return ans
 
 
# 处理输入
# print ( input())
 
input_params = [int(x) for x in input().split(" ")]
n = input_params[0]
m = input_params[1]
c = input_params[2]
k = input_params[3]
 
matrix = []
for i in range(n):
    matrix.append([int(x) for x in input().split(" ")])
 
print(maxSideLength(matrix, k, c))
```

## 最长的密码

```
import sys
def solution_01():
    # 处理输入
    pwd_list = input().split(" ")
 
    valid_pwd_list = []  # 定义变量,存储合法的密码
    for pwd in pwd_list:
        flag = True  # 定义flag, 表示当前密码依次去掉一个字符后是否都在pwd_list中
        # 当前密码依次去除一个字符
        for i in range(len(pwd) - 1, 0, -1):
            if pwd[: i] not in pwd_list:
                flag = False
                break
        if flag:
            valid_pwd_list.append(pwd)
 
    valid_pwd_list.sort(reverse=True)
 
    return valid_pwd_list[0] if len(valid_pwd_list) != 0 else ""
 
 
if __name__ == '__main__':
    ans = solution_01()
    print(ans)
```

## 计算数组中心位置

```
import sys
# 计算num_list的乘积
def calc_pd(num_list):
    pd = 1
    for num in num_list:
        pd *= num
 
    return pd
 
 
def Solution():
    # 处理输入
    num_list = input().split(" ")
    num_list = [int(num) for num in num_list]
 
    ans = -1
    for i in range(0, len(num_list)):
        if i == 0:
            l_pd = 1
            r_pd = calc_pd(num_list[1:])
        elif i == len(num_list) - 1:
            l_pd = calc_pd(num_list[0: -1])
            r_pd = 1
        else:
            l_pd = calc_pd(num_list[0: i])
            r_pd = calc_pd(num_list[i + 1:])
        if l_pd == r_pd and ans == -1:
            ans = i
 
    return ans
 
 
if __name__ == '__main__':
    ans = Solution()
    print(ans)
```

## 积木最远距离

```
count = int(input())
blocks = {}
for i in range(count):
    num = int(input())
    if num in blocks:
        blocks[num].append(i)
    else:
        blocks[num] = [i]
 
max_distance = -1
for block_num in blocks:
    if len(blocks[block_num]) > 1:
        max_distance = max(max_distance, max(blocks[block_num]) - min(blocks[block_num]));
 
print(max_distance)
```

## 打印机队列

```
import functools
from collections import defaultdict
targs_dict = defaultdict(list)
# total = 7
total = int(input().strip())

count = 0
def comp(x,y):
    if x[0] ==y[0]:
        if x[1] < y[1]:
            return -1
        else:
            return 1
    if x[0] < y[0]:
        return 1
    else:
        return -1
for i in range(total):
    temp_msg = input().strip().split(" ")
    # temp_msg = msg_list[i]
    if temp_msg[0] =="IN":
        count+=1
        temp_key = int(temp_msg[1])
        temp_value = (int(temp_msg[2]),count)
        targs_dict[temp_key].append(temp_value)
    else:
        # print(targs_dict)
        temp_key = int(temp_msg[1])
        temp_targs = targs_dict[temp_key]
        if temp_targs == []:
            print("NULL")
        else:
            temp_targs.sort(key=functools.cmp_to_key(comp))
            print(temp_targs[0][1])
            # print(temp_targs)
            targs_dict[temp_key] = temp_targs[1:]
```

## 模拟商场优惠打折

```
#先满减后打折
def mode_a(price,m,n):
    count = 0
    while m>0:
        if price < 100:
            break
        price -= (price // 100 * 10)
        count += 1
        m-=1
    price *= 0.92
    count +=1
    return (price, count)
 
#先打折后满减
def mode_b(price, m, n):
 
    count = 0;
    price *= 0.92
    count +=1
    while m>0 :
        if price < 100:
            break
        price -= (price // 100 * 10)
        count += 1
        m -= 1
    return (price, count)
 
 
#先满减后无门槛
def mode_c(price, m, k):
 
    count = 0
    while m>0 :
        if price < 100:
            break
        price -= (price // 100 * 10)
        count += 1
        m -= 1
 
    for i in range(k):
        price -= 5
        count +=1
        if price < 0:
            break
    return (price, count)
 
# 先打折后无门槛
def mode_d(price, n, k):
 
    count = 0
    price *= 0.92
    count += 1;
    for i in range(k):
        price -= 5
        count +=1
        if price < 0:
            break
    return (price, count)
 
def main():
    params = [3,2,5]
    m,n,k = 3,2,5
    # nums = int(input().strip())
    nums= 3
    prices=[100,200,400]
    for i in range(nums):
        res = []
        # price = int(input().strip())
        price = prices[i]
        res.append(mode_a(price, m, n))
        res.append(mode_b(price, m, n))
        res.append(mode_c(price, m, k))
        res.append(mode_d(price, n, k))
 
        #按照价格降序，用券数降序排序
        res.sort(key=lambda x: (x[0], x[1]))
        print(res[0])
main()
```

## 羊、狼、农夫过河

```
input_nums = [int(x) for x in input().split(" ")]
M = input_nums[0]
N = input_nums[1]
X = input_nums[2]
 
min_times = (M + N) * X
 
 
# m0, n0 分别表示剩余的羊、狼个数， x为船容量
# m1, n1 分别表示运输到对岸的羊、狼个数，times为次数
def transport(m0, n0, x, m1, n1, times):
    global min_times
    # 若可以一次性运走，结束了，注意等于号。。。
    if x >= m0 + n0:
        if times + 1 < min_times:
            min_times = times + 1
        return times + 1
 
    # 尝试运一部分狼一部分羊
    # 要上船的羊数量不可以超过岸上数量、也不可以超过船的容量
    for i in range(m0):
        if i > x:
            break
        # 要上船的狼的数量不可以超过岸上数量、也不可以超过船装了羊后的剩余的容量
        for j in range(n0):
            if i + j > x:
                break
            # 不可以不运
            if i + j == 0:
                continue
 
            # 船离岸后，原来这岸，要么没有羊，要么羊比狼多，才可以运；对岸也要检查，不考虑回程带动物
            if (m0 - i == 0 or m0 - i > n0 - j) and (m1 + i == 0 or m1 + i > n1 + j):
                # 运一次
                result = transport(m0 - i, n0 - j, x, m1 + i, n1 + j, times + 1)
                # 如果获取了结果，和minTime比较，但是不结束，继续检查
                if result < min_times and result != 0:
                    min_times = result
 
    # 没有方案...返回0
    return 0
 
 
# 表示已运输到对岸的羊、狼个数
m_temp = 0
n_temp = 0
 
transport(M, N, X, m_temp, n_temp, 0)
 
if min_times == (M + N) * X:
    print(0)
else:
    print(min_times)
```

## 真正的密码

```
# 处理输入
input_strs = input().split(" ")
# 将所有字符串放入哈希集合
word_set = set()
for single_str in input_strs:
    word_set.add(single_str)
# 真正的密码
true_pass_word = ""
 
# 按顺序检查每一个词
for single_str in input_strs:
    # 条件1：检查这个词所有以索引0开头的子串在数组中是否都有
    flag = True
    for i in range(1, len(single_str)):
        # 以索引0开头的子串
        sub_str = single_str[0:i]
        if sub_str not in word_set:
            flag = False
            break
 
    if flag:
        # 条件2：比较密码长度
        if len(single_str) > len(true_pass_word):
            true_pass_word = single_str
        # 条件3：比较密码字典排序
        if len(single_str) == len(true_pass_word) and single_str > true_pass_word:
            true_pass_word = single_str
 
print(true_pass_word)
```

# 过滤组合字符串

```
import copy
 
# 保存排列组合字符串
res_str_list = []
 
# 预设值
num_char_map = {'0': "abc", '1': "def", '2': "ghi", '3': "jkl", '4': "mno", '5': "pqr", '6': "st", '7': "uv", '8': "wx",
                '9': "yz"}
 
 
# 递归求排列组合
def dfs(num_str, temp_list, index):
    if index == len(num_str):
        res_str_list.append("".join(temp_list))
        return
    temp_list_back_up = copy.copy(temp_list)
    for single_char in num_char_map[num_str[index]]:
        temp_list.append(single_char)
        dfs(num_str, temp_list, index + 1)
        temp_list.pop()
 
 
# 处理输入
num_str = input()
block_str = input()
dfs(num_str, [], 0)
 
# 过滤
for single_str in res_str_list:
    if block_str in single_str:
        res_str_list.remove(single_str)
 
print(res_str_list)
```

## 等和子数组最小和

```
import functools
 
 
def canPartitionKSubsets(nums, k):
    all = sum(nums)
    if all % k:
        return False
    per = all // k
    nums.sort()
    if nums[-1] > per:
        return False
    n = len(nums)
    dp = [False] * (1 << n)
    dp[0] = True
    cursum = [0] * (1 << n)
    for i in range(0, 1 << n):
        if not dp[i]:
            continue
        for j in range(n):
            if cursum[i] + nums[j] > per:
                break
            if (i >> j & 1) == 0:
                next = i | (1 << j)
                if not dp[next]:
                    cursum[next] = (cursum[i] + nums[j]) % per
                    dp[next] = True
    return dp[(1 << n) - 1]
 
 
# 处理输入
n = int(input())
nums = [int(x) for x in input().split(" ")]
 
for i in reversed(range(n + 1)):
    # 从最大的可能行开始，满足条件即为为最小的情况
    if (canPartitionKSubsets(nums, i)):
        print(sum(nums) / i)
        break;
```

## 租车骑绿岛

```
input_param = [int(x) for x in input().split(" ")]
m = input_param[0]
n = input_param[0]
weights = [int(x) for x in input().split(" ")]
 
# 第一步，单词内部调整
ordered_weights = sorted(weights, reverse=False)
 
min_bikes = 0
temp_weight = 0
for i in ordered_weights:
    if temp_weight <= m <= temp_weight + ordered_weights[i]:
        min_bikes += 1
        temp_weight = ordered_weights[i]
    else:
        temp_weight += ordered_weights[i]
print(min_bikes)
```

# 最多颜色的车辆

```
cars = [int(x) for x in input().split(" ")]
window_size = int(input())
 
car_count = [0, 0, 0]
# 初始化滑动窗口
for i in range(window_size):
    car_count[cars[i]] += 1
 
# 滑动窗口向前滑
max_res = max(max(car_count[0], car_count[1]), car_count[2])
for i in range(window_size, len(cars)):
    car_count[cars[i]] += 1
    car_count[cars[i - window_size]] -= 1
    max_res = max(max_res, max(max(car_count[0], car_count[1]), car_count[2]))
print(max_res)
```

## 完美走位

```
# 处理输入
input_str = input()
 
char_count = {'W': 0, 'A': 0, 'S': 0, 'D': 0}
 
# 频次统计
for single_char in input_str:
    char_count[single_char] += 1
 
# 特殊情况
if char_count['W'] == char_count['A'] and \
        char_count['W'] == char_count['S'] and \
        char_count['W'] == char_count['D']:
    print(0)
else:
    # 左右区间位置
    left = 0
    right = 0
    length = 0
 
    # 替换的最小长度
    res = len(input_str)
    # 出现次数最多的字母
    max_char_num = 0
    # 可替换字母个数, 随着指针移动，如果free_char_num 大于0且能被4整除，当前范围满足条件，左指针右移一格，否则右指针右移
    free_char_num = 0
 
    char_count[input_str[0]] -= 1
    while True:
        max_char_num = max(max((max(char_count['W'], char_count['S'])), char_count['A']), char_count['D']);
        length = right - left + 1
        free_char_num = length - ((max_char_num - char_count['W']) + (max_char_num - char_count['S']) + (
                max_char_num - char_count['A']) + (max_char_num - char_count['D']));
        if free_char_num >= 0 and free_char_num % 4 == 0:
            if length < res:
                res = length
 
            char_count[input_str[left]] += 1
            left += 1
 
        else:
            right += 1
            char_count[input_str[right]] -= 1
 
        if right >= len(input_str) - 1:  # 越界即结束
            break
 
    print(res)
```

## 字符串子序列II

```
a = input().strip()
b = input().strip()
 
j = len(b) - 1
ok = True
for i in range(len(a) - 1, -1, -1):
    if j == -1:
        print(-1)
        exit(0)
    find = False
    for k in range(j, -1, -1):
        if a[i] == b[k]:
            j = k - 1
            find = True
            break
    if not find:
        ok = False
if not ok:
    print(-1)
else:
    print(j + 1)
```

## 事件推送

```
m, n, r = map(int, input().split())
numsA = list(map(int, input().split()))
numsB = list(map(int, input().split()))
for ai in numsA:
    for bj in numsB:
        if ai <= bj and bj - ai <= r:
            print(ai, bj)
            break
```

## 最大股票收益

```
def to_rmb(n):
    if n[-1] == "Y":
        return int(n[:-1])
    else:
        return int(n[:-1]) * 7
 
 
while 1:
    try:
        nums = list(map(to_rmb, input().split()))
 
        if not nums:
            print(0)
            break
 
        dp = []
        # 最大收益
        max_ = 0
        # 当前最小值
        min_ = nums[0]
        before_ = nums[0]
        for c in nums:
            if before_ > c:
                dp.append(max_)
                min_ = c
                max_ = 0
            else:
                min_ = min(min_, c)
                max_ = max(max_, c - min_)
            before_ = c
 
        dp.append(max_)
        print(sum(dp))
    except Exception as e:
        break
```

## 统计射击比赛成绩

while 1:
    try:
        n = int(input())
        ids = input().split(",")
        nums = list(map(int, input().split(",")))

        # 记录用户成绩
        dct = {}
        for i in range(n):
            if ids[i] in dct:
                dct[ids[i]].append(nums[i])
            else:
                dct[ids[i]] = [nums[i]]
     
        # 剔除长度小于3的用户
        for k, v in dct.items():
            if len(v) < 3:
                dct.pop(k)
            else:
                v.sort(reverse=True)
                dct[k] = sum(v[:3])
     
        ret = sorted(dct.items(), key=lambda x: (x[1], x[0]), reverse=True)
        print(",".join([id_ for id_, v in ret]))
    except Exception as e:
        break

## 流水线

```
m, n = map(int, input().split())
workTimes = list(map(int, input().split()))
workTimes.sort()
res = []
if n <= m:
    res = workTimes
else:
    res = workTimes[:m]  
    for i in range(m, n):
        minTime = min(res)  
        index = res.index(minTime)  
        res[index] += workTimes[i]  
print(max(res))
```

## 最长广播效应

```
n = 5
t = 7
link_list = [[2,1],[1,4],[2,4],[2,3],[3,4],[3,5],[4,5]]
def bfs():
    queue = [2] #添加起点值
    queue1 = []
    visited = [2]#讲起点值放入已访问列表，防止重复计算
    a= 0
    while queue:
        m = queue.pop(0)
        for k,v in  enumerate(link_list):
            non_m = v[0] if m!=v[0] else v[1]
            if m in v and non_m not in visited:
                visited.append(non_m)
                queue1.append(non_m)
                link_list.pop(k)
        if len(queue1)>0:
            a+=1
            queue = queue1
            queue1 = []
    return a*2
print(bfs())
```

## 考古问题

```
while 1:
    try:
        chars = input().split()
 
        dp = []
 
        def dfs(sub):
            if len(sub) == len(chars):
                t = "".join(sub)
                if t not in dp:
                    dp.append(t)
            else:
                for c in chars:
                    if c not in sub:
                        dfs(sub + [c])
 
        for c in chars:
            dfs([c])
 
        print(" ".join(dp))
    except Exception as e:
        break
```

## 贪吃蛇

```
steps = input().split(" ")
MN = input().split(" ")
M = int(MN[0])
N = int(MN[1])
import sys
 
arr = []  
first = []  
for i in range(M):
    line = sys.stdin.readline().strip().split()
    arr.append(line)
print(arr)
for i in range(N):
    for j in range(N):
        if arr[i][j] == "H":
            first.append(i)
            first.append(j)
print(first)
direction = {
    'U': [-1, 0],
    'D': [1, 0],
    'L': [0, -1],
    'R': [0, 1],
}
goStep = [0, -1]
snake = []
for s in range(len(steps)):
    item = steps[s]
    if item == 'G':  
        step = [first[0] + goStep[0], first[1] + goStep[1]]  
        if step[0] < 0 or step[1] < 0 or step[0] >= N or step[1] >= M:  
            break
        stepStr = arr[step[0]][step[1]]  
        if stepStr == "F":  
            arr[first[0]][first[1]] = "S"  
            arr[step[0]][step[1]] = "H" 
            snake.insert(0, first) 
            first = step
        else: 
            length = len(snake)
            if length > 0:  
                tail = snake[length - 1]  
                arr[tail[0]][tail[1]] = "E"  
                snake.pop()
                arr[first[0]][first[1]] = "H"  
                snake.insert(0, first)
            else:
                arr[first[0]][first[1]] = "E"
            if stepStr == "S":
                break
            arr[step[0]][step[1]] = "H"  
            first = step
        print(arr)
    else:
        goStep = direction[item]  
print(len(snake) + 1)
```

## 最大社交距离

```
n= 10
nums = [1,1,1,1,-4,1]
steated = []
def paizuo(n,nums):
    for i in range(len(nums)):
        ops = nums[i]
        if ops>0:
            if len(steated) == 0:
                if len(nums) == 1:
                    return 0
                steated.append(0)
            elif len(steated) == 1:
                if len(nums) == 2:
                    return n-1
                steated.append(n-1)
                continue
            elif len(steated)<n:
                max_len = 0
                start = 0
                for j in range(len(steated)-1):
                    max_length = steated[j + 1] - steated[j]
                    if max_length//2 >max_len:
                        max_len = max_length//2
                        start = steated[j]
                steated.append(start+max_len)
                steated.sort()
                if i ==len(nums)-1:
                    return start+max_len
            else:
                return -1
        else:
            index = steated.index(-ops)
            steated.pop(index)
    print(steated)
```

## 最小传输时延

```
while 1:
    try:
        n, m = map(int, input().split())
        map_ = {}
        for i in range(n):
            ui, vi, wi = list(map(int, input().split()))
            if ui not in map_:
                map_[ui] = {}
            map_[ui].update({vi: wi})
 
        s, e = map(int, input().split())
 
 
        # print(map_)
        # {1: {2: 11, 3: 50}, 2: {3: 13}}
 
        def dfs(start, end, high):
            """
            :param start: 起始位置
            :param end: 结束位置
            :param high: 当前深度，超过m跳出
            :return:
            """
            # float("inf") 无穷大
            min_ = float("inf")
            # 假设所有起始点都在map中
            if start not in map_ or high > m:
                return min_
 
            next_ = map_[start]
            if end in next_:
                min_ = min(min_, next_[end])
 
            for k, v in next_.items():
                min_ = min(min_, v + dfs(k, e, high + 1))
 
            return min_
 
 
        print(dfs(s, e, 1))
    except Exception as e:
        break
```

## 叠积木

```
nums = [3,6,3,3,3]
nums = sorted(nums,reverse=True)
#nums = [9 ,9, 9, 5, 3 ,2 ,2, 2 ,2, 2]
total = sum(nums)
max_nums = max(nums)
def dfs(nums,k,target):
    while nums and nums[0] ==target:
        nums.pop(0)
        k-=1
    if nums == []:
        return True
    v = nums[0]
    dp = [0] * k
    for i in range(k):
        if dp[i] +v <=target:
            dp[i]+=v
            if dfs(nums[1:],k,target):
                return True
            dp[i] -=v
        if dp[i]==0:break
    return False
for k in range(2,total//max_nums+1):
    target = total//k
    if total%k ==0 and target >= max_nums:
        flag = dfs(nums, k, target)
        if flag:
           print(k)
```

## 打印任务排序

```
nums = [9,3,5]
#nums= [1,2,2]
new_nums = sorted(nums,reverse=True)
print(new_nums)
res = []
for i in range(len(new_nums)):
    temp = nums[i]
    index = new_nums.index(temp)
    res.append(index)
    new_nums[index] = -1
print(res)
```

## 简易内存池

```
from sys import stdin
 
 
class MiniMemoryPool:
    def __init__(self):
        self.memory = []
 
    def request(self, size: int) -> str:
        if size <= 0 or size > 100:
            return "error"
        if len(self.memory) == 0:
            self.memory.append((0, size - 1))
            return "0"
        else:
            bef_start, bef_stop, insert_index = -1, -1, 0
            for start, stop in self.memory:
                if start == 0:
                    pass
                elif start - bef_stop - 1 >= size:
                    self.memory.insert(insert_index, (bef_stop + 1, bef_stop + size))
                    return str(bef_stop + 1)
                bef_start, bef_stop = start, stop
                insert_index += 1
            if bef_stop + size < 100:
                self.memory.append((bef_stop + 1, bef_stop + size))
                return str(bef_stop + 1)
            else:
                return "error"
 
    def release(self, start_addr: int) -> bool:
        found = False
        found_couple = (0, 0)
        for item in self.memory:
            if item[0] == start_addr:
                found = True
                found_couple = item
                break
        if found:
            self.memory.remove(found_couple)
        return found
 
 
if __name__ == "__main__":
    command_count = int(input())
    pool = MiniMemoryPool()
    for _ in range(command_count):
        command, size = stdin.readline().strip().split("=")
        if command == "REQUEST":
            print(pool.request(int(size)))
        elif command == "RELEASE":
            released = pool.release(int(size))
            if not released:
                print("error")
```

